.. *** docs/index.rst ***

.. pyranges documentation master file, created by
   sphinx-quickstart.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.


The pyranges documentation
==========================
Pyranges is a Python library specifically designed for efficient and intuitive manipulation of genomics data,
particularly genomic intervals (like genes, genomic features, or reads).
The library is optimized for fast querying and manipulation of genomic annotations.

Pyranges is open source, and hosted at github: https://github.com/pyranges/pyranges_1.x/

Pyranges is developed by Endre Bakken Stovner and by
`Marco Mariotti's lab <https://www.mariottigenomicslab.com/>`_.

**This documentation refers to the version 1 of pyranges**, which introduces a new API and a new data structure
compared to version 0, still the 'default', soon to be deprecated. If you are a pyranges v0 user,
check :doc:`this guide to migrate to v1 <./migration_guide>`.


While we recommend using pyranges as Python library, alternatively, the
:doc:`pyranger command-line tool <./pyranger_cli>` allows you to access the same functionalities from the command line,
without writing any Python code.

Citation
~~~~~~~~

Stovner EB, S√¶trom P (2020) PyRanges: efficient comparison of genomic intervals in Python. *Bioinformatics 36(3):918-919*  http://dx.doi.org/10.1093/bioinformatics/btz615

Coming soon: a paper for v1!


Documentation outline
~~~~~~~~~~~~~~~~~~~~~

#. üõ†Ô∏è  :doc:`Installation instructions <./installation>`
#. üìñ  :doc:`The tutorial <./tutorial>`,  recommended for all new users
#. üß∞  :doc:`The how-to pages <./how_to_pages>`, where functionalities are grouped by topic
#. üìë  :doc:`The API reference <./api_reference>`, where all methods are explained in detail
#. üöÄ  :doc:`The cheatsheet <./cheatsheet>`, a quick reference for the most common operations
#. üíª  :doc:`The pyranger command-line tool <./pyranger_cli>`, for those who prefer the command line
#. üßë‚Äçüíª :doc:`The developer guide <./developer_guide>`, to follow in order to contribute to PyRanges
#. üîÑ  :doc:`The guide to migrate to v1 <./migration_guide>`, for existing users of PyRanges v0


.. toctree::
   :maxdepth: 1
   :hidden:
   :caption: Contents:

   installation
   tutorial
   how_to_pages
   api_reference
   cheatsheet
   pyranger_cli
   developer_guide
   migration_guide


Indices
=======

* :ref:`genindex`
* :ref:`modindex`


.. *** docs/api_reference.rst ***


API reference
~~~~~~~~~~~~~

#. :doc:`PyRanges objects <./pyranges_objects>` are the main data structure in pyranges
#. :doc:`The pyranges module <./pyranges_module>` offer file readers and other utilities
#. :doc:`Extensions submodules <./pyranges_extensions>` provide additional domain-specific functionalities
#. :doc:`RangeFrame <./range_frame>` is the parent class of PyRanges, supporting operations on simple intervals

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   pyranges_objects
   pyranges_module
   pyranges_extensions
   range_frame


.. *** docs/pyranges_extensions.rst ***



Extensions submodules
---------------------

Pyranges includes extensions modules that provide additional domain-specific functionalities.

.. toctree::
   :maxdepth: 2

   extension_orfs
   extension_seqs
   extension_stats


.. *** docs/how_to_rows.rst ***

Rows operations
~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2


Indexing with iloc, loc
-----------------------

PyRanges inherits all the indexing and slicing capabilities of pandas, e.g. boolean Series indexing,
``iloc``, ``loc``, ``at``, ``iat``.
Note that these methods return a view, not a copy, with the caveats that it implies.
See the pandas documentation for details.
Briefly, to avoid ambiguity it is best to explicitly call ``copy`` if you want an object to not be linked
to the original object from which it was extracted. For example:

  >>> import pyranges as pr
  >>> gr = pr.example_data.aorta
  >>> gr
  index    |    Chromosome    Start    End      Name      Score    Strand
  int64    |    category      int64    int64    object    int64    category
  -------  ---  ------------  -------  -------  --------  -------  ----------
  0        |    chr1          9916     10115    H3K27me3  5        -
  1        |    chr1          9939     10138    H3K27me3  7        +
  2        |    chr1          9951     10150    H3K27me3  8        -
  3        |    chr1          9953     10152    H3K27me3  5        +
  ...      |    ...           ...      ...      ...       ...      ...
  7        |    chr1          10127    10326    H3K27me3  1        -
  8        |    chr1          10241    10440    H3K27me3  6        -
  9        |    chr1          10246    10445    H3K27me3  4        +
  10       |    chr1          110246   110445   H3K27me3  1        +
  PyRanges with 11 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> sgr = gr.iloc[0:3].copy()
  >>> sgr
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        0  |    chr1             9916    10115  H3K27me3        5  -
        1  |    chr1             9939    10138  H3K27me3        7  +
        2  |    chr1             9951    10150  H3K27me3        8  -
  PyRanges with 3 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> sgr['Score'] = 100  # does not modify gr
  >>> gr.head(3)
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        0  |    chr1             9916    10115  H3K27me3        5  -
        1  |    chr1             9939    10138  H3K27me3        7  +
        2  |    chr1             9951    10150  H3K27me3        8  -
  PyRanges with 3 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

On the other hand, to modify even a few lines of a PyRanges object,
use ``loc`` (label-based indexing) or ``iloc`` (positional indexing) on the whole object, not on a view:

  >>> gr.loc[0:2, 'Score'] = 100  # modifies gr
  >>> gr.head(5)
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        0  |    chr1             9916    10115  H3K27me3      100  -
        1  |    chr1             9939    10138  H3K27me3      100  +
        2  |    chr1             9951    10150  H3K27me3      100  -
        3  |    chr1             9953    10152  H3K27me3        5  +
        4  |    chr1             9978    10177  H3K27me3        7  -
  PyRanges with 5 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Using boolean indexers
-----------------------

In PyRanges, boolean indexers work analogously as in pandas, as already seen in the tutorial:

  >>> sel = (gr['Score'] == 100)
  >>> gr[sel]
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        0  |    chr1             9916    10115  H3K27me3      100  -
        1  |    chr1             9939    10138  H3K27me3      100  +
        2  |    chr1             9951    10150  H3K27me3      100  -
  PyRanges with 3 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> gr[gr.Score==5]
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        3  |    chr1             9953    10152  H3K27me3        5  +
        5  |    chr1            10001    10200  H3K27me3        5  -
  PyRanges with 2 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Combined with ``loc``, boolean indexers can be used to add or update column values:

  >>> gr.loc[gr['Score'] < 6, 'Score'] = -10  # modifies gr
  >>> gr.head(5)
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        0  |    chr1             9916    10115  H3K27me3      100  -
        1  |    chr1             9939    10138  H3K27me3      100  +
        2  |    chr1             9951    10150  H3K27me3      100  -
        3  |    chr1             9953    10152  H3K27me3      -10  +
        4  |    chr1             9978    10177  H3K27me3        7  -
  PyRanges with 5 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

In pandas, these logical operators can be employed with boolean Series:

* "&" =  element-wise AND operator
* "|" = element-wise OR operator
* "~" = NOT operator, inverts the values of the Series on its right

When using logical operators, make sure to parenthesize properly.

Let's get the + intervals with Score<8 starting before 10,000 or ending after 100,000:

  >>> gr[ (gr.Score<8) & (gr.Strand=='+') &
  ...     ((gr.Start<10000) | (gr.End>100000)) ]
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        3  |    chr1             9953    10152  H3K27me3      -10  +
       10  |    chr1           110246   110445  H3K27me3      -10  +
  PyRanges with 2 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

Let's invert the selection:
  >>> gr[~(
  ...      (gr.Score<8) & (gr.Strand=='+') &
  ...      ((gr.Start<10000) | (gr.End>100000)) )]
  index    |    Chromosome    Start    End      Name      Score    Strand
  int64    |    category      int64    int64    object    int64    category
  -------  ---  ------------  -------  -------  --------  -------  ----------
  0        |    chr1          9916     10115    H3K27me3  100      -
  1        |    chr1          9939     10138    H3K27me3  100      +
  2        |    chr1          9951     10150    H3K27me3  100      -
  4        |    chr1          9978     10177    H3K27me3  7        -
  ...      |    ...           ...      ...      ...       ...      ...
  6        |    chr1          10024    10223    H3K27me3  -10      +
  7        |    chr1          10127    10326    H3K27me3  -10      -
  8        |    chr1          10241    10440    H3K27me3  6        -
  9        |    chr1          10246    10445    H3K27me3  -10      +
  PyRanges with 9 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Using PyRanges .loci
---------------------

PyRanges provides the method :func:`loci <pyranges.PyRanges.loci>`
to select rows by genomic region:

  >>> gr2 = pr.example_data.aorta2.sort_ranges()
  >>> gr2
  index    |    Chromosome    Start    End      Name      Score    Strand
  int64    |    category      int64    int64    object    int64    category
  -------  ---  ------------  -------  -------  --------  -------  ----------
  1        |    chr1          10073    10272    Input     1        +
  5        |    chr1          10280    10479    Input     1        +
  6        |    chr1          16056    16255    Input     1        +
  7        |    chr1          16064    16263    Input     1        +
  ...      |    ...           ...      ...      ...       ...      ...
  4        |    chr1          10149    10348    Input     1        -
  3        |    chr1          10082    10281    Input     1        -
  2        |    chr1          10079    10278    Input     1        -
  0        |    chr1          9988     10187    Input     1        -
  PyRanges with 10 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Various syntaxes are accepted, see its API. For example:

  >>> gr2.loci['-'] # get all rows with strand '-'
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        9  |    chr1            19958    20157  Input           1  -
        4  |    chr1            10149    10348  Input           1  -
        3  |    chr1            10082    10281  Input           1  -
        2  |    chr1            10079    10278  Input           1  -
        0  |    chr1             9988    10187  Input           1  -
  PyRanges with 5 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

  >>> gr2.loci['chr1', '+'] # get all rows with chromosome 'chr1' and strand '+'
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        1  |    chr1            10073    10272  Input           1  +
        5  |    chr1            10280    10479  Input           1  +
        6  |    chr1            16056    16255  Input           1  +
        7  |    chr1            16064    16263  Input           1  +
        8  |    chr1            16109    16308  Input           1  +
  PyRanges with 5 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

  >>> gr2.loci['chr1', 10000:11000] # get all rows on 'chr1' and overlapping 10000:11000
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        1  |    chr1            10073    10272  Input           1  +
        5  |    chr1            10280    10479  Input           1  +
        4  |    chr1            10149    10348  Input           1  -
        3  |    chr1            10082    10281  Input           1  -
        2  |    chr1            10079    10278  Input           1  -
        0  |    chr1             9988    10187  Input           1  -
  PyRanges with 6 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> gr2.loci['chr1', '+', 10000:11000] # get all rows on 'chr1', strand '+', and overlapping 10000:11000
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        1  |    chr1            10073    10272  Input           1  +
        5  |    chr1            10280    10479  Input           1  +
  PyRanges with 2 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

  Loci also support assignment. In this case, you must provide a DataFrame with the same shape as the selection:

  >>> gr2.loci['chr1', '+', 10000:11000] = gr2.loci['chr1', '+', 10000:11000].copy().assign(Score=100)
  >>> gr2.loci['chr1', '+', 10000:11000]  # see below that the Score was altered
    index  |    Chromosome      Start      End  Name        Score  Strand
    int64  |    category        int64    int64  object      int64  category
  -------  ---  ------------  -------  -------  --------  -------  ----------
        1  |    chr1            10073    10272  Input         100  +
        5  |    chr1            10280    10479  Input         100  +
  PyRanges with 2 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

  For more flexible assignment, you can use ``loc`` and provide use the ``index`` attribute of ``loci`` output:

  >>> sindex=gr2.loci['chr1', '+', 16000:17000].index
  >>> gr2.loc[sindex, "Score"]=150
  >>> gr2
  index    |    Chromosome    Start    End      Name      Score    Strand
  int64    |    category      int64    int64    object    int64    category
  -------  ---  ------------  -------  -------  --------  -------  ----------
  1        |    chr1          10073    10272    Input     100      +
  5        |    chr1          10280    10479    Input     100      +
  6        |    chr1          16056    16255    Input     150      +
  7        |    chr1          16064    16263    Input     150      +
  ...      |    ...           ...      ...      ...       ...      ...
  4        |    chr1          10149    10348    Input     1        -
  3        |    chr1          10082    10281    Input     1        -
  2        |    chr1          10079    10278    Input     1        -
  0        |    chr1          9988     10187    Input     1        -
  PyRanges with 10 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.



Sorting PyRanges
----------------

PyRanges objects can be sorted (i.e. altering the order of rows) by calling the pandas dataframe method ``sort_values``,
or the PyRanges method :func:`sort_ranges <pyranges.PyRanges.sort_ranges>`.

  >>> import random; random.seed(1)
  >>> c = pr.example_data.chipseq.remove_nonloc_columns()
  >>> c['peak'] = [random.randint(0, 1000) for _ in range(len(c))] # add a column with random values
  >>> c
  index    |    Chromosome    Start      End        Strand      peak
  int64    |    category      int64      int64      category    int64
  -------  ---  ------------  ---------  ---------  ----------  -------
  0        |    chr8          28510032   28510057   -           137
  1        |    chr7          107153363  107153388  -           582
  2        |    chr5          135821802  135821827  -           867
  3        |    chr14         19418999   19419024   -           821
  ...      |    ...           ...        ...        ...         ...
  16       |    chr9          120803448  120803473  +           96
  17       |    chr6          89296757   89296782   -           499
  18       |    chr1          194245558  194245583  +           29
  19       |    chr8          57916061   57916086   +           914
  PyRanges with 20 rows, 5 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.


Pandas ``sort_values`` sorts the whole dataframe by the specified columns. See its API for details.
For example, let's sort by column ``peak``:

  >>> c.sort_values(by='peak', ascending=False)
  index    |    Chromosome    Start      End        Strand      peak
  int64    |    category      int64      int64      category    int64
  -------  ---  ------------  ---------  ---------  ----------  -------
  19       |    chr8          57916061   57916086   +           914
  2        |    chr5          135821802  135821827  -           867
  3        |    chr14         19418999   19419024   -           821
  14       |    chr2          152562484  152562509  -           807
  ...      |    ...           ...        ...        ...         ...
  7        |    chr19         19571102   19571127   +           120
  16       |    chr9          120803448  120803473  +           96
  5        |    chr21         40099618   40099643   +           64
  18       |    chr1          194245558  194245583  +           29
  PyRanges with 20 rows, 5 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.


PyRanges :func:`sort_ranges <pyranges.PyRanges.sort_ranges>` is designed for genomic ranges.
By default, it sorts by Chromosome, Strand, then interval coordinates. If Strands are valid (
see :func:`strand_valid <pyranges.PyRanges.strand_valid>`), then intervals on the reverse strand are
sorted in reverse order:

  >>> c.sort_ranges()
  index    |    Chromosome    Start      End        Strand      peak
  int64    |    category      int64      int64      category    int64
  -------  ---  ------------  ---------  ---------  ----------  -------
  12       |    chr1          38457520   38457545   +           667
  18       |    chr1          194245558  194245583  +           29
  13       |    chr1          80668132   80668157   -           388
  14       |    chr2          152562484  152562509  -           807
  ...      |    ...           ...        ...        ...         ...
  4        |    chr12         106679761  106679786  -           782
  3        |    chr14         19418999   19419024   -           821
  7        |    chr19         19571102   19571127   +           120
  5        |    chr21         40099618   40099643   +           64
  PyRanges with 20 rows, 5 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.


Above, ``chr8`` appears before ``chr10`` because of 'natural sorting'. We can force alphabetical sorting instead:

  >>> c.sort_ranges(natsort=False)
  index    |    Chromosome    Start      End        Strand      peak
  int64    |    category      int64      int64      category    int64
  -------  ---  ------------  ---------  ---------  ----------  -------
  12       |    chr1          38457520   38457545   +           667
  18       |    chr1          194245558  194245583  +           29
  13       |    chr1          80668132   80668157   -           388
  9        |    chr10         35419784   35419809   -           779
  ...      |    ...           ...        ...        ...         ...
  19       |    chr8          57916061   57916086   +           914
  0        |    chr8          28510032   28510057   -           137
  6        |    chr8          22714402   22714427   -           261
  16       |    chr9          120803448  120803473  +           96
  PyRanges with 20 rows, 5 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.
    
To sort by a different column, use the first argument (``by``). This is used after Chromosome and Strand, but before
coordinates:

  >>> c.sort_ranges('peak')
  index    |    Chromosome    Start      End        Strand      peak
  int64    |    category      int64      int64      category    int64
  -------  ---  ------------  ---------  ---------  ----------  -------
  18       |    chr1          194245558  194245583  +           29
  12       |    chr1          38457520   38457545   +           667
  13       |    chr1          80668132   80668157   -           388
  14       |    chr2          152562484  152562509  -           807
  ...      |    ...           ...        ...        ...         ...
  4        |    chr12         106679761  106679786  -           782
  3        |    chr14         19418999   19419024   -           821
  7        |    chr19         19571102   19571127   +           120
  5        |    chr21         40099618   40099643   +           64
  PyRanges with 20 rows, 5 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

To use a different priorization of genomic location columns, specify them in the first argument (``by``):

  >>> c.sort_ranges(['peak', 'Chromosome', 'Strand'])
  index    |    Chromosome    Start      End        Strand      peak
  int64    |    category      int64      int64      category    int64
  -------  ---  ------------  ---------  ---------  ----------  -------
  18       |    chr1          194245558  194245583  +           29
  12       |    chr1          38457520   38457545   +           667
  13       |    chr1          80668132   80668157   -           388
  14       |    chr2          152562484  152562509  -           807
  ...      |    ...           ...        ...        ...         ...
  4        |    chr12         106679761  106679786  -           782
  3        |    chr14         19418999   19419024   -           821
  7        |    chr19         19571102   19571127   +           120
  5        |    chr21         40099618   40099643   +           64
  PyRanges with 20 rows, 5 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.





.. *** docs/tutorial.rst ***

Tutorial
========

:class:`PyRanges <pyranges.PyRanges>` objects represent sequence intervals ("ranges") such as genomic regions.
Examples include gene annotations, mapped reads, protein domains, and results from
Blast or analogous software. Pyranges provides convenient methods to load data in
GFF, GTF, BED, BAM format. In this tutorial, we refer to PyRanges objects for their
typical use case, i.e. representing genomic intervals, but the same concepts and methods
may be applied to RNA or protein sequences.

Every interval in a PyRanges object is defined, at minimum, by its chromosome and start
and end coordinates. Optionally, the strand (+ or -) can also be present; if so, the
PyRanges object is "Stranded". The ranges can additionally have an arbitrary number
of meta-data fields, i.e. columns associated with them.

Note that PyRanges follows the standard python convention:

* coordinates are **0-based**
* in each interval, the **start is included** and the **end is excluded**.

Some genomic coordinate formats (GFF, GTF) use a 1-based, start-and-end-included format.
Pyranges takes care of converting between these conventions when loading and writing files in these formats.

PyRanges objects are a subclass of  `Pandas <https://pandas.pydata.org/>`_ DataFrame, extending its functionalities
to genomic operations. This means that the vast pandas/numpy ecosystem for high-performance scientific computing is
available to manipulate the data directly in PyRanges objects. While not strictly necessary, having
familiarity with pandas greatly facilitates the use of PyRanges.

.. contents:: Contents of Tutorial
   :depth: 3


Getting started
~~~~~~~~~~~~~~~

We recommend using `ipython <https://ipython.readthedocs.io/>`_ or `Jupyter <https://jupyter.org/>`_ for this tutorial.
Besides pyranges and pandas, we will use optional modules (e.g. **pyfaidx**).
If you haven't already, install the optional add-ons with:

.. code-block:: shell

      pip install pyranges1[add-ons]


Loading and accessing pyranges objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's import libraries, and load in memory an example annotation in GFF3 format, consisting of a portion of the genome
annotation of the worm *Dimorphilus gyrociliatus*.

  >>> import pyranges as pr
  >>> ann = pr.example_data.ncbi_gff
  >>> ann
  index    |    Chromosome         Source    Feature     Start    End      Score     Strand      Frame     ...
  int64    |    category           object    category    int64    int64    object    category    object    ...
  -------  ---  -----------------  --------  ----------  -------  -------  --------  ----------  --------  -----
  0        |    CAJFCJ010000053.1  EMBL      region      0        109277   .         +           .         ...
  1        |    CAJFCJ010000053.1  EMBL      gene        4882     5264     .         -           .         ...
  2        |    CAJFCJ010000053.1  EMBL      mRNA        4882     5264     .         -           .         ...
  3        |    CAJFCJ010000053.1  EMBL      exon        4882     5264     .         -           .         ...
  ...      |    ...                ...       ...         ...      ...      ...       ...         ...       ...
  146      |    CAJFCJ010000025.1  EMBL      CDS         2753     2851     .         -           0         ...
  147      |    CAJFCJ010000025.1  EMBL      CDS         2593     2693     .         -           1         ...
  148      |    CAJFCJ010000025.1  EMBL      CDS         2354     2537     .         -           0         ...
  149      |    CAJFCJ010000025.1  EMBL      CDS         2174     2294     .         -           0         ...
  PyRanges with 150 rows, 21 columns, and 1 index columns. (13 columns not shown: "ID", "Dbxref", "gbkey", ...).
  Contains 6 chromosomes and 2 strands.

Above, we leveraged the builtin example data. In real use cases, you would load data from a file, using methods like
:func:`read_gtf <pyranges.read_gtf>`, :func:`read_bed <pyranges.read_bed>` and others (see all readers in
:doc:`pyranges_module`).

The ``ann`` object has lots of columns, most of which are not displayed because of space. Here's the full list:

  >>> ann.columns
  Index(['Chromosome', 'Source', 'Feature', 'Start', 'End', 'Score', 'Strand',
         'Frame', 'ID', 'Dbxref', 'gbkey', 'mol_type', 'note', 'Name',
         'gene_biotype', 'locus_tag', 'Parent', 'Note', 'standard_name',
         'product', 'protein_id'],
        dtype='object')


Let's select only certain columns. We can use the method
:func:`get_with_loc_columns <pyranges.PyRanges.get_with_loc_columns>` to select columns by name, and
retain the "genomic location" columns **Chromosome, Start, End**, (and **Strand** if present):

  >>> ann = ann.get_with_loc_columns(['Feature', 'Parent', 'ID'])
  >>> ann
  index    |    Chromosome         Start    End      Strand      Feature     Parent                 ...
  int64    |    category           int64    int64    category    category    object                 ...
  -------  ---  -----------------  -------  -------  ----------  ----------  ---------------------  -----
  0        |    CAJFCJ010000053.1  0        109277   +           region      nan                    ...
  1        |    CAJFCJ010000053.1  4882     5264     -           gene        nan                    ...
  2        |    CAJFCJ010000053.1  4882     5264     -           mRNA        gene-DGYR_LOCUS13733   ...
  3        |    CAJFCJ010000053.1  4882     5264     -           exon        rna-DGYR_LOCUS13733    ...
  ...      |    ...                ...      ...      ...         ...         ...                    ...
  146      |    CAJFCJ010000025.1  2753     2851     -           CDS         rna-DGYR_LOCUS12552-2  ...
  147      |    CAJFCJ010000025.1  2593     2693     -           CDS         rna-DGYR_LOCUS12552-2  ...
  148      |    CAJFCJ010000025.1  2354     2537     -           CDS         rna-DGYR_LOCUS12552-2  ...
  149      |    CAJFCJ010000025.1  2174     2294     -           CDS         rna-DGYR_LOCUS12552-2  ...
  PyRanges with 150 rows, 7 columns, and 1 index columns. (1 columns not shown: "ID").
  Contains 6 chromosomes and 2 strands.

The Chromosome column can take any value among the sequence names in the genome assembly.
In top-quality assemblies, it corresponds to actual chromosomes, and in other cases it is contigs or scaffolds;
for simplicity, here we refer to it as chromosomes. In a fasta file, the sequence name is the first word of a header
line (i.e. those starting with ">"). Let's peek the assembly fasta file available as example data:

  >>> genome_file = pr.example_data.files['ncbi.fasta']
  >>> with open(genome_file) as fh:
  ...   for _ in range(8):
  ...     print(fh.readline().strip())
  >CAJFCJ010000053.1 Dimorphilus gyrociliatus genome assembly, contig: scaffold053, whole genome shotgun sequence
  aaaaaaagaagtttttgacaaactttttctttttttcatcaagCTTTGTATAATGGACAA
  ACTAACgcaactttttcaattactGTTAACAAACTACCTGAAACAATTTACAATTCAAAA
  AGTACATTTTGTATTAGAAATTATTCCAAGAAAATTCAAGTAGATTTGAAATTCATGATT
  TAACTTGTGAAATTGTGTataaggaaaatatataaatattttcaaaactgTTACTTTGGA
  TACTAAAGAAATTCCattagaaataattgaaatatttgtatatacttcaccaaatgaaag
  aatgaatgaaataagtaaaaataaaatggagaaatttttttttttaattttttttctctt
  tcttcctttattCATAGctttatttgataatttcaaGAGTATAATTGAAGAGATCAGTGT


Genomic annotations often contain information for diverse entities, such as genes, mRNAs, exons, CDS, etc.
In GFF files, the entity type is encoded in the Feature column. In pyranges, you use the dot notation to
fetch an individual column, which is technically a pandas Series:

  >>> ann.Feature # or ann['Feature']
  0      region
  1        gene
  2        mRNA
  3        exon
  4         CDS
          ...
  145       CDS
  146       CDS
  147       CDS
  148       CDS
  149       CDS
  Name: Feature, Length: 150, dtype: category
  Categories (5, object): ['CDS', 'exon', 'gene', 'mRNA', 'region']


The syntax ``ann[column_name]`` is also available, and must be used when creating or updating a column.
Let's create a new column with the midpoint of each interval:

  >>> ann['midpoint'] = (ann.Start + ann.End) // 2
  >>> ann.get_with_loc_columns(['midpoint'])
  index    |    Chromosome         Start    End      Strand      midpoint
  int64    |    category           int64    int64    category    int64
  -------  ---  -----------------  -------  -------  ----------  ----------
  0        |    CAJFCJ010000053.1  0        109277   +           54638
  1        |    CAJFCJ010000053.1  4882     5264     -           5073
  2        |    CAJFCJ010000053.1  4882     5264     -           5073
  3        |    CAJFCJ010000053.1  4882     5264     -           5073
  ...      |    ...                ...      ...      ...         ...
  146      |    CAJFCJ010000025.1  2753     2851     -           2802
  147      |    CAJFCJ010000025.1  2593     2693     -           2643
  148      |    CAJFCJ010000025.1  2354     2537     -           2445
  149      |    CAJFCJ010000025.1  2174     2294     -           2234
  PyRanges with 150 rows, 5 columns, and 1 index columns.
  Contains 6 chromosomes and 2 strands.

Let's focus on a row subset of the annotation: CDS intervals, corresponding to coding sequences.
We filter rows and create a new PyRanges object called ``cds``:

  >>> selector = (ann.Feature == 'CDS')
  >>> cds = ann [selector]

The object ``selector`` is a Series of boolean values, so it can be used to index PyRanges.

Now, let's further reduce the width of the cds object.
We showcase an alternative method for column selection: ``drop`` lets us choose which columns to discard.

  >>> cds = cds.drop( ['Feature', 'Parent', 'midpoint'], axis=1 )
  >>> cds
  index    |    Chromosome         Start    End      Strand      ID
  int64    |    category           int64    int64    category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
  4        |    CAJFCJ010000053.1  4882     5263     -           cds-CAD5126491.1
  11       |    CAJFCJ010000053.1  10732    10958    +           cds-CAD5126492.1
  12       |    CAJFCJ010000053.1  11028    11169    +           cds-CAD5126492.1
  13       |    CAJFCJ010000053.1  11227    11400    +           cds-CAD5126492.1
  ...      |    ...                ...      ...      ...         ...
  146      |    CAJFCJ010000025.1  2753     2851     -           cds-CAD5125114.1
  147      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125114.1
  148      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125114.1
  149      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125114.1
  PyRanges with 56 rows, 5 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.


``drop`` is actually a method of pandas dataframe, inherited by PyRanges.
Whenever a pandas methods is applied to a PyRanges object, if the returned object has the genomic location columns,
then it is returned as a PyRanges object. Otherwise, a dataframe is returned.

We already seen a boolean selector to filter rows. The ``loc`` and ``iloc`` pandas operators are also available.
Besides, pyranges offers the :func:`loci <pyranges.PyRanges.loci>` operator for selecting intervals in a
genomic region of interest. It accepts various syntaxes.
The code below will show intervals overlapping with the specified position range in the requested chromosome:

  >>> reg = cds.loci['CAJFCJ010000097.1', '+', 50000:55000]
  >>> reg
  index    |    Chromosome         Start    End      Strand      ID
  int64    |    category           int64    int64    category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
  110      |    CAJFCJ010000097.1  51865    52382    +           cds-CAD5126878.1
  111      |    CAJFCJ010000097.1  52446    52826    +           cds-CAD5126878.1
  112      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126878.1
  113      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126878.1
  ...      |    ...                ...      ...      ...         ...
  121      |    CAJFCJ010000097.1  52261    52382    +           cds-CAD5126877.1
  122      |    CAJFCJ010000097.1  52446    52826    +           cds-CAD5126877.1
  123      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126877.1
  124      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126877.1
  PyRanges with 9 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

We cannot see all rows because of space. We can set how many rows are displayed using
:func:`pyranges.options.set_option`:

  >>> pr.options.set_option('max_rows_to_show', 10)
  >>> reg
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
      110  |    CAJFCJ010000097.1    51865    52382  +           cds-CAD5126878.1
      111  |    CAJFCJ010000097.1    52446    52826  +           cds-CAD5126878.1
      112  |    CAJFCJ010000097.1    52903    53027  +           cds-CAD5126878.1
      113  |    CAJFCJ010000097.1    53339    53404  +           cds-CAD5126878.1
      120  |    CAJFCJ010000097.1    51865    52201  +           cds-CAD5126877.1
      121  |    CAJFCJ010000097.1    52261    52382  +           cds-CAD5126877.1
      122  |    CAJFCJ010000097.1    52446    52826  +           cds-CAD5126877.1
      123  |    CAJFCJ010000097.1    52903    53027  +           cds-CAD5126877.1
      124  |    CAJFCJ010000097.1    53339    53404  +           cds-CAD5126877.1
  PyRanges with 9 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

Let's go back to default display settings:

  >>> pr.options.reset_options()

Working with groups of exons
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Multi-exonic genes are represented with multiple rows in PyRanges. In this tutorial, the ``ID`` column links the
intervals belonging to the same CDS: these rows have the same ID value.
While this concept applies to all annotations, files from different sources may use different column names
for this purpose (e.g. transcript_id). Note that here we focus on CDS regions. These may encompass multiple exons,
but they do not span the whole mRNA: the 5'UTRs and 3'UTRs are not included.
Various PyRanges methods are available to work with groups of intervals, accepting argument ``group_by``.

Next, we will examine the first and last codon of annotated CDSs.
We will obtain their genomic coordinate, then fetch their sequence.

Method :func:`slice_ranges <pyranges.PyRanges.slice_ranges>` allows to obtain a subregion of
groups of intervals. The code below derives the first codon of each CDS group; grouping is defined by their ID:

  >>> first=cds.slice_ranges(start=0, end=3, group_by='ID')
  >>> first
  index    |    Chromosome         Start    End      Strand      ID
  int64    |    category           int64    int64    category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
  4        |    CAJFCJ010000053.1  5260     5263     -           cds-CAD5126491.1
  11       |    CAJFCJ010000053.1  10732    10735    +           cds-CAD5126492.1
  18       |    CAJFCJ010000053.1  19649    19652    +           cds-CAD5126493.1
  25       |    CAJFCJ010000053.1  27136    27139    -           cds-CAD5126494.1
  ...      |    ...                ...      ...      ...         ...
  120      |    CAJFCJ010000097.1  51865    51868    +           cds-CAD5126877.1
  135      |    CAJFCJ010000025.1  2753     2755     -           cds-CAD5125115.1
  136      |    CAJFCJ010000025.1  2692     2693     -           cds-CAD5125115.1
  145      |    CAJFCJ010000025.1  3150     3153     -           cds-CAD5125114.1
  PyRanges with 18 rows, 5 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.

Let's **fetch the sequence** for each of these intervals from our genome fasta file.

The function :func:`get_sequence <pyranges.PyRanges.get_sequence>` returns one sequence per interval, which we assign to a new column of our pyranges object:

  >>> first['Sequence'] = first.get_sequence(genome_file)  #genome_file defined above
  >>> first
  index    |    Chromosome         Start    End      Strand      ID                Sequence
  int64    |    category           int64    int64    category    object            object
  -------  ---  -----------------  -------  -------  ----------  ----------------  ----------
  4        |    CAJFCJ010000053.1  5260     5263     -           cds-CAD5126491.1  ATG
  11       |    CAJFCJ010000053.1  10732    10735    +           cds-CAD5126492.1  ATG
  18       |    CAJFCJ010000053.1  19649    19652    +           cds-CAD5126493.1  ATG
  25       |    CAJFCJ010000053.1  27136    27139    -           cds-CAD5126494.1  ATG
  ...      |    ...                ...      ...      ...         ...               ...
  120      |    CAJFCJ010000097.1  51865    51868    +           cds-CAD5126877.1  ATG
  135      |    CAJFCJ010000025.1  2753     2755     -           cds-CAD5125115.1  at
  136      |    CAJFCJ010000025.1  2692     2693     -           cds-CAD5125115.1  g
  145      |    CAJFCJ010000025.1  3150     3153     -           cds-CAD5125114.1  ATG
  PyRanges with 18 rows, 6 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.


The ``Sequence`` column is a pandas Series containing strings. We see that the starting codon is ATG in most cases, as expected.
When we check the length of the sequences, we notice that some are not 3-letter long:

  >>> bool( (first.Sequence.str.len() == 3 ).all() )
  False

Let's look at those sequences, using a row selector as before:

  >>> first [ first.Sequence.str.len() != 3 ]
    index  |    Chromosome           Start      End  Strand      ID                Sequence
    int64  |    category             int64    int64  category    object            object
  -------  ---  -----------------  -------  -------  ----------  ----------------  ----------
      135  |    CAJFCJ010000025.1     2753     2755  -           cds-CAD5125115.1  at
      136  |    CAJFCJ010000025.1     2692     2693  -           cds-CAD5125115.1  g
  PyRanges with 2 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.


In some cases the starting codon is split between two exons. This is uncommon, but expected at least in a few genes
in a genome. How do we get the full codon sequence?

Function :func:`get_sequence <pyranges.PyRanges.get_sequence>` can accept a ``group_by`` argument,
thus returning the concatenated sequence of a group of intervals,
i.e. joining exons together. The sequence is given 5' to 3'.

  >>> seq_first = first.get_sequence(genome_file, group_by='ID')
  >>> seq_first # doctest: +NORMALIZE_WHITESPACE
  ID
  cds-CAD5125114.1    ATG
  cds-CAD5125115.1    atg
  cds-CAD5126491.1    ATG
  cds-CAD5126492.1    ATG
  cds-CAD5126493.1    ATG
  cds-CAD5126494.1    ATG
  cds-CAD5126495.1    ATG
  cds-CAD5126496.1    atg
  cds-CAD5126497.1    ATG
  cds-CAD5126498.1    atg
  cds-CAD5126499.1    atg
  cds-CAD5126873.1    ATG
  cds-CAD5126874.1    ATG
  cds-CAD5126875.1    ATG
  cds-CAD5126876.1    ATG
  cds-CAD5126877.1    ATG
  cds-CAD5126878.1    ATG
  Name: Sequence, dtype: object

Note that, when :func:`get_sequence <pyranges.PyRanges.get_sequence>` is called with the ``group_by`` argument,
the output is indexed by the group_by column, in this case the ``ID``. Here we confirm the sequence length is always 3:

  >>> bool( (seq_first.str.len()==3).all() )
  True


Ok, so far we got the coordinates and sequences of the first codon of each CDS.

Now let's look at  stop codons.
First, we get the a pyranges object of the last codon of each CDS.
Conveniently, :func:`slice_ranges <pyranges.PyRanges.slice_ranges>` accepts negative arguments
to count from the 3', so we can obtain the last three nucleotides of CDSs with:

  >>> last = cds.slice_ranges(start=-3, group_by='ID')

By not providing an ``end`` argument, we requested intervals that reach the very end of each CDS group.
Let's get their sequence as before:

  >>> seq_last = last.get_sequence(genome_file, group_by='ID').str.upper()
  >>> seq_last # doctest: +NORMALIZE_WHITESPACE
  ID
  cds-CAD5125114.1    TGA
  cds-CAD5125115.1    TGA
  cds-CAD5126491.1    TAA
  cds-CAD5126492.1    TGA
  cds-CAD5126493.1    TAA
  cds-CAD5126494.1    TAG
  cds-CAD5126495.1    TAA
  cds-CAD5126496.1    TGA
  cds-CAD5126497.1    TAA
  cds-CAD5126498.1    TAA
  cds-CAD5126499.1    TAG
  cds-CAD5126873.1    TGA
  cds-CAD5126874.1    TAG
  cds-CAD5126875.1    TAA
  cds-CAD5126876.1    TGA
  cds-CAD5126877.1    TAA
  cds-CAD5126878.1    TAA
  Name: Sequence, dtype: object


Let's use pandas ``value_counts`` to see the usage of stop codons:

  >>> seq_last.value_counts()
  Sequence
  TAA    8
  TGA    6
  TAG    3
  Name: count, dtype: int64

Say we want to focus on CDSs with a TAA stop codon. Let's gather the IDs of those CDSs:

  >>> taa_stop_ids = seq_last[ seq_last == 'TAA' ].index

We can now use this list to subset the ``cds`` object:

  >>> taa_stop_cds = cds[ cds.ID.isin(taa_stop_ids) ]


Writing coordinates and sequences to the disk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We obtained a custom genome annotation, consisting of CDS with a TAA stop codon.
We can now write this :class:`PyRanges <pyranges.PyRanges>`
object to a file, for example in GTF format using method :func:`to_gtf <pyranges.PyRanges.to_gtf>`:

  >>> taa_stop_cds.to_gtf('Dgyro.taa_CDS.gtf')


Let's get the sequence for these CDSs and write it to a tabular file using pandas method ``to_csv``:

  >>> taa_stop_cds_seqs = taa_stop_cds.get_sequence(genome_file, group_by='ID')
  >>> taa_stop_cds_seqs.to_csv('Dgyro_taa_CDS_seqs.tsv', sep='\t', index=True)

Note that ``taa_stop_cds_seqs`` is a pandas Series. To write sequences in fasta format we may use:

  >>> with open('Dgyro_taa_CDS_seqs.fa', 'w') as fw: # doctest: +SKIP
  ...   for xid, xseq in taa_stop_cds_seqs.itertuples():
  ...     fw.write(f'>{xid}\n{xseq}\n')


Extending genomic intervals
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we want to obtain (a toy approximation of) promoter sequences, here defined as the
300bp region before the start codon. Before we begin, let's peek into our object ``cds`` using
the pandas method ``head``:

  >>> cds.head()
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
        4  |    CAJFCJ010000053.1     4882     5263  -           cds-CAD5126491.1
       11  |    CAJFCJ010000053.1    10732    10958  +           cds-CAD5126492.1
       12  |    CAJFCJ010000053.1    11028    11169  +           cds-CAD5126492.1
       13  |    CAJFCJ010000053.1    11227    11400  +           cds-CAD5126492.1
       14  |    CAJFCJ010000053.1    11453    14183  +           cds-CAD5126492.1
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

First, we use the method  :func:`extend_ranges <pyranges.PyRanges.extend_ranges>`
to obtain intervals which include the CDS and the promoter defined as above.
We will group by the ID column, so that the extension is applied to each CDS group
(i.e. in this case only the 5' most
interval of each group).

  >>> g = cds.extend_ranges(ext_5=300, group_by='ID')
  >>> g.head()
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
        4  |    CAJFCJ010000053.1     4882     5563  -           cds-CAD5126491.1
       11  |    CAJFCJ010000053.1    10432    10958  +           cds-CAD5126492.1
       12  |    CAJFCJ010000053.1    11028    11169  +           cds-CAD5126492.1
       13  |    CAJFCJ010000053.1    11227    11400  +           cds-CAD5126492.1
       14  |    CAJFCJ010000053.1    11453    14183  +           cds-CAD5126492.1
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

In the object we obtained, the promoter corresponds to the first 300 bp of every interval group.
We can use method :func:`slice_ranges <pyranges.PyRanges.slice_ranges>`  again to get it:

  >>> prom = g.slice_ranges(0, 300, group_by='ID')
  >>> prom.head()
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
        4  |    CAJFCJ010000053.1     5263     5563  -           cds-CAD5126491.1
       11  |    CAJFCJ010000053.1    10432    10732  +           cds-CAD5126492.1
       18  |    CAJFCJ010000053.1    19349    19649  +           cds-CAD5126493.1
       25  |    CAJFCJ010000053.1    27139    27439  -           cds-CAD5126494.1
       32  |    CAJFCJ010000053.1    38860    39160  +           cds-CAD5126495.1
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

So far we applied :func:`extend_ranges <pyranges.PyRanges.extend_ranges>` and
:func:`slice_ranges <pyranges.PyRanges.slice_ranges>` to obtain the regions immediately upstream of each CDS group.
In latest versions, pyranges offers a direct method to perform this operation, called
:func:`upstream <pyranges.PyRanges.upstream>` (as well as its 3' analog
:func:`downstream <pyranges.PyRanges.downstream>`):

  >>> cds.upstream(length=300, group_by='ID').head()
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
        4  |    CAJFCJ010000053.1     5263     5563  -           cds-CAD5126491.1
       11  |    CAJFCJ010000053.1    10432    10732  +           cds-CAD5126492.1
       18  |    CAJFCJ010000053.1    19349    19649  +           cds-CAD5126493.1
       25  |    CAJFCJ010000053.1    27139    27439  -           cds-CAD5126494.1
       32  |    CAJFCJ010000053.1    38860    39160  +           cds-CAD5126495.1
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Because we extended intervals, some may have gone out-of-bounds on the left or on the right side:
they may have a Start smaller than 0, or an End greater than the length of its chromosome, respectively.
The function :func:`clip_ranges <pyranges.PyRanges.clip_ranges>`
is designed to correct this:

  >>> import pyfaidx
  >>> pyf=pyfaidx.Fasta(genome_file)
  >>> cor_prom = prom.clip_ranges(chromsizes=pyf)
  >>> cor_prom.head()
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
        4  |    CAJFCJ010000053.1     5263     5563  -           cds-CAD5126491.1
       11  |    CAJFCJ010000053.1    10432    10732  +           cds-CAD5126492.1
       18  |    CAJFCJ010000053.1    19349    19649  +           cds-CAD5126493.1
       25  |    CAJFCJ010000053.1    27139    27439  -           cds-CAD5126494.1
       32  |    CAJFCJ010000053.1    38860    39160  +           cds-CAD5126495.1
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

To detect cases of out-of-bounds on the right side, :func:`clip_ranges <pyranges.PyRanges.clip_ranges>`
needs to know chromosome sizes.
Various input types are accepted for the ``chromsizes`` argument; above, we used a ``pyfaidx.Fasta``
object, which derives it from a fasta file.

You see below that some intervals were gone out-of-bounds on the right side, and have been corrected:

  >>> select_diff_end = cor_prom.End != prom.End
  >>> prom[select_diff_end]
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
      145  |    CAJFCJ010000025.1     3153     3453  -           cds-CAD5125114.1
  PyRanges with 1 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

  >>> cor_prom[select_diff_end]
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
      145  |    CAJFCJ010000025.1     3153     3418  -           cds-CAD5125114.1
  PyRanges with 1 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.


Detecting overlaps among intervals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pyranges offers many efficient methods to detect overlaps, such as
:func:`overlap <pyranges.PyRanges.overlap>`.
This method returns the rows in self that overlap with another PyRanges object.

Let's see if any of the promoter regions overlap other CDSs:

  >>> cor_prom.overlap(cds)
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
      135  |    CAJFCJ010000025.1     2755     3055  -           cds-CAD5125115.1
  PyRanges with 1 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

As many PyRanges methods, the Strand (if present) is taken into account in the comparison, so that
the overlap between intervals is reported only if they are on the same strand.
Argument ``strand_behavior`` is available in many functions to control how strand is handled in overlap comparisons
(see :func:`overlap <pyranges.PyRanges.overlap>`).

Above, we obtained the promoter region that overlaps another CDS, but we don't know what CDS it is.
Function :func:`join_overlaps <pyranges.PyRanges.join_overlaps>` will find overlaps and combine the columns
of the overlapping intervals, similar to a SQL join operation:

  >>> j = cor_prom.join_overlaps(cds)
  >>> j
    index  |    Chromosome           Start      End  Strand      ID                  Start_b    End_b  ID_b
    int64  |    category             int64    int64  category    object                int64    int64  object
  -------  ---  -----------------  -------  -------  ----------  ----------------  ---------  -------  ----------------
       15  |    CAJFCJ010000025.1     2755     3055  -           cds-CAD5125115.1       2753     2851  cds-CAD5125114.1
  PyRanges with 1 rows, 8 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.


The object ``j`` contains the columns of both objects, with the suffix "_b" to distinguish the second one (``cds``).
It may be a bit too wide for our taste. Let's just look at a few columns to understand the overlap:

  >>> j[['ID', 'Start', 'End', 'ID_b', 'Start_b', 'End_b']]
                    ID  Start   End              ID_b  Start_b  End_b
  15  cds-CAD5125115.1   2755  3055  cds-CAD5125114.1     2753   2851

Above, we used a pandas syntax to select columns. Because the returned object does not have all genomic location
columns, it is a pandas DataFrame.

Let's get the intersection between the overlapping intervals, using function
:func:`intersect_overlaps <pyranges.PyRanges.intersect_overlaps>`:

  >>> prom_in_cds = cor_prom.intersect_overlaps(cds)
  >>> prom_in_cds
    index  |    Chromosome           Start      End  Strand      ID
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
      135  |    CAJFCJ010000025.1     2755     2851  -           cds-CAD5125115.1
  PyRanges with 1 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.


Let's go back to the ``cds`` object and see if any of its intervals overlap each other.
We can use :func:`cluster_overlaps <pyranges.PyRanges.cluster_overlaps>`. This will assign each interval to a cluster,
identified by an integer. The intervals that overlap each other will be assigned to the same cluster.

  >>> clu_cds = cds.cluster_overlaps()
  >>> clu_cds
  index    |    Chromosome         Start    End      Strand      ID                Cluster
  int64    |    category           int64    int64    category    object            uint32
  -------  ---  -----------------  -------  -------  ----------  ----------------  ---------
  138      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125115.1  0
  149      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125114.1  0
  137      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125115.1  1
  148      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125114.1  1
  ...      |    ...                ...      ...      ...         ...               ...
  95       |    CAJFCJ010000097.1  5579     6029     -           cds-CAD5126874.1  47
  94       |    CAJFCJ010000097.1  6082     6450     -           cds-CAD5126874.1  48
  93       |    CAJFCJ010000097.1  6505     6599     -           cds-CAD5126874.1  49
  103      |    CAJFCJ010000097.1  31876    32194    -           cds-CAD5126876.1  50
  PyRanges with 56 rows, 6 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.

Let's get the clusters that have more than one interval in them, using pandas
identified by an integer. The intervals that overlap each other will be assigned to the same cluster.

  >>> clu_cds = cds.cluster_overlaps()
  >>> clu_cds
  index    |    Chromosome         Start    End      Strand      ID                Cluster
  int64    |    category           int64    int64    category    object            uint32
  -------  ---  -----------------  -------  -------  ----------  ----------------  ---------
  138      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125115.1  0
  149      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125114.1  0
  137      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125115.1  1
  148      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125114.1  1
  ...      |    ...                ...      ...      ...         ...               ...
  95       |    CAJFCJ010000097.1  5579     6029     -           cds-CAD5126874.1  47
  94       |    CAJFCJ010000097.1  6082     6450     -           cds-CAD5126874.1  48
  93       |    CAJFCJ010000097.1  6505     6599     -           cds-CAD5126874.1  49
  103      |    CAJFCJ010000097.1  31876    32194    -           cds-CAD5126876.1  50
  PyRanges with 56 rows, 6 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.

Let's get the clusters that have more than one interval in them, using pandas
identified by an integer. The intervals that overlap each other will be assigned to the same cluster.

  >>> clu_cds = cds.cluster_overlaps()
  >>> clu_cds
  index    |    Chromosome         Start    End      Strand      ID                Cluster
  int64    |    category           int64    int64    category    object            uint32
  -------  ---  -----------------  -------  -------  ----------  ----------------  ---------
  138      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125115.1  0
  149      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125114.1  0
  137      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125115.1  1
  148      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125114.1  1
  ...      |    ...                ...      ...      ...         ...               ...
  95       |    CAJFCJ010000097.1  5579     6029     -           cds-CAD5126874.1  47
  94       |    CAJFCJ010000097.1  6082     6450     -           cds-CAD5126874.1  48
  93       |    CAJFCJ010000097.1  6505     6599     -           cds-CAD5126874.1  49
  103      |    CAJFCJ010000097.1  31876    32194    -           cds-CAD5126876.1  50
  PyRanges with 56 rows, 6 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.

Let's get the clusters that have more than one interval in them, using pandas ``value_counts``:

  >>> c = clu_cds.Cluster.value_counts()
  >>> multi_clusters = c[ c > 1 ].index
  >>> multi_clu_cds = clu_cds[ clu_cds.Cluster.isin(multi_clusters) ].copy()
  >>> multi_clu_cds
  index    |    Chromosome         Start    End      Strand      ID                Cluster
  int64    |    category           int64    int64    category    object            uint32
  -------  ---  -----------------  -------  -------  ----------  ----------------  ---------
  138      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125115.1  0
  149      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125114.1  0
  137      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125115.1  1
  148      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125114.1  1
  ...      |    ...                ...      ...      ...         ...               ...
  112      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126878.1  44
  123      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126877.1  44
  113      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126878.1  45
  124      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126877.1  45
  PyRanges with 17 rows, 6 columns, and 1 index columns.
  Contains 2 chromosomes and 2 strands.

Sorting intervals
~~~~~~~~~~~~~~~~~
Above, it is not apparent that there are overlaps among the intervals in the object ``multi_clu_cds``. This is due to
the order of rows. We could sort rows using pandas ``sort_values``, but Pyranges offers something
better: the method :func:`sort_ranges <pyranges.PyRanges.sort_ranges>` sorts by chromosome, strand, then by
coordinates. By default, intervals are sorted 5' to 3', meaning that intervals on the positive strand are sorted
from left-most to right-most, while intervals on the negative strand are sorted in the opposite direction.

  >>> multi_clu_cds.sort_ranges()
  index    |    Chromosome         Start    End      Strand      ID                Cluster
  int64    |    category           int64    int64    category    object            uint32
  -------  ---  -----------------  -------  -------  ----------  ----------------  ---------
  146      |    CAJFCJ010000025.1  2753     2851     -           cds-CAD5125114.1  3
  135      |    CAJFCJ010000025.1  2753     2755     -           cds-CAD5125115.1  3
  136      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125115.1  2
  147      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125114.1  2
  ...      |    ...                ...      ...      ...         ...               ...
  112      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126878.1  44
  123      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126877.1  44
  113      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126878.1  45
  124      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126877.1  45
  PyRanges with 17 rows, 6 columns, and 1 index columns.
  Contains 2 chromosomes and 2 strands.


:func:`sort_ranges <pyranges.PyRanges.sort_ranges>` can be combined by Pandas ``sort_values`` to customize the sorting.
For example, let's add a columns with the lengths of each interval.
Thus, sort by chromosome, strand, length, then interval coordinates:

  >>> multi_clu_cds['Length'] = multi_clu_cds.lengths()
  >>> multi_clu_cds.sort_ranges().sort_values(["Chromosome", "Strand", "Length"], kind="stable")
  index    |    Chromosome         Start    End      Strand      ID                Cluster    Length
  int64    |    category           int64    int64    category    object            uint32     int64
  -------  ---  -----------------  -------  -------  ----------  ----------------  ---------  --------
  135      |    CAJFCJ010000025.1  2753     2755     -           cds-CAD5125115.1  3          2
  146      |    CAJFCJ010000025.1  2753     2851     -           cds-CAD5125114.1  3          98
  136      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125115.1  2          100
  147      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125114.1  2          100
  ...      |    ...                ...      ...      ...         ...               ...        ...
  120      |    CAJFCJ010000097.1  51865    52201    +           cds-CAD5126877.1  42         336
  111      |    CAJFCJ010000097.1  52446    52826    +           cds-CAD5126878.1  43         380
  122      |    CAJFCJ010000097.1  52446    52826    +           cds-CAD5126877.1  43         380
  110      |    CAJFCJ010000097.1  51865    52382    +           cds-CAD5126878.1  42         517
  PyRanges with 17 rows, 7 columns, and 1 index columns.
  Contains 2 chromosomes and 2 strands.

Other overlap-based operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Say that we are interested in intergenic regions in chromosome ``CAJFCJ010000097.1``.
In any genome annotation, the annotation rows "exon" define transcript coordinates. Let's fetch them from
the annotation ``ann``:

  >>> exons = ann[ ann.Feature == 'exon' ].loci['CAJFCJ010000097.1']
  >>> exons
  index    |    Chromosome         Start    End      Strand      Feature     Parent                 ...
  int64    |    category           int64    int64    category    category    object                 ...
  -------  ---  -----------------  -------  -------  ----------  ----------  ---------------------  -----
  86       |    CAJFCJ010000097.1  2248     3308     +           exon        rna-DGYR_LOCUS14091    ...
  90       |    CAJFCJ010000097.1  6505     6600     -           exon        rna-DGYR_LOCUS14092    ...
  91       |    CAJFCJ010000097.1  6082     6450     -           exon        rna-DGYR_LOCUS14092    ...
  92       |    CAJFCJ010000097.1  5579     6029     -           exon        rna-DGYR_LOCUS14092    ...
  ...      |    ...                ...      ...      ...         ...         ...                    ...
  116      |    CAJFCJ010000097.1  52261    52382    +           exon        rna-DGYR_LOCUS14095-2  ...
  117      |    CAJFCJ010000097.1  52446    52826    +           exon        rna-DGYR_LOCUS14095-2  ...
  118      |    CAJFCJ010000097.1  52903    53027    +           exon        rna-DGYR_LOCUS14095-2  ...
  119      |    CAJFCJ010000097.1  53339    53404    +           exon        rna-DGYR_LOCUS14095-2  ...
  PyRanges with 15 rows, 8 columns, and 1 index columns. (2 columns not shown: "ID", "midpoint").
  Contains 1 chromosomes and 2 strands.

Let's define the boundaries of each mRNA, e.g. the left and right limits of its exons. While this may be readily
available in the genome annotation, let's use PyRanges to calculate them, using
:func:`outer_ranges <pyranges.PyRanges.outer_ranges>`:

  >>> mRNA_bounds = exons.outer_ranges(group_by='Parent')
  >>> mRNA_bounds
    index  |    Chromosome           Start      End  Strand      Parent
    int64  |    category             int64    int64  category    object
  -------  ---  -----------------  -------  -------  ----------  ---------------------
        0  |    CAJFCJ010000097.1     2248     3308  +           rna-DGYR_LOCUS14091
        1  |    CAJFCJ010000097.1    16697    17634  +           rna-DGYR_LOCUS14093
        2  |    CAJFCJ010000097.1    51864    53404  +           rna-DGYR_LOCUS14095
        3  |    CAJFCJ010000097.1    51864    53404  +           rna-DGYR_LOCUS14095-2
        4  |    CAJFCJ010000097.1     5579     6600  -           rna-DGYR_LOCUS14092
        5  |    CAJFCJ010000097.1    31876    32195  -           rna-DGYR_LOCUS14094
  PyRanges with 6 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

To get the intergenic regions, let's define the maximum and minimum coordinates of any mRNA in this region,
using :func:`outer_ranges <pyranges.PyRanges.outer_ranges>` again without ``group_by``. Because we want our result to
not depend on strand, we remove it using :func:`remove_strand <pyranges.PyRanges.remove_strand>`:

  >>> all_mRNA_bounds = mRNA_bounds.remove_strand().outer_ranges()
  >>> all_mRNA_bounds
    index  |    Chromosome           Start      End
    int64  |    category             int64    int64
  -------  ---  -----------------  -------  -------
        0  |    CAJFCJ010000097.1     2248    53404
  PyRanges with 1 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

Now we can get the intergenic regions using :func:`subtract_overlaps <pyranges.PyRanges.subtract_overlaps>`:

  >>> intergenic = all_mRNA_bounds.subtract_overlaps(mRNA_bounds)
  >>> intergenic
    index  |    Chromosome           Start      End
    int64  |    category             int64    int64
  -------  ---  -----------------  -------  -------
        0  |    CAJFCJ010000097.1     3308     5579
        0  |    CAJFCJ010000097.1     6600    16697
        0  |    CAJFCJ010000097.1    17634    31876
        0  |    CAJFCJ010000097.1    32195    51864
  PyRanges with 4 rows, 3 columns, and 1 index columns (with 3 index duplicates).
  Contains 1 chromosomes.

Note that pyranges indicates that the object has duplicate indices, because all come from the same row in
``all_mRNA_bounds``, broken into subintervals by the subtraction operation.
We can use pandas ``reset_index`` to remedy:

  >>> intergenic = intergenic.reset_index(drop=True)
  >>> intergenic
    index  |    Chromosome           Start      End
    int64  |    category             int64    int64
  -------  ---  -----------------  -------  -------
        0  |    CAJFCJ010000097.1     3308     5579
        1  |    CAJFCJ010000097.1     6600    16697
        2  |    CAJFCJ010000097.1    17634    31876
        3  |    CAJFCJ010000097.1    32195    51864
  PyRanges with 4 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.


Counting overlaps
~~~~~~~~~~~~~~~~~

Often, one wants to count the number of overlaps between two PyRanges objects, e.g. to count reads in specific regions.
Here, let's count the number of CDS intervals that overlap our previously computed objects ``intergenic``
and  ``all_mRNA_bounds``, using  method :func:`count_overlaps <pyranges.PyRanges.count_overlaps>` :

  >>> intergenic.count_overlaps(cds)
    index  |    Chromosome           Start      End     Count
    int64  |    category             int64    int64    uint32
  -------  ---  -----------------  -------  -------  --------
	0  |    CAJFCJ010000097.1     3308     5579         0
	1  |    CAJFCJ010000097.1     6600    16697         0
	2  |    CAJFCJ010000097.1    17634    31876         0
	3  |    CAJFCJ010000097.1    32195    51864         0
  PyRanges with 4 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes.

  >>> all_mRNA_bounds.count_overlaps(cds)
    index  |    Chromosome           Start      End     Count
    int64  |    category             int64    int64    uint32
  -------  ---  -----------------  -------  -------  --------
        0  |    CAJFCJ010000097.1     2248    53404        15
  PyRanges with 1 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes.

As expected, there's no CDS overlapping the intergenic regions, while the other object reports 15. Yet,
the CDS intervals may be redundant: different splicing isoforms may have some identical exons:

  >>> example = cds.loci['CAJFCJ010000097.1', '+', 51000:54000].sort_ranges()
  >>> example
  index    |    Chromosome         Start    End      Strand      ID
  int64    |    category           int64    int64    category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
  120      |    CAJFCJ010000097.1  51865    52201    +           cds-CAD5126877.1
  110      |    CAJFCJ010000097.1  51865    52382    +           cds-CAD5126878.1
  121      |    CAJFCJ010000097.1  52261    52382    +           cds-CAD5126877.1
  111      |    CAJFCJ010000097.1  52446    52826    +           cds-CAD5126878.1
  ...      |    ...                ...      ...      ...         ...
  112      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126878.1
  123      |    CAJFCJ010000097.1  52903    53027    +           cds-CAD5126877.1
  113      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126878.1
  124      |    CAJFCJ010000097.1  53339    53404    +           cds-CAD5126877.1
  PyRanges with 9 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.


If we want to calculate the intervals that are annotated as CDS in any of the isoforms, we can use
method :func:`merge_overlaps <pyranges.PyRanges.merge_overlaps>` :

  >>> example.merge_overlaps()
    index  |    Chromosome           Start      End  Strand
    int64  |    category             int64    int64  category
  -------  ---  -----------------  -------  -------  ----------
        0  |    CAJFCJ010000097.1    51865    52382  +
        1  |    CAJFCJ010000097.1    52446    52826  +
        2  |    CAJFCJ010000097.1    52903    53027  +
        3  |    CAJFCJ010000097.1    53339    53404  +
  PyRanges with 4 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

Various methods are available to obtain non-overlapping intervals, depending on the desired output. See
:func:`split_overlaps <pyranges.PyRanges.split_overlaps>`, :func:`max_disjoint_overlaps <pyranges.PyRanges.max_disjoint_overlaps>`.

Finally, let's count how many non-redundant CDS intervals overlap our target region:

  >>> all_mRNA_bounds.count_overlaps(cds.merge_overlaps())
    index  |    Chromosome           Start      End     Count
    int64  |    category             int64    int64    uint32
  -------  ---  -----------------  -------  -------  --------
        0  |    CAJFCJ010000097.1     2248    53404        10
  PyRanges with 1 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes.

AI coding assistant
~~~~~~~~~~~~~~~~~~~

Nowadays, coding is greatly facilitated by AI coding assistants (ChatGPT, Copilot, etc.).
Pyranges provides methods to streamline the use of such tools to generate or modify pyranges codes.
There are two main functions for this purpose. The first one is :func:`export_docs <pyranges.assistant.export_docs>`.
It generates a text file with the documentation of all pyranges functionalities:

  >>> pr.assistant.export_docs("pyranges_docs.txt")

The second one is :func:`prompt <pyranges.assistant.prompt>`:

  >>> pr.assistant.prompt()
  'Act as an expert bioinformatician programmer experienced in pyranges (complete documentation attached for you to learn). Next, answer my requests for code by first explaining the workflow, followed by oneliner-style code snippets, as concise as possible but elegant, preceded by the text of task as commented code. Ensure you use pyranges v1 interface that you find here, rather than the v0, from which you may have seen examples before; v1 renamed many methods. '


This concludes our tutorial. The next pages will delve into pyranges functionalities grouped by topic.


.. *** docs/pyranges_objects.rst ***


PyRanges objects
----------------

The main object in pyranges is the PyRanges object.
It is a pandas DataFrame with additional methods for genomic operations.


.. autoclass:: pyranges.PyRanges
   :members:


.. *** docs/pyranger_cli.rst ***

Command-line interface: pyranger
================================

Pyranger lets you access core functionalities directly from your shell:
build a pyranges-based pipeline in one command, without writing any
Python code.

Installation
------------

Pyranger is based on `Google's Python Fire <https://github.com/google/python-fire>`__.
which is an optional dependency. To install it, use::

   pip install pyranges1[cli]


Quick Start
-----------

Run pyranger with no arguments to print a usage summary
along these lines::

   Read sequence interval data into PyRanges and apply a chain of methods

   Usage:
     pyranger reader <args> , [var=reader <args>]‚Ä¶ , method <args> , ‚Ä¶

     ‚Ä¢ The command line defines a pipeline of actions separated by " , " and starting with readers
     ‚Ä¢ The first reader loads the main PyRanges object
     ‚Ä¢ Every reader beyond the first *must* be named (e.g. b=read_bed b.bed)
     ‚Ä¢ Methods are invoked on the main object; others can be provided as arguments, e.g. intersect_overlaps b
     ‚Ä¢ The result replaces the main object in the pipeline

Readers
-------

Every pyranger command line must begin with one of these possible readers:

- :func:`read_bed <pyranges.read_bed>` <path> [<options>]
- :func:`read_gtf <pyranges.read_gtf>` <path> [<options>]
- :func:`read_gff3 <pyranges.read_gff3>` <path> [<options>]
- :func:`read_bam <pyranges.read_bam>` <path> [<options>]
- :func:`read_bigwig <pyranges.read_bigwig>` <path> [<options>]
- read_csv  <path> [<options>]   # wrapped from Pandas


The first reader (unnamed) becomes the ‚Äúmain‚Äù PyRanges object.
Without further operations, pyranger will print its content to stdout::

   pyranger read_bed sample1.bed

    index  |    Chromosome      Start      End  Name      Score     Strand        ThickStart
    int64  |    category        int64    int64  object    object    category           int64
  -------  ---  ------------  -------  -------  --------  --------  ----------  ------------
        0  |    chr1                1        5  .         .         +                      1
        1  |    chr1                6        8  .         .         -                      2
  PyRanges with 2 rows, 7 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


*(From here onwards, the output of commands is omitted.)*

Some operations (e.g. intersect_overlaps) require two objects.
You can chain multiple readers and methods together, separated by a comma surrounded by spaces
(:literal:` , `). After the first one, all subsequent readers
must be named into variables that can be used later.
For example, to read two BED files and intersect them, use::

   pyranger read_bed sample1.bed , b=read_bed sample2.bed , intersect_overlaps b

Methods
-------

After reader(s), pyranger pipelines consists of methods applied to the main PyRanges object.
As before, the separator is a comma surrounded by spaces (:literal:` , `)::

   pyranger read_bed a.bed , downstream 10

   pyranger read_bed a.bed , head

Methods available include all those implemented by :class:`PyRanges <pyranges.PyRanges>` objects,
as well as those from Pandas DataFrames, which are inherited.

Arguments
---------

Arguments can be passed to readers/methods either positionally or by name::

   pyranger read_bed sample1.bed , downstream 10 --gap=5

   pyranger read_bed sample1.bed , b=read_bed sample2.bed , intersect_overlaps b --multiple first

Typically, the last method in a pipeline will be the one that outputs the result
(e.g., :func:`to_bed <pyranges.PyRanges.to_bed>`, :func:`to_csv <pyranges.PyRanges.to_csv>`,
:func:`to_gtf <pyranges.PyRanges.to_gtf>`, :func:`to_gff3 <pyranges.PyRanges.to_csv>`)::

   pyranger read_bed sample1.bed , downstream 10 --gap=5 , to_bed output.bed
   pyranger read_bed sample1.bed , b=read_bed sample2.bed , intersect_overlaps b , to_csv output.tsv --sep $'\t'

Getting help
------------

To view arguments for a specific reader/method, append ``--help`` immediately after its name.
For methods, include the full context of your pipeline::

   pyranger read_bed --help

   pyranger read_bed a.bed , downstream --help


Examples
--------

Below are some common workflows. Everything after a separator (:literal:` , `) is
either a named reader or a method invocation, in sequence:

1. **Load a single BED file**::

     pyranger read_bed sample1.bed

   Loads `sample1.bed` into a `PyRanges` object and prints its content.

2. **Load + inspect first 5 lines**::

     pyranger read_bed sample1.bed , head 5

   - ``read_bed sample1.bed`` becomes the main object  
   - ``head 5`` takes the first five rows of that `PyRanges`.

3. **Intersect two BED files**::

     pyranger read_bed a.bed , other=read_bed b.bed , intersect_overlaps other

   - ``read_bed a.bed`` ‚Üí main object  
   - ``other=read_bed b.bed`` ‚Üí variable ``other``  
   - ``intersect_overlaps other`` ‚Üí runs ``.intersect_overlaps(other)``

4. **Chain three readers and two methods**::

     pyranger read_bed a.bed , b=read_bed b.bed , c=read_bed c.bed , join_overlaps b , intersect_overlaps c

   - Load `a.bed` as main  
   - Load `b.bed` into ``b`` and `c.bed` into ``c``  
   - Run ``.join_overlaps(b)`` on the main object, then ``.intersect_overlaps(c)`` on the result


Final notes
-----------

To discover the functionalities available in pyranger,
we recommend reading the rest of the pyranges documentation, especially the
:doc:`tutorial <./tutorial>` and :doc:`how-to pages <./how_to_pages>`.
While these are written in Python, the same concepts and methods are
accessible through pyranger.

Note that some cases may not be fully supported in pyranger.
If you struggle to express a specific operation,
consider building a custom Python script using pyranges instead.



.. *** docs/how_to_sequences.rst ***


Working with sequences
~~~~~~~~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2

Fetching sequences per interval
-------------------------------

A common operation is to fetch the sequences corresponding to the intervals
represented in the PyRanges object. Let's see an example with built-in data.

  >>> import pyranges as pr
  >>> genome_file = pr.example_data.files['ncbi.fasta']
  >>> sg = pr.example_data.ncbi_gff
  >>> sg = sg[sg.Feature == 'CDS'].get_with_loc_columns('ID')
  >>> sg = sg.sort_ranges().head(20).copy()
  >>> sg
  index    |    Chromosome         Start    End      Strand      ID
  int64    |    category           int64    int64    category    object
  -------  ---  -----------------  -------  -------  ----------  ----------------
  145      |    CAJFCJ010000025.1  3111     3153     -           cds-CAD5125114.1
  146      |    CAJFCJ010000025.1  2753     2851     -           cds-CAD5125114.1
  135      |    CAJFCJ010000025.1  2753     2755     -           cds-CAD5125115.1
  136      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125115.1
  ...      |    ...                ...      ...      ...         ...
  41       |    CAJFCJ010000053.1  77280    77395    +           cds-CAD5126496.1
  42       |    CAJFCJ010000053.1  77458    77655    +           cds-CAD5126496.1
  43       |    CAJFCJ010000053.1  77724    77839    +           cds-CAD5126496.1
  44       |    CAJFCJ010000053.1  77899    78770    +           cds-CAD5126496.1
  PyRanges with 20 rows, 5 columns, and 1 index columns.
  Contains 2 chromosomes and 2 strands.

Function :func:`get_sequence <pyranges.PyRanges.get_sequence>`
takes the path to a fasta file, and returns a Series containing those sequences, with the same index as the PyRanges object.
It requires the package pyfaidx (see :doc:`add-ons installation <./installation>`.
:func:`get_sequence <pyranges.PyRanges.get_sequence>` will treat each interval independently. The Series returned
is typically used to create a new column in the PyRanges object:

  >>> sg['Sequence'] = sg.get_sequence(genome_file)
  >>> sg
  index    |    Chromosome         Start    End      Strand      ID                ...
  int64    |    category           int64    int64    category    object            ...
  -------  ---  -----------------  -------  -------  ----------  ----------------  -----
  145      |    CAJFCJ010000025.1  3111     3153     -           cds-CAD5125114.1  ...
  146      |    CAJFCJ010000025.1  2753     2851     -           cds-CAD5125114.1  ...
  135      |    CAJFCJ010000025.1  2753     2755     -           cds-CAD5125115.1  ...
  136      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125115.1  ...
  ...      |    ...                ...      ...      ...         ...               ...
  41       |    CAJFCJ010000053.1  77280    77395    +           cds-CAD5126496.1  ...
  42       |    CAJFCJ010000053.1  77458    77655    +           cds-CAD5126496.1  ...
  43       |    CAJFCJ010000053.1  77724    77839    +           cds-CAD5126496.1  ...
  44       |    CAJFCJ010000053.1  77899    78770    +           cds-CAD5126496.1  ...
  PyRanges with 20 rows, 6 columns, and 1 index columns. (1 columns not shown: "Sequence").
  Contains 2 chromosomes and 2 strands.

  >>> sg.Sequence.head()
  145           ATGTCGCGACAGAGTGGGAGATCAAATGATCCTCGAAAAGTA
  146    AGTGGGGAATTATTGACCCTTACCTACGGAGCTTTGGTTGCTCAGC...
  135                                                   at
  136    ggGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCAGA...
  147    ggGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCAGA...

For intervals on the negative strand, the sequence has been reverse complemented.

The ``Sequence`` Series is amenable to string operations, using the pandas ``.str`` operator.
Let's convert it to uppercase:

  >>> sg['Sequence'] = sg.Sequence.str.upper()
  >>> sg.Sequence.head()
  145           ATGTCGCGACAGAGTGGGAGATCAAATGATCCTCGAAAAGTA
  146    AGTGGGGAATTATTGACCCTTACCTACGGAGCTTTGGTTGCTCAGC...
  135                                                   AT
  136    GGGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCAGA...
  147    GGGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCAGA...

Fetching sequences per mRNA
---------------------------

Often we're interested in the sequence of a transcript, i.e. the concatenation of the exons.
Using the argument ``group_by`` in function :func:`get_sequence <pyranges.PyRanges.get_sequence>` allows to get just
that, by concatenating the sequences of the intervals in the PyRanges object in the correct order:

  >>> mrna_seq = sg.get_sequence(genome_file, group_by='ID')
  >>> mrna_seq # doctest: +NORMALIZE_WHITESPACE
  ID
  cds-CAD5125114.1    ATGTCGCGACAGAGTGGGAGATCAAATGATCCTCGAAAAGTAAGTG...
  cds-CAD5125115.1    atggGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCA...
  cds-CAD5126492.1    ATGAAGATTTTTGctataatatcaatatattttatattatctgAGT...
  cds-CAD5126493.1    ATGAAtttctatagaaatttttttaatttaattttttgtattaaag...
  cds-CAD5126495.1    ATGGATTTAGACTTTTTTGCTATATGGTCACCAACTGTAAATTTGA...
  cds-CAD5126496.1    atggtTATATGCATATTAAGAACTACAGACAACAAAATGAGAATAA...
  Name: Sequence, dtype: object

Again, let's convert to uppercase:

  >>> mrna_seq = mrna_seq.str.upper()
  >>> mrna_seq # doctest: +NORMALIZE_WHITESPACE
  ID
  cds-CAD5125114.1    ATGTCGCGACAGAGTGGGAGATCAAATGATCCTCGAAAAGTAAGTG...
  cds-CAD5125115.1    ATGGGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCA...
  cds-CAD5126492.1    ATGAAGATTTTTGCTATAATATCAATATATTTTATATTATCTGAGT...
  cds-CAD5126493.1    ATGAATTTCTATAGAAATTTTTTTAATTTAATTTTTTGTATTAAAG...
  cds-CAD5126495.1    ATGGATTTAGACTTTTTTGCTATATGGTCACCAACTGTAAATTTGA...
  cds-CAD5126496.1    ATGGTTATATGCATATTAAGAACTACAGACAACAAAATGAGAATAA...
  Name: Sequence, dtype: object

Filtering by sequence
---------------------

The ``Sequence`` column can be used to filter the PyRanges object.
For example, let's get intervals whose sequence starts with a G:

  >>> g_sg= sg[sg.Sequence.str.startswith('G')]
  >>> g_sg[ ['ID', 'Sequence'] ] # show only ID and Sequence to allow display
                     ID                                           Sequence
  136  cds-CAD5125115.1  GGGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCAGA...
  147  cds-CAD5125114.1  GGGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCAGA...
  138  cds-CAD5125115.1  GTTCAGTTGGAAGTTGAAACGAAAATTGTTCAGGATCAATTAAAAG...
  149  cds-CAD5125114.1  GTTCAGTTGGAAGTTGAAACGAAAATTGTTCAGGATCAATTAAAAG...
  12   cds-CAD5126492.1  GTCTAAAGGTTTTCGATACTTGTTTCAGTAAGTTTCATACATCAAA...
  13   cds-CAD5126492.1  GAATTCTTGGACCAACTACTAGTGCTATATCCGAAACTATATCCAC...
  42   cds-CAD5126496.1  GTTAAATGGTAAAAACTATGGTGGAAATCCTATACCTGAAAAAAGT...

We can use a regular expression as a filter. Let's get those with CC, followed by 1 to 3 characters, then AA:

  >>> pat_sg = sg[sg.Sequence.str.contains(r'CCC.{1,3}AA', regex=True)]
  >>> pat_sg[ ['ID', 'Sequence'] ] # show only ID and Sequence to allow display
                    ID                                           Sequence
  14  cds-CAD5126492.1  TCTCTTGCTTCATTAATGGAAAAATTTGGCTGGAATTTTATTCTAA...
  43  cds-CAD5126496.1  TTCCAAATGATGATGCTACCCATAAAATATGTCTCTTTGAAACATT...
  44  cds-CAD5126496.1  TGTTTCTGTTGTTGATCCCACTAAGGCATCGGTAGATCTTACTGGC...

Let's check the mRNA sequence instead. Let's get the sequences with TTTT in their first 200 nucleotides:

  >>> z = mrna_seq[mrna_seq.str[:200].str.contains('TTTT')]
  >>> z # doctest: +NORMALIZE_WHITESPACE
  ID
  cds-CAD5125115.1    ATGGGCTATAATATAGGAATACGTTTAATAGAAGACTTTCTAGCCA...
  cds-CAD5126492.1    ATGAAGATTTTTGCTATAATATCAATATATTTTATATTATCTGAGT...
  cds-CAD5126493.1    ATGAATTTCTATAGAAATTTTTTTAATTTAATTTTTTGTATTAAAG...
  cds-CAD5126495.1    ATGGATTTAGACTTTTTTGCTATATGGTCACCAACTGTAAATTTGA...
  cds-CAD5126496.1    ATGGTTATATGCATATTAAGAACTACAGACAACAAAATGAGAATAA...
  Name: Sequence, dtype: object

Now let's filter the original PyRanges object to get all interval groups with these IDs:

  >>> zsg = sg[sg.ID.isin(z.index)]
  >>> zsg
  index    |    Chromosome         Start    End      Strand      ID                ...
  int64    |    category           int64    int64    category    object            ...
  -------  ---  -----------------  -------  -------  ----------  ----------------  -----
  135      |    CAJFCJ010000025.1  2753     2755     -           cds-CAD5125115.1  ...
  136      |    CAJFCJ010000025.1  2593     2693     -           cds-CAD5125115.1  ...
  137      |    CAJFCJ010000025.1  2354     2537     -           cds-CAD5125115.1  ...
  138      |    CAJFCJ010000025.1  2174     2294     -           cds-CAD5125115.1  ...
  ...      |    ...                ...      ...      ...         ...               ...
  41       |    CAJFCJ010000053.1  77280    77395    +           cds-CAD5126496.1  ...
  42       |    CAJFCJ010000053.1  77458    77655    +           cds-CAD5126496.1  ...
  43       |    CAJFCJ010000053.1  77724    77839    +           cds-CAD5126496.1  ...
  44       |    CAJFCJ010000053.1  77899    78770    +           cds-CAD5126496.1  ...
  PyRanges with 15 rows, 6 columns, and 1 index columns. (1 columns not shown: "Sequence").
  Contains 2 chromosomes and 2 strands.

Translation and reverse complement
----------------------------------

The submodule :mod:`pyranges.seqs` contains functions to translate sequences and reverse complement them.
They can operate on a single sequence, or a Series of sequences as below:

  >>> sg['Protein'] = pr.seqs.translate(sg.Sequence)
  >>> sg['RevComp'] = pr.seqs.reverse_complement(sg.Sequence)
  >>> sg[ ['ID', 'Sequence', 'Protein', 'RevComp'] ].head(1).transpose()  # to allow display
                                                   145
  ID                                  cds-CAD5125114.1
  Sequence  ATGTCGCGACAGAGTGGGAGATCAAATGATCCTCGAAAAGTA
  Protein                               MSRQSGRSNDPRKV
  RevComp   TACTTTTCGAGGATCATTTGATCTCCCACTCTGTCGCGACAT


.. *** docs/how_to_overlap.rst ***

Overlap-related operations
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2

Overlap-related operations: cheatsheet
======================================

.. image:: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/examples/cheatsheet_overlap.png
   :alt: PyRanges cheatsheet
   :target: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/examples/cheatsheet_overlap.png

Single and pairwise PyRanges operations
======================================

Pyranges offers many efficient methods to detect / process overlaps. We present them here split in two groups:

1. Methods accepting a **pair of PyRanges** as input:

.. autosummary::
    :toctree: _generated_hidden
    :template: custom_method_summary.rst

    pyranges.PyRanges.overlap
    pyranges.PyRanges.join_overlaps
    pyranges.PyRanges.set_intersect_overlaps
    pyranges.PyRanges.set_union_overlaps
    pyranges.PyRanges.intersect_overlaps
    pyranges.PyRanges.subtract_overlaps
    pyranges.PyRanges.count_overlaps
    pyranges.PyRanges.nearest_ranges

2. Methods accepting a **single PyRanges** as input:

.. autosummary::
    :toctree: _generated_hidden2
    :template: custom_method_summary.rst

    pyranges.PyRanges.cluster_overlaps
    pyranges.PyRanges.merge_overlaps
    pyranges.PyRanges.split_overlaps
    pyranges.PyRanges.max_disjoint_overlaps


Methods for pairs of PyRanges
=============================
These methods accept two PyRanges objects as input (i.e. self and other),
and return a new PyRanges object with the results of the operation.

We will briefly showcase them in this document. First, let's create two PyRanges objects to work with:

  >>> import pyranges as pr
  >>> a = pr.PyRanges(dict(Chromosome="chr1",
  ...                      Start=[3, 13, 18, 23, 28, 32, 33],
  ...                      End=[6, 15, 21, 27, 29, 37, 36],
  ...                      Strand=["+", "+", "-", "-", "-", "+", "+"]))
  >>> a
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                3        6  +
        1  |    chr1               13       15  +
        2  |    chr1               18       21  -
        3  |    chr1               23       27  -
        4  |    chr1               28       29  -
        5  |    chr1               32       37  +
        6  |    chr1               33       36  +
  PyRanges with 7 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> b = pr.PyRanges(dict(Chromosome="chr1",
  ...                      Start=[6, 12, 19, 25, 34],
  ...                      End=[8, 14, 20, 29, 36],
  ...                      Strand=["+", "+", "+", "-", "+"]))
  >>> b
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                6        8  +
        1  |    chr1               12       14  +
        2  |    chr1               19       20  +
        3  |    chr1               25       29  -
        4  |    chr1               34       36  +
  PyRanges with 5 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Filter rows: overlap
--------------------

The most intuitive overlap-related method is :func:`overlap <pyranges.PyRanges.overlap>`.
This is simply a filter of the intervals in self, so that only those overlapping any interval in other are returned:

  >>> a.overlap(b)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        1  |    chr1               13       15  +
        3  |    chr1               23       27  -
        4  |    chr1               28       29  -
        5  |    chr1               32       37  +
        6  |    chr1               33       36  +
  PyRanges with 5 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Let's now filter the rows of the other PyRanges object:

  >>> b.overlap(a)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        1  |    chr1               12       14  +
        3  |    chr1               25       29  -
        4  |    chr1               34       36  +
  PyRanges with 3 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Note above how intervals overlapping with more than one interval in the other PyRanges are not reported multiple times.
Use ``multiple=True`` to do so.

To get the self intervals **without overlap** in other, use ``invert=True``:

  >>> a.overlap(b, invert=True)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
	0  |    chr1                3        6  +
	2  |    chr1               18       21  -
  PyRanges with 2 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

A reminder that intervals are encoded in pythonic convention:
0-based coordinates, with start included and end excluded.
Thus, the closest possible intervals that are not overlapping are two intervals wherein
the end of the first is equal of the start of the second. These are called **"bookended"** intervals, e.g.:

  >>> a.head(1)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                3        6  +
  PyRanges with 1 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

  >>> b.head(1)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                6        8  +
  PyRanges with 1 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.


Common arguments: slack, strand_behavior, match_by
--------------------------------------------------

We will now use :func:`overlap <pyranges.PyRanges.overlap>` to showcase arguments
that are available in many overlap-related methods.

``slack`` (default: 0) is used to relax the criteria of overlap.
A value of 1 will report bookended intervals, previously not considered overlapping:

  >>> b.overlap(a, slack=1)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
	0  |    chr1                6        8  +
	1  |    chr1               12       14  +
	3  |    chr1               25       29  -
	4  |    chr1               34       36  +
  PyRanges with 4 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Analogously, higher values will report  increasingly distant intervals.
In practice, the self intervals are temporarily extended by the slack amount on both ends before the overlap operation.

``strand_behavior`` determines how strand is treated.
The value 'same' results in the intuitive behavior, i.e. two intervals overlap only if on the same strand:

  >>> b.overlap(a, strand_behavior="same")  # the result here is the same as: a.overlap(b)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        1  |    chr1               12       14  +
        3  |    chr1               25       29  -
        4  |    chr1               34       36  +
  PyRanges with 3 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

On the other hand, value 'ignore' will define overlaps regardless of strands:

  >>> a.overlap(b, strand_behavior="ignore")
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
	1  |    chr1               13       15  +
	2  |    chr1               18       21  -
	3  |    chr1               23       27  -
	4  |    chr1               28       29  -
	5  |    chr1               32       37  +
	6  |    chr1               33       36  +
  PyRanges with 6 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Value 'opposite' will require two intervals to be on the opposite strands to be considered overlapping:

  >>> a.overlap(b, strand_behavior="opposite")
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
	2  |    chr1               18       21  -
  PyRanges with 1 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

Naturally, values 'same' and 'opposite' can only be used when the PyRanges objects have
valid strand information, i.e. the Strand column is present and all its values are either '+' or '-':

  >>> b_unstranded = b.remove_strand()
  >>> b_unstranded
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                6        8
        1  |    chr1               12       14
        2  |    chr1               19       20
        3  |    chr1               25       29
        4  |    chr1               34       36
  PyRanges with 5 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

  >>> a.overlap(b_unstranded, strand_behavior="same")
  Traceback (most recent call last):
    ...
  ValueError: Can only do same strand operations when both PyRanges contain valid strand info.

See function :func:`strand_valid <pyranges.PyRanges.strand_valid>` for details, and
:func:`make_strand_valid <pyranges.PyRanges.make_strand_valid>` to convert non-standard strand values to standard ones.

The default value of ``strand_behavior`` is 'auto'.
This is transformed to 'same' if both PyRanges have valid strands, and to 'ignore' otherwise:

  >>> a.overlap(b).equals(
  ... a.overlap(b, strand_behavior='same') )
  True

  >>> a.overlap(b_unstranded).equals(
  ... a.overlap(b, strand_behavior='ignore') )
  True

Above, we leveraged method ``equals`` inherited from pandas Dataframe to compare table contents.


Note that the presence of any non-standard Strand value will result in strand being ignored for all rows.
When leading to potentially non-intuitive behavior, a warning is printed:

  >>> a_invalid = a.copy()
  >>> a_invalid.loc[2, 'Strand'] = "."
  >>> a_invalid
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                3        6  +
        1  |    chr1               13       15  +
        2  |    chr1               18       21  .
        3  |    chr1               23       27  -
        4  |    chr1               28       29  -
        5  |    chr1               32       37  +
        6  |    chr1               33       36  +
  PyRanges with 7 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 3 strands (including non-genomic strands: .).

  >>> a_invalid.overlap(b)  # doctest: +SKIP
  <input>:1: UserWarning: overlap: 'auto' strand_behavior treated as ignore due to invalid Strand values. Please use strand_behavior=ignore
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        1  |    chr1               13       15  +
        2  |    chr1               18       21  .
        3  |    chr1               23       27  -
        4  |    chr1               28       29  -
        5  |    chr1               32       37  +
        6  |    chr1               33       36  +
  PyRanges with 6 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 3 strands (including non-genomic strands: .).


Finally, argument ``match_by`` can be used to specify additional columns whose values must match for two intervals
to be considered overlapping.
For example, let's add a column to both objects to mark intervals whose Start is an odd number, then
use this column to filter the overlaps:

  >>> a2 = a.assign(odd = lambda x:x.Start % 2 )
  >>> a2
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        0  |    chr1                3        6  +               1
        1  |    chr1               13       15  +               1
        2  |    chr1               18       21  -               0
        3  |    chr1               23       27  -               1
        4  |    chr1               28       29  -               0
        5  |    chr1               32       37  +               0
        6  |    chr1               33       36  +               1
  PyRanges with 7 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> b2 = b.assign(odd = lambda x:x.Start % 2 )
  >>> b2
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        0  |    chr1                6        8  +               0
        1  |    chr1               12       14  +               0
        2  |    chr1               19       20  +               1
        3  |    chr1               25       29  -               1
        4  |    chr1               34       36  +               0
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


  >>> a2.overlap(b2, match_by='odd')
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        3  |    chr1               23       27  -               1
        5  |    chr1               32       37  +               0
  PyRanges with 2 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


The most versatile: join_overlaps
---------------------------------

The most versatile overlap-related method for pairs of PyRanges is :func:`join_overlaps <pyranges.PyRanges.join_overlaps>`.
This method is analogous to a SQL join operation, but rather than matching rows in two tables through a common key,
they are matched in virtue of their overlap.

This function searches for overlaps between the intervals in self and other, and reports in output the full
information related to the input intervals. The returned PyRanges object will have a number of rows equal to the
number of overlaps found, and the columns will be the union of the columns of self and other, using a suffix
to differentiate columns in other which are present with the same name in the self PyRanges, like Start and End:

  >>> a.join_overlaps(b)
    index  |    Chromosome      Start      End  Strand      Start_b    End_b
    int64  |    object          int64    int64  object        int64    int64
  -------  ---  ------------  -------  -------  --------  ---------  -------
        1  |    chr1               13       15  +                12       14
        3  |    chr1               23       27  -                25       29
        4  |    chr1               28       29  -                25       29
        5  |    chr1               32       37  +                34       36
        6  |    chr1               33       36  +                34       36
  PyRanges with 5 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

In contrast to :func:`overlap <pyranges.PyRanges.overlap>`, a row is returned per overlap, so
if an interval in self overlaps with more than one interval in other, it will be reported multiple times,
resulting in index duplicates (see below); you may call .reset_index() to correct this.

  >>> b.join_overlaps(a)
    index  |    Chromosome      Start      End  Strand      Start_b    End_b
    int64  |    object          int64    int64  object        int64    int64
  -------  ---  ------------  -------  -------  --------  ---------  -------
        1  |    chr1               12       14  +                13       15
        3  |    chr1               25       29  -                23       27
        3  |    chr1               25       29  -                28       29
        4  |    chr1               34       36  +                32       37
        4  |    chr1               34       36  +                33       36
  PyRanges with 5 rows, 6 columns, and 1 index columns (with 2 index duplicates).
  Contains 1 chromosomes and 2 strands.

Like all overlap-related methods accepting two PyRanges as input,
:func:`join_overlaps <pyranges.PyRanges.join_overlaps>`
accepts the ``strand_behavior`` argument. If Strand is not used to determine overlaps, it will
be returned for both PyRanges:

  >>> a.join_overlaps(b, strand_behavior="ignore")
    index  |    Chromosome      Start      End  Strand      Start_b    End_b  Strand_b
    int64  |    object          int64    int64  object        int64    int64  object
  -------  ---  ------------  -------  -------  --------  ---------  -------  ----------
        1  |    chr1               13       15  +                12       14  +
        2  |    chr1               18       21  -                19       20  +
        3  |    chr1               23       27  -                25       29  -
        4  |    chr1               28       29  -                25       29  -
        5  |    chr1               32       37  +                34       36  +
        6  |    chr1               33       36  +                34       36  +
  PyRanges with 6 rows, 7 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

``slack`` and ``match_by`` arguments are also available, e.g.:

  >>> a2.join_overlaps(b2, match_by='odd')
    index  |    Chromosome      Start      End  Strand        odd    Start_b    End_b
    int64  |    object          int64    int64  object      int64      int64    int64
  -------  ---  ------------  -------  -------  --------  -------  ---------  -------
        3  |    chr1               23       27  -               1         25       29
        5  |    chr1               32       37  +               0         34       36
  PyRanges with 2 rows, 7 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> a2.join_overlaps(b2, match_by='odd', slack=5)
    index  |    Chromosome      Start      End  Strand        odd    Start_b    End_b
    int64  |    object          int64    int64  object      int64      int64    int64
  -------  ---  ------------  -------  -------  --------  -------  ---------  -------
        1  |    chr1               13       15  +               1         19       20
        3  |    chr1               23       27  -               1         25       29
        5  |    chr1               32       37  +               0         34       36
  PyRanges with 3 rows, 7 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Pyranges provides method :func:`combine_interval_columns <pyranges.PyRanges.combine_interval_columns>`
to post-process the output of :func:`join_overlaps <pyranges.PyRanges.join_overlaps>`
and aggregate the coordinates of the overlapping intervals in Start and End columns.
For example, this allows to obtain the union of the overlapping intervals:

  >>> a2.join_overlaps(b2, match_by='odd', slack=5).combine_interval_columns('union')
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        1  |    chr1               13       20  +               1
        3  |    chr1               23       29  -               1
        5  |    chr1               32       37  +               0
  PyRanges with 3 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


:func:`join_overlaps <pyranges.PyRanges.join_overlaps>` is one of most versatile methods in PyRanges, since it
retains the full information of the two input PyRanges objects.
Nevertheless, more efficient alternative methods are available for specific use cases, detailed below.

Set operations: set_intersect_overlaps, set_union_overlaps
----------------------------------------------------------

Pyranges offers efficient methods based on the concept of set operations in mathematics. These are useful
when the user is interested in the intervals themselves, rather than in the full information (i.e. metadata)
of the input intervals.


Method :func:`set_intersect_overlaps <pyranges.PyRanges.set_intersect_overlaps>`, allows to obtain the genomic regions
present in both PyRanges:

  >>> a.set_intersect_overlaps(b)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1               13       14  +
        1  |    chr1               34       36  +
        2  |    chr1               25       27  -
        3  |    chr1               28       29  -
  PyRanges with 4 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> a.set_intersect_overlaps(b, strand_behavior="ignore")
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1               13       14
        1  |    chr1               19       20
        2  |    chr1               25       27
        3  |    chr1               28       29
        4  |    chr1               34       36
  PyRanges with 5 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

The regions reported may be part of any interval in the two PyRanges. All metadata columns are dropped:

  >>> a2.set_intersect_overlaps(b2).columns  # see above: a2 and b2 had the 'odd' column
  Index(['Chromosome', 'Start', 'End', 'Strand'], dtype='object')

Analogously, method :func:`set_union_overlaps <pyranges.PyRanges.set_union_overlaps>` allows to obtain the genomic regions that
are present in at least one of the PyRanges:

  >>> a.set_union_overlaps(b)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                3        6  +
        1  |    chr1                6        8  +
        2  |    chr1               12       15  +
        3  |    chr1               19       20  +
        4  |    chr1               32       37  +
        5  |    chr1               18       21  -
        6  |    chr1               23       29  -
  PyRanges with 7 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> a2.set_union_overlaps(b2, strand_behavior='ignore')
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                3        6
        1  |    chr1                6        8
        2  |    chr1               12       15
        3  |    chr1               18       21
        4  |    chr1               23       29
        5  |    chr1               32       37
  PyRanges with 6 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

Interval manipulation operations: intersect_overlaps, subtract_overlaps
-----------------------------------------------------------------------
Set operations do not preserve input metadata.
:func:`join_overlaps <pyranges.PyRanges.join_overlaps>` preserve metadata of both PyRanges, but is less efficient.
Pyranges also offers methods that preserve the metadata in self, but not in other.
Specifically, method :func:`intersect_overlaps <pyranges.PyRanges.intersect_overlaps>` allows to obtain the intervals in self that overlap
with any interval in other. It is similar to :func:`overlap <pyranges.PyRanges.overlap>`, but here coordinates
are modified to return only the actual overlaps:

  >>> a2.intersect_overlaps(b)
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        1  |    chr1               13       14  +               1
        3  |    chr1               25       27  -               1
        4  |    chr1               28       29  -               0
        5  |    chr1               34       36  +               0
        6  |    chr1               34       36  +               1
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> a2.intersect_overlaps(b2, strand_behavior='ignore', match_by='odd')
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        3  |    chr1               25       27  -               1
        5  |    chr1               34       36  +               0
  PyRanges with 2 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Method :func:`subtract_overlaps <pyranges.PyRanges.subtract_overlaps>` allows to obtain the portions of intervals in self
that do not overlap any interval in other:

  >>> a2.subtract_overlaps(b).sort_values('Start')
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        0  |    chr1                3        6  +               1
        1  |    chr1               14       15  +               1
        2  |    chr1               18       21  -               0
        3  |    chr1               23       25  -               1
        5  |    chr1               32       34  +               0
        6  |    chr1               33       34  +               1
        5  |    chr1               36       37  +               0
  PyRanges with 7 rows, 5 columns, and 1 index columns (with 1 index duplicates).
  Contains 1 chromosomes and 2 strands.


  >>> a2.subtract_overlaps(b, strand_behavior='ignore').sort_values('Start')
    index  |    Chromosome      Start      End  Strand        odd
    int64  |    object          int64    int64  object      int64
  -------  ---  ------------  -------  -------  --------  -------
        0  |    chr1                3        6  +               1
        1  |    chr1               14       15  +               1
        2  |    chr1               18       19  -               0
        2  |    chr1               20       21  -               0
        3  |    chr1               23       25  -               1
        5  |    chr1               32       34  +               0
        6  |    chr1               33       34  +               1
        5  |    chr1               36       37  +               0
  PyRanges with 8 rows, 5 columns, and 1 index columns (with 2 index duplicates).
  Contains 1 chromosomes and 2 strands.

Fast counting: count_overlaps
-----------------------------

Method :func:`count_overlaps <pyranges.PyRanges.count_overlaps>` allows to count, for each interval in self,
the number of intervals in other that overlaps with it.
Input coordinates are not modified, and a new column is added:

  >>> a2.count_overlaps(b) # using a2 to show the 'odd' column is preserved
    index  |    Chromosome      Start      End  Strand        odd     Count
    int64  |    object          int64    int64  object      int64    uint32
  -------  ---  ------------  -------  -------  --------  -------  --------
	0  |    chr1                3        6  +               1         0
	1  |    chr1               13       15  +               1         1
	2  |    chr1               18       21  -               0         0
	3  |    chr1               23       27  -               1         1
	4  |    chr1               28       29  -               0         1
	5  |    chr1               32       37  +               0         1
	6  |    chr1               33       36  +               1         1
  PyRanges with 7 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Arguments ``strand_behavior`` and ``match_by`` are available:

  >>> a.count_overlaps(b, strand_behavior='ignore')
    index  |    Chromosome      Start      End  Strand       Count
    int64  |    object          int64    int64  object      uint32
  -------  ---  ------------  -------  -------  --------  --------
	0  |    chr1                3        6  +                0
	1  |    chr1               13       15  +                1
	2  |    chr1               18       21  -                1
	3  |    chr1               23       27  -                1
	4  |    chr1               28       29  -                1
	5  |    chr1               32       37  +                1
	6  |    chr1               33       36  +                1
  PyRanges with 7 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


  >>> a2.count_overlaps(b2, strand_behavior='ignore', match_by='odd')
    index  |    Chromosome      Start      End  Strand        odd     Count
    int64  |    object          int64    int64  object      int64    uint32
  -------  ---  ------------  -------  -------  --------  -------  --------
	0  |    chr1                3        6  +               1         0
	1  |    chr1               13       15  +               1         0
	2  |    chr1               18       21  -               0         0
	3  |    chr1               23       27  -               1         1
	4  |    chr1               28       29  -               0         0
	5  |    chr1               32       37  +               0         1
	6  |    chr1               33       36  +               1         0
  PyRanges with 7 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Advanced metrics (e.g. interval fraction covered by overlap)
can be computed using the :func:`compute_interval_metrics <pyranges.PyRanges.compute_interval_metrics>`
function, which is run on the output of :func:`join_overlaps <pyranges.PyRanges.join_overlaps>`:

  >>> a.join_overlaps(b, strand_behavior='ignore').compute_interval_metrics('fraction')
    index  |    Chromosome      Start      End  Strand      Start_b    End_b  Strand_b      fraction
    int64  |    object          int64    int64  object        int64    int64  object         float64
  -------  ---  ------------  -------  -------  --------  ---------  -------  ----------  ----------
	1  |    chr1               13       15  +                12       14  +             0.5
	2  |    chr1               18       21  -                19       20  +             0.333333
	3  |    chr1               23       27  -                25       29  -             0.5
	4  |    chr1               28       29  -                25       29  -             1
	5  |    chr1               32       37  +                34       36  +             0.4
	6  |    chr1               33       36  +                34       36  +             0.666667
  PyRanges with 6 rows, 8 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Find the closest interval: nearest_ranges
-----------------------------------------

Method :func:`nearest_ranges <pyranges.PyRanges.nearest_ranges>` allows to find the closest interval in other for each interval
in self:

  >>> a.nearest_ranges(b)
    index  |    Chromosome      Start      End  Strand    Chromosome_b      Start_b    End_b  Strand_b      Distance
    int64  |    object          int64    int64  object    object              int64    int64  object           int64
  -------  ---  ------------  -------  -------  --------  --------------  ---------  -------  ----------  ----------
	0  |    chr1                3        6  +         chr1                    6        8  +                    1
	1  |    chr1               13       15  +         chr1                   12       14  +                    0
	2  |    chr1               18       21  -         chr1                   25       29  -                    5
	3  |    chr1               23       27  -         chr1                   25       29  -                    0
	4  |    chr1               28       29  -         chr1                   25       29  -                    0
	5  |    chr1               32       37  +         chr1                   34       36  +                    0
	6  |    chr1               33       36  +         chr1                   34       36  +                    0
  PyRanges with 7 rows, 9 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

The output format is similar to :func:`join_overlaps <pyranges.PyRanges.join_overlaps>`.
Note the "Distance" column, which reports the distance between the intervals in self and other.

In case you want to find the nearest interval which does not overlap with each self interval, use
``exclude_overlaps=True``:

  >>> a.nearest_ranges(b, exclude_overlaps=True)
    index  |    Chromosome      Start      End  Strand    Chromosome_b      Start_b    End_b  Strand_b      Distance
    int64  |    object          int64    int64  object    object              int64    int64  object           int64
  -------  ---  ------------  -------  -------  --------  --------------  ---------  -------  ----------  ----------
	0  |    chr1                3        6  +         chr1                    6        8  +                    1
	1  |    chr1               13       15  +         chr1                   19       20  +                    5
	2  |    chr1               18       21  -         chr1                   25       29  -                    5
	5  |    chr1               32       37  +         chr1                   19       20  +                   13
	6  |    chr1               33       36  +         chr1                   19       20  +                   14
  PyRanges with 5 rows, 9 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

The :func:`nearest_ranges <pyranges.PyRanges.nearest_ranges>` method also accepts the ``strand_behavior`` argument:

  >>> a.nearest_ranges(b, strand_behavior='ignore', exclude_overlaps=True)
    index  |    Chromosome      Start      End  Strand    Chromosome_b      Start_b    End_b  Strand_b      Distance
    int64  |    object          int64    int64  object    object              int64    int64  object           int64
  -------  ---  ------------  -------  -------  --------  --------------  ---------  -------  ----------  ----------
	0  |    chr1                3        6  +         chr1                    6        8  +                    1
	1  |    chr1               13       15  +         chr1                   19       20  +                    5
	2  |    chr1               18       21  -         chr1                   12       14  +                    5
	2  |    chr1               18       21  -         chr1                   25       29  -                    5
	3  |    chr1               23       27  -         chr1                   19       20  +                    4
	4  |    chr1               28       29  -         chr1                   34       36  +                    6
	5  |    chr1               32       37  +         chr1                   25       29  -                    4
	6  |    chr1               33       36  +         chr1                   25       29  -                    5
  PyRanges with 8 rows, 9 columns, and 1 index columns (with 1 index duplicates).
  Contains 1 chromosomes and 2 strands.


Methods for single PyRanges
===========================

These overlap-related methods return a modified version of the input PyRanges object (self).
We will showcase them with this data:

  >>> c = pr.PyRanges(dict(Chromosome="chr1",
  ...                      Start=[1, 4, 10, 12, 19, 20, 24, 28],
  ...                      End=[5, 7, 14, 16, 27, 22, 25, 30],
  ...                      Strand=["+", "+", "+", "-", "+", "+", "+", "+"]))
  >>> c
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                1        5  +
        1  |    chr1                4        7  +
        2  |    chr1               10       14  +
        3  |    chr1               12       16  -
        4  |    chr1               19       27  +
        5  |    chr1               20       22  +
        6  |    chr1               24       25  +
        7  |    chr1               28       30  +
  PyRanges with 8 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Grouping overlapping intervals: cluster_overlaps
------------------------------------------------
The most flexible method in this category is :func:`cluster_overlaps <pyranges.PyRanges.cluster_overlaps>`.
This function will detect overlaps among intervals in self, and assign a cluster identifier
to each group of overlapping intervals. The object returned is identical to the input,
with an additional column "Cluster" containing the cluster identifier:

  >>> c.cluster_overlaps()
    index  |    Chromosome      Start      End  Strand      Cluster
    int64  |    object          int64    int64  object       uint32
  -------  ---  ------------  -------  -------  --------  ---------
	0  |    chr1                1        5  +                 0
	1  |    chr1                4        7  +                 0
	2  |    chr1               10       14  +                 1
	4  |    chr1               19       27  +                 2
	5  |    chr1               20       22  +                 2
	6  |    chr1               24       25  +                 2
	7  |    chr1               28       30  +                 3
	3  |    chr1               12       16  -                 5
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Note that clusters 1 and 2 are kept separated only because of strand.
We introduce argument ``use_strand``, accepted by all overlap-related methods for single PyRanges.
When set to False, strand is ignored for overlap detection:

  >>> c.cluster_overlaps(use_strand=False)
    index  |    Chromosome      Start      End  Strand      Cluster
    int64  |    object          int64    int64  object       uint32
  -------  ---  ------------  -------  -------  --------  ---------
	0  |    chr1                1        5  +                 0
	1  |    chr1                4        7  +                 0
	2  |    chr1               10       14  +                 1
	3  |    chr1               12       16  -                 1
	4  |    chr1               19       27  +                 2
	5  |    chr1               20       22  +                 2
	6  |    chr1               24       25  +                 2
	7  |    chr1               28       30  +                 3
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

The default value of argument ``use_strand`` is 'auto', which is interpreted as True if the PyRanges object
has valid strand information, and False otherwise.

Note that cluster 2 contain intervals with indices 5 and 6 which do not directly overlap,
but they both overlap with the interval with index 4. (More generally, a cluster is a connected
component of the overlap graph, where two intervals are connected if they overlap directly.)

Argument ``cluster_column`` controls the name of the column containing the cluster identifier.
Also, argument ``slack`` is also available here, and it is analogous to its use in methods for pairs of PyRanges.
Its default value is 0. With ``slack=1``, bookended intervals are placed in the same cluster.
With ``slack=2``, intervals that are distant at the most 1 bp are placed in the same cluster,
like those with index 4 and 7 above; and so on.

  >>> c2 = c.cluster_overlaps(slack=2, use_strand=False, cluster_column='myClust')
  >>> c2
    index  |    Chromosome      Start      End  Strand      myClust
    int64  |    object          int64    int64  object       uint32
  -------  ---  ------------  -------  -------  --------  ---------
	0  |    chr1                1        5  +                 0
	1  |    chr1                4        7  +                 0
	2  |    chr1               10       14  +                 1
	3  |    chr1               12       16  -                 1
	4  |    chr1               19       27  +                 2
	5  |    chr1               20       22  +                 2
	6  |    chr1               24       25  +                 2
	7  |    chr1               28       30  +                 2
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Argument ``match_by`` is also available.
Only intervals with the same value in the specified column will be considered for overlap detection.
Let's add a gene column to the PyRanges object and compare "Cluster" results with the previous column "myClust":

  >>> c2['gene'] = ['abc'[s % 3] for s in c2.Start] # arbitrary gene assignment
  >>> c2.cluster_overlaps(slack=2, use_strand=False, match_by='gene')
    index  |    Chromosome      Start      End  Strand      myClust  gene        Cluster
    int64  |    object          int64    int64  object       uint32  object       uint32
  -------  ---  ------------  -------  -------  --------  ---------  --------  ---------
	3  |    chr1               12       16  -                 1  a                 0
	6  |    chr1               24       25  +                 2  a                 1
	0  |    chr1                1        5  +                 0  b                 3
	1  |    chr1                4        7  +                 0  b                 3
	2  |    chr1               10       14  +                 1  b                 4
	4  |    chr1               19       27  +                 2  b                 5
	7  |    chr1               28       30  +                 2  b                 5
	5  |    chr1               20       22  +                 2  c                 7
  PyRanges with 8 rows, 7 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Resolve overlaps: merge_overlaps, split_overlaps, max_disjoint_overlaps
-----------------------------------------------------------------------
Various methods exists to obtain a PyRanges object without internal overlaps.

Method :func:`merge_overlaps <pyranges.PyRanges.merge_overlaps>`
allows to merge overlapping intervals in self.
In practice, this function returns the union of all intervals in self.
All metadata columns are dropped:

  >>> c.merge_overlaps()
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                1        7  +
        1  |    chr1               10       14  +
        2  |    chr1               19       27  +
        3  |    chr1               28       30  +
        4  |    chr1               12       16  -
  PyRanges with 5 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

As before, both ``slack`` and ``use_strand`` are supported:

  >>> c.merge_overlaps(slack=2)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                1        7  +
        1  |    chr1               10       14  +
        2  |    chr1               19       30  +
        3  |    chr1               12       16  -
  PyRanges with 4 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Note that Strand is not reported when ``use_strand`` is set to False:

  >>> c.merge_overlaps(slack=2, use_strand=False)
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                1        7
        1  |    chr1               10       16
        2  |    chr1               19       30
  PyRanges with 3 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

On the other hand, method :func:`split_overlaps <pyranges.PyRanges.split_overlaps>` allows
to split intervals in self
at the position of overlaps, leaving as many bookended intervals as necessary to avoid overlaps.
This function drops metadata, too:

  >>> pr.options.set_option('max_rows_to_show', 12) # to see all rows
  >>> c.split_overlaps()
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
	0  |    chr1                1        4  +
	1  |    chr1                4        5  +
	2  |    chr1                5        7  +
	3  |    chr1               10       14  +
	4  |    chr1               19       20  +
	5  |    chr1               20       22  +
	6  |    chr1               22       24  +
	7  |    chr1               24       25  +
	8  |    chr1               25       27  +
	9  |    chr1               28       30  +
       10  |    chr1               12       16  -
  PyRanges with 11 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Function :func:`max_disjoint_overlaps <pyranges.PyRanges.max_disjoint_overlaps>` also returns a set of non-overlapping intervals.
In this case, however, input intervals are not modified, just filtered.
The intervals to return are chosen to maximize the number of intervals in the output.
The usual arguments (e.g. ``use_strand``) are available:


  >>> pr.options.reset_options()
  >>> c2.max_disjoint_overlaps(use_strand=False) # using c2 to show that metadata is retained
    index  |    Chromosome      Start      End  Strand      myClust  gene
    int64  |    object          int64    int64  object       uint32  object
  -------  ---  ------------  -------  -------  --------  ---------  --------
        0  |    chr1                1        5  +                 0  b
        2  |    chr1               10       14  +                 1  b
        4  |    chr1               19       27  +                 2  b
        7  |    chr1               28       30  +                 2  b
  PyRanges with 4 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.



.. *** docs/pyranges_module.rst ***

The pyranges module
-------------------

The pyranges module exposes the class :class:`PyRanges <pyranges.PyRanges>` (omitted in this page)
as well as a number of functions for reading data from commonly used file formats.
You also have an :ref:`pyranges.options <pyranges_options>` interface to
configure how PyRanges objects are represented, and an :ref:`pyranges.example_data <pyranges_example_data>` object used in tests and documentation.


.. automodule:: pyranges
    :members:
    :imported-members:  # Ensure this is set to include imported members
    :exclude-members: PyRanges, RangeFrame

.. _pyranges_options:
pyranges.options
~~~~~~~~~~~~~~~~

The ``pyranges.options`` object is used to configure aspects of how PyRanges is represented.
Below are the methods available on this object.

.. automodule:: pyranges.options
   :members:
   :show-inheritance:
   :exclude-members: __init__

.. _pyranges_example_data:
pyranges.example_data
~~~~~~~~~~~~~~~~~~~~~
The ``pyranges.example_data`` object contains example data used in tests and documentation.
Printing it shows an overview of available data:

  >>> import pyranges as pr
  >>> pr.example_data
  Available example data:
  -----------------------
  example_data.chipseq            : Example ChIP-seq data.
  example_data.chipseq_background : Example ChIP-seq data.
  example_data.chromsizes         : Example chromsizes data (hg19).
  example_data.ensembl_gtf        : Example gtf file from Ensembl.
  example_data.f1                 : Example bed file.
  example_data.f2                 : Example bed file.
  example_data.aorta              : Example ChIP-seq data.
  example_data.aorta2             : Example ChIP-seq data.
  example_data.ncbi_gff           : Example NCBI GFF data.
  example_data.ncbi_fasta         : Example NCBI fasta.
  example_data.files              : A dict of basenames to file paths of available data.

Most of the data is in the form of PyRanges objects:

  >>> pr.example_data.chipseq
  index    |    Chromosome    Start      End        Name      Score    Strand
  int64    |    category      int64      int64      object    int64    category
  -------  ---  ------------  ---------  ---------  --------  -------  ----------
  0        |    chr8          28510032   28510057   U0        0        -
  1        |    chr7          107153363  107153388  U0        0        -
  2        |    chr5          135821802  135821827  U0        0        -
  3        |    chr14         19418999   19419024   U0        0        -
  ...      |    ...           ...        ...        ...       ...      ...
  16       |    chr9          120803448  120803473  U0        0        +
  17       |    chr6          89296757   89296782   U0        0        -
  18       |    chr1          194245558  194245583  U0        0        +
  19       |    chr8          57916061   57916086   U0        0        +
  PyRanges with 20 rows, 6 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

.. _pyranges_assistant:
pyranges.assistant
~~~~~~~~~~~~~~~~~~
The ``pyranges.assistant`` object is a helper to use AI-based assistant to code with pyranges:

  >>> pr.assistant
  Utilities to instruct a AI coding assistant for pyranges prompts.

  Get a prompt to copy-paste into an AI assistant to prime it for pyranges coding tasks:
      >>> import pyranges as pr
      >>> pr.assistant.prompt()

  Make a file with pyranges documentation to upload to the AI assistant:
      >>> pr.assistant.export_docs("pr_docs.txt")



.. *** docs/extension_seqs.rst ***


Seqs: sequences
---------------

Utilities to process nucleotide or protein sequences.

.. automodule:: pyranges.seqs
    :members:
    :imported-members:



.. *** docs/cheatsheet.rst ***


Cheatsheet
~~~~~~~~~~
Here's a cheatsheet for Pyranges, summarizing the most common operations.

.. image:: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/images/pyranges_cheatsheet.png
   :alt: Pyranges cheatsheet
   :target: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/images/pyranges_cheatsheet.png


.. *** docs/installation.rst ***


Installation
~~~~~~~~~~~~

Pyranges 1.x requires python ‚â• 3.12. If necessary, create a new conda environment::

    conda create -yn pr python
    conda activate pr


The preferred way to install pyranges is via pip::

    pip install pyranges1

The command above will install a **minimal version** of pyranges.
Pyranges has several optional dependencies, required for certain functionalities.

To **install all optional dependencies**, use::

    pip install pyranges1[all]

Here you can see the optional dependencies grouped by functionality::

    # user add-ons: to fetch sequences, read BAM files ...
    pip install pyranges1[add-ons]

    # command line: to use the pyranger command-line tool
    pip install pyranges1[cli]

    # development: for testing, linting, type checking, generating documentation
    pip install pyranges1[dev]

    # documentation: for building the documentation
    pip install pyranges1[docs]

To inspect the list of dependencies, check the pyproject.toml file in the repository.


.. *** docs/range_frame.rst ***

RangeFrame
----------

The RangeFrame is the parent class of PyRanges. It supports interval-based operations that do not require the data
to contain Chromosome and Strand information. It is a subclass of pandas.DataFrame.

.. autoclass:: pyranges.RangeFrame
   :members:


.. *** docs/migration_guide.rst ***

Migration guide from v0 to v1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pyranges v1.x introduced major changes in data structure and interface.
This guide is intended to help you migrate your code from v0.x to v1.x.

Useful links:

 * `Documentation for v0 <https://pyranges.readthedocs.io/en/v0/>`_
 * `Github repository for v0 <https://github.com/pyranges/pyranges/tree/v0>`_

In v0, PyRanges objects were implemented as a dictionary of DataFrames, one for each chromosome or for each
(chromosome, strand) pair if strand was present and valid. This implied that intervals on different chromosomes had
no inherent order, and operations on each chromosome were independent. In practical uses,
PyRanges had to be often converted to a single DataFrame to access the full functionality of pandas, using the
``df`` or ``as_df`` attributes, which was inefficient and cumbersome. Moreover, performance was not
very low on datasets comprising many "chromosomes" such as transcriptomic-based intervals.

In v1, PyRanges objects are implemented as a DataFrame subclass, which allows for more efficient operations and
direct access to pandas methods. This required a major interface change, since some methods and attributes existed
with the same name in both PyRanges and DataFrame, and the new implementation had to be consistent with the DataFrame.
Ultimately, we took advantage of the necessity of the change to redesign the interface to be more consistent and
maintainable in the future.

Below, we provide a cheatsheet to help you migrate your code from v0 to v1.
The most problematic aspects are the get/set item methods, since the v0 syntax is not compatible with dataframes.
See `here a discussion on the topic <https://github.com/pyranges/pyranges/discussions/357#discussioncomment-7274998>`_.

In the table below, ``pr`` refers to the pyranges module, and ``g`` to a PyRanges object. Most items are linked
to the corresponding documentation page.

.. csv-table:: Migration cheatsheet
   :file: migration_cheatsheet.tsv
   :delim: tab
   :header-rows: 1



.. *** docs/extension_orfs.rst ***


Orfs: Open Reading Frames
-------------------------

Utilities to work with open reading frames and coding sequences (e.g. CDS features in gene annotation files).

.. automodule:: pyranges.orfs
    :members:
    :imported-members:



.. *** docs/how_to_write.rst ***

Writing to disk
~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2


The PyRanges can be written to several formats, namely csv, gtf, gff3 and bigwig.
If no path-argument is given, the string representation of the data is returned. (It may potentially be very large.)
If a path is given, it is taken as the path to the file to be written; in this case, the return value is the object
itself, to allow inserting write methods into method call chains.


Writing genomic formats
-----------------------

Pyranges supports the most popular for genomic annotations, such as bed, gtf and gff3.
You can readily write them using the correspondent methods (see
:func:`to_bed <pyranges.PyRanges.to_bed>`,
:func:`to_gtf <pyranges.PyRanges.to_gtf>`,
:func:`to_gff3 <pyranges.PyRanges.to_gff3>`).

  >>> import pyranges as pr
  >>> gr = pr.example_data.chipseq
  >>> gr.to_gtf("chipseq.gtf")
  >>> #file chipseq.gtf has been created


Methods to_gff3 and to_gtf have a default mapping of PyRanges columns to GFF/GTF fields.
All extra ("metadata") columns are put in the last field:

  >>> gr['Label']='something'
  >>> print(gr.head().to_gtf()) # doctest: +NORMALIZE_WHITESPACE
  chr8	.	.	28510033	28510057	0	-	.	Name "U0"; Label "something";
  chr7	.	.	107153364	107153388	0	-	.	Name "U0"; Label "something";
  chr5	.	.	135821803	135821827	0	-	.	Name "U0"; Label "something";
  chr14	.	.	19419000	19419024	0	-	.	Name "U0"; Label "something";
  chr12	.	.	106679762	106679786	0	-	.	Name "U0"; Label "something";

Such mapping, as well as which attribute(s) are included as last field, can be altered. See the API for details.

The `bigwig <http://genome.ucsc.edu/goldenPath/help/bigWig.html>`_ format differs substantially from
the formats above. Bigwig is a binary format, and it is typically used for large continuous quantitative
data along a genome sequence.

The pyranges library can also create bigwigs, but it needs the library pybigwig and pyrle which are not installed by default.

Use this to install it::

	pip install pybigwig pyrle

The bigwig writer needs to know the chromosome sizes, e.g. provided as a dictionary {chromosome_name: size}.
You can also derive chromosome sizes from a fasta file using pyfaidx (see above to install it).

.. doctest::

  >>> import pyfaidx
  >>> chromsizes=pyfaidx.Fasta('your_genome.fa') # doctest: +SKIP


Once you obtained chromosome sizes, you are ready to write your PyRanges object to a bigwig file:

  >>> gr.to_bigwig("chipseq.bw", chromsizes) # doctest: +SKIP
  >>> # file chipseq.bw has been created

Bigwig is typically used to represent a coverage of some type.
To compute it from an arbitrary value column, use the value_col argument. See the API for additional options.
If you want to write one bigwig for each strand, you need to do it manually.


  >>> gr.loci["+"].to_bigwig("chipseq_plus.bw", chromsizes) # doctest: +SKIP
  >>> gr.loci["-"].to_bigwig("chipseq_minus.bw", chromsizes) # doctest: +SKIP


Writing tabular formats
-----------------------

The csv format is the most flexible format, as it allows for any column to be included, and any separator to be used.
The method ``to_csv`` is directly inherited by pandas, so search for its API for details.


The ``to_csv`` method takes the arguments header and sep:

  >>> print(gr.drop(['Label'], axis=1).head().to_csv(sep="\t", header=False, index=False)) # doctest: +NORMALIZE_WHITESPACE
  chr8	28510032	28510057	U0	0	-
  chr7	107153363	107153388	U0	0	-
  chr5	135821802	135821827	U0	0	-
  chr14	19418999	19419024	U0	0	-
  chr12	106679761	106679786	U0	0	-
  <BLANKLINE>

Remember that ``to_csv`` will not alter coordinates, so the output
will have the same pythonic convention as PyRanges. Adjust accordingly if needed.


.. *** docs/how_to_create.rst ***

Loading/Creating PyRanges
~~~~~~~~~~~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2


A PyRanges object can be built like a Pandas DataFrame, but genomic location columns (Chromosome, Start, End) are
mandatory. Refer to https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html for more information on how
to create a DataFrame. In alternative, PyRanges can be read from a file in bed, gtf, gff3 or bam format.

PyRanges are created in the following ways:

#. from a pandas dataframe
#. from a dictionary with the column names as keys and iterables as values
#. from a file, using pyranges readers
#. concatenating existing PyRanges objects

From a DataFrame
----------------

If you instantiate a PyRanges object from a dataframe, it should at least contain the columns Chromosome, Start and End.
Coordinates follow the python standard (0-based, start included, end excluded). A column called Strand is optional.
Any other columns in the dataframe are carried over as metadata.

  >>> import pandas as pd, pyranges as pr, numpy as np
  >>> df=pd.DataFrame(
  ... {'Chromosome':['chr1', 'chr1', 'chr1', 'chr3'],
  ...  'Start': [5, 20, 80, 10],
  ...  'End':   [10, 28, 95, 38],
  ...  'Strand':['+', '+', '-', '+'],
  ...  'title': ['a', 'b', 'c', 'd']}
  ... )
  >>> df
    Chromosome  Start  End Strand title
  0       chr1      5   10      +     a
  1       chr1     20   28      +     b
  2       chr1     80   95      -     c
  3       chr3     10   38      +     d


To instantiate PyRanges from a dataframe, provide it as argument to the PyRanges constructor:

  >>> p=pr.PyRanges(df)
  >>> p
    index  |    Chromosome      Start      End  Strand    title
    int64  |    object          int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |    chr1                5       10  +         a
        1  |    chr1               20       28  +         b
        2  |    chr1               80       95  -         c
        3  |    chr3               10       38  +         d
  PyRanges with 4 rows, 5 columns, and 1 index columns.
  Contains 2 chromosomes and 2 strands.


From a Dictionary
-----------------

You can instantiate a PyRanges object using a dictionary:

  >>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1', 'chr3'],
  ...                   'Start': [5, 20, 80, 10],
  ...                   'End': [10, 28, 95, 38],
  ...                   'Strand': ['+', '+', '-', '+'],
  ...                   'title': ['a', 'b', 'c', 'd']})
  >>> gr
    index  |    Chromosome      Start      End  Strand    title
    int64  |    object          int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |    chr1                5       10  +         a
        1  |    chr1               20       28  +         b
        2  |    chr1               80       95  -         c
        3  |    chr3               10       38  +         d
  PyRanges with 4 rows, 5 columns, and 1 index columns.
  Contains 2 chromosomes and 2 strands.

Both the ``{}`` and the ``dict`` constructors can be used to create a dictionary:

  >>> gr2 = pr.PyRanges(dict(Chromosome=['chr10', 'chr10', 'chr1', 'chr3'],
  ...                       Start=[55, 250, 80, 100],
  ...                       End=[150, 258, 95, 380]))
  >>> gr2
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr10              55      150
        1  |    chr10             250      258
        2  |    chr1               80       95
        3  |    chr3              100      380
  PyRanges with 4 rows, 3 columns, and 1 index columns.
  Contains 3 chromosomes.


As in the creation of a Dataframe, each list in the dictionary must have the same length, i.e. the number of rows
in the PyRanges. Also, it may be any iterable, including pd.Series or np.array.
Alternatively, if a string or scalar is provided, it is broadcasted to the length of the other columns:

  >>> gr3 = pr.PyRanges(dict(Chromosome=pd.Series(['chr10', 'chr10', 'chr1', 'chr3']),
  ...                       Start=np.array([55, 250, 80, 100]),
  ...                       End=[150, 258, 95, 380],
  ...                       Strand='+'))
  >>> gr3
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr10              55      150  +
        1  |    chr10             250      258  +
        2  |    chr1               80       95  +
        3  |    chr3              100      380  +
  PyRanges with 4 rows, 4 columns, and 1 index columns.
  Contains 3 chromosomes and 1 strands.


Loading from a file
-------------------

The pyranges library can create PyRanges from gff3 common file formats, namely gtf/gff, gff3, bed and bam (see
:func:`read_bed <pyranges.read_bed>`, :func:`read_gtf <pyranges.read_gtf>`,
:func:`read_gff3 <pyranges.read_gff3>`, :func:`read_bam <pyranges.read_bam>`).
The documentation of readers is available in the :doc:`pyranges module <pyranges_module>`.
Note that these files may encode coordinates with different conventions (e.g. GTF: 1-based, start and end included).
When instancing a PyRanges object they are converted to the python convention.

  >>> ensembl_path = pr.example_data.files['ensembl.gtf']  # example file
  >>> gr = pr.read_gtf(ensembl_path)
  >>> gr
  index    |    Chromosome    Source    Feature     Start    End      Score     Strand      Frame     gene_id          ...
  int64    |    category      object    category    int64    int64    object    category    object    object           ...
  -------  ---  ------------  --------  ----------  -------  -------  --------  ----------  --------  ---------------  -----
  0        |    1             havana    gene        11868    14409    .         +           .         ENSG00000223972  ...
  1        |    1             havana    transcript  11868    14409    .         +           .         ENSG00000223972  ...
  2        |    1             havana    exon        11868    12227    .         +           .         ENSG00000223972  ...
  3        |    1             havana    exon        12612    12721    .         +           .         ENSG00000223972  ...
  ...      |    ...           ...       ...         ...      ...      ...       ...         ...       ...              ...
  8        |    1             ensembl   transcript  120724   133723   .         -           .         ENSG00000238009  ...
  9        |    1             ensembl   exon        133373   133723   .         -           .         ENSG00000238009  ...
  10       |    1             ensembl   exon        129054   129223   .         -           .         ENSG00000238009  ...
  11       |    1             ensembl   exon        120873   120932   .         -           .         ENSG00000238009  ...
  PyRanges with 12 rows, 23 columns, and 1 index columns. (14 columns not shown: "gene_version", "gene_name", "gene_source", ...).
  Contains 1 chromosomes and 2 strands.


To read bam files, the optional bamread-library must be installed, with ::

    pip install bamread

Let's read a bam file:

  >>> bam_path = pr.example_data.files['smaller.bam']  # example file
  >>> gr4 = pr.read_bam(bam_path)
  >>> gr4
  index    |    Chromosome    Start     End       Strand      Flag
  int64    |    category      int64     int64     category    uint16
  -------  ---  ------------  --------  --------  ----------  --------
  0        |    chr1          887771    887796    -           16
  1        |    chr1          994660    994685    -           16
  2        |    chr1          1041102   1041127   +           0
  3        |    chr1          1770383   1770408   -           16
  ...      |    ...           ...       ...       ...         ...
  96       |    chr1          18800901  18800926  +           0
  97       |    chr1          18800901  18800926  +           0
  98       |    chr1          18855123  18855148  -           16
  99       |    chr1          19373470  19373495  +           0
  PyRanges with 100 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

``read_bam`` takes various arguments, such as ``sparse``.
With ``sparse=True`` (default), only the columns ``['Chromosome', 'Start', 'End', 'Strand', 'Flag']``
are fetched. Setting ``sparse=False`` additionally gives you the columns
``['QueryStart', 'QueryEnd', 'QuerySequence', 'Name', 'Cigar', 'Quality']``, but is more time and memory-consuming:

  >>> pr.read_bam(bam_path, sparse=False)
  index    |    Chromosome    Start     End       Strand      Flag      QueryStart    QueryEnd    QuerySequence    ...
  int64    |    category      int64     int64     category    uint16    int64         int64       object           ...
  -------  ---  ------------  --------  --------  ----------  --------  ------------  ----------  ---------------  -----
  0        |    chr1          887771    887796    -           16        0             25          None             ...
  1        |    chr1          994660    994685    -           16        0             25          None             ...
  2        |    chr1          1041102   1041127   +           0         0             25          None             ...
  3        |    chr1          1770383   1770408   -           16        0             25          None             ...
  ...      |    ...           ...       ...       ...         ...       ...           ...         ...              ...
  96       |    chr1          18800901  18800926  +           0         0             25          None             ...
  97       |    chr1          18800901  18800926  +           0         0             25          None             ...
  98       |    chr1          18855123  18855148  -           16        0             25          None             ...
  99       |    chr1          19373470  19373495  +           0         0             25          None             ...
  PyRanges with 100 rows, 11 columns, and 1 index columns. (3 columns not shown: "Name", "Cigar", "Quality").
  Contains 1 chromosomes and 2 strands.

To load tabular file in any format, you can use pandas ``read_csv`` method and then pass the resulting dataframe to the
PyRanges constructor. Be aware of the coordinate convention of the file you load, and make sure that the
dataframe has aptly named columns.

Concatenating PyRanges
----------------------

Analogously to ``pandas.concat``, :func:`pyranges.concat` can be used to concatenate PyRanges objects, i.e.
stack rows of two or more PyRanges to create a new PyRanges object.

  >>> gr1 = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1', 'chr3'],
  ...                    'Start': [5, 20, 80, 10],
  ...                    'End': [10, 28, 95, 38],
  ...                    'Strand': ['+', '+', '-', '+'],
  ...                    'title': ['a', 'b', 'c', 'd']})
  >>> gr2 = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1', 'chr3'],
  ...                    'Start': [5, 20, 80, 10],
  ...                    'End': [10, 28, 95, 38],
  ...                    'Strand': ['+', '+', '-', '+'],
  ...                    'title': ['a', 'b', 'c', 'd']})
  >>> gr3 = pr.concat([gr1, gr2])
  >>> gr3
    index  |    Chromosome      Start      End  Strand    title
    int64  |    object          int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |    chr1                5       10  +         a
        1  |    chr1               20       28  +         b
        2  |    chr1               80       95  -         c
        3  |    chr3               10       38  +         d
        0  |    chr1                5       10  +         a
        1  |    chr1               20       28  +         b
        2  |    chr1               80       95  -         c
        3  |    chr3               10       38  +         d
  PyRanges with 8 rows, 5 columns, and 1 index columns (with 4 index duplicates).
  Contains 2 chromosomes and 2 strands.

Note that this may result in index duplicates, which can be remedied by pandas ``reset_index`` method.

  >>> pr.concat([gr1, gr2]).reset_index(drop=True)
    index  |    Chromosome      Start      End  Strand    title
    int64  |    object          int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |    chr1                5       10  +         a
        1  |    chr1               20       28  +         b
        2  |    chr1               80       95  -         c
        3  |    chr3               10       38  +         d
        4  |    chr1                5       10  +         a
        5  |    chr1               20       28  +         b
        6  |    chr1               80       95  -         c
        7  |    chr3               10       38  +         d
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 2 chromosomes and 2 strands.

Data for testing
----------------

For testing purposes, pyranges provides some data in :ref:`pr.example_data <pyranges_example_data>`.
See an overview with:

  >>> pr.example_data
  Available example data:
  -----------------------
  example_data.chipseq            : Example ChIP-seq data.
  example_data.chipseq_background : Example ChIP-seq data.
  example_data.chromsizes         : Example chromsizes data (hg19).
  example_data.ensembl_gtf        : Example gtf file from Ensembl.
  example_data.interpro_hits      : Example of InterPro protein hits.
  example_data.rfam_hits          : Example of RNA motifs (Rfam) as 1-based dataframe.
  example_data.f1                 : Example bed file.
  example_data.f2                 : Example bed file.
  example_data.aorta              : Example ChIP-seq data.
  example_data.aorta2             : Example ChIP-seq data.
  example_data.ncbi_gff           : Example NCBI GFF data.
  example_data.ncbi_fasta         : Example NCBI fasta.
  example_data.files              : Return a dict of basenames to file paths of available data.

You can load the data with this syntax:

  >>> cs = pr.example_data.chipseq
  >>> cs
  index    |    Chromosome    Start      End        Name      Score    Strand
  int64    |    category      int64      int64      object    int64    category
  -------  ---  ------------  ---------  ---------  --------  -------  ----------
  0        |    chr8          28510032   28510057   U0        0        -
  1        |    chr7          107153363  107153388  U0        0        -
  2        |    chr5          135821802  135821827  U0        0        -
  3        |    chr14         19418999   19419024   U0        0        -
  ...      |    ...           ...        ...        ...       ...      ...
  16       |    chr9          120803448  120803473  U0        0        +
  17       |    chr6          89296757   89296782   U0        0        -
  18       |    chr1          194245558  194245583  U0        0        +
  19       |    chr8          57916061   57916086   U0        0        +
  PyRanges with 20 rows, 6 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

On the on other hand, you can create random intervals using :func:`pyranges.random`.
By default, the data refers to the human genome (hg19):

  >>> pr.random(n=5, length=50, seed=123)
    index  |    Chromosome        Start        End  Strand
    int64  |    object            int64      int64  object
  -------  ---  ------------  ---------  ---------  --------
        0  |    chr12         108700348  108700398  +
        1  |    chr1          230144267  230144317  -
        2  |    chr3           54767920   54767970  +
        3  |    chr3          162329749  162329799  +
        4  |    chr3          176218669  176218719  +
  PyRanges with 5 rows, 4 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.


.. *** docs/extension_stats.rst ***


Stats: statistics
-----------------

Utilities for calculating statistics about genomic intervals.

.. automodule:: pyranges.stats
    :members:
    :imported-members:



.. *** docs/developer_guide.rst ***

Developer guide
===============

Pyranges was originally written by Endre Bakken Stovner under supervision of P√•l S√¶trom.
It is now mainly developed by Endre Bakken Stovner and by the Comparative Genomics lab of
Marco Mariotti. It follows the guidelines for open source software, and external contributors
are welcome. The code is centralized on github, at https://github.com/pyranges/pyranges_1.x

Bugs and feature requests can be reported as github issues. You may also contribute by submitting
your own code edits, either to deal with issues or to add new functionalities. Please discuss new
features with the team before making a PR. The code will be reviewed by the core development team,
which may integrate it in the main repository. Contributions are tracked by github and are publicly
visible.

Below, we sketch a guide to contribute to Pyranges. It assumes familiarity with python and with the
terminal, and minimal experience with git/github. Before the actual list of steps follow (:ref:`Task
sequence <task_sequence>`), we go over some essential concepts used in the "continuous integration" system in place
to maintain and evolve Pyranges.




Tests
~~~~~

Tests are an essential part of continuous integration. Briefly, they ensure that code edits do not
break existing functions. Various layers of tests are implemented in Pyranges:

- **unit tests**: quick and compulsory tests about the main Pyranges functionalities
- **doctest**: quick and compulsory tests that ensures that the code in the documentation (tutorial and how-to-pages) gives the expected results
- **property based tests**: time-consuming tests that involve the generation of random data to check that the results of Pyranges functions match that of other reference bioinformatic tools. These tests are not compulsory: the core development team runs them when the code backbone is edited.

If the code submitted to Pyranges does not pass the compulsory tests, it will not be integrated.
Therefore, we highly recommend developers to run tests before code submissions, as explained
further below.



Documentation: docstrings
~~~~~~~~~~~~~~~~~~~~~~~~~

Python docstrings are widely used to document the rationale, input arguments, and returned values of
all functions and methods. The use of a consistent docstring style allows the automatic generation
of API documentation, as seen in Pyranges documentation at `https://pyranges.readthedocs.io/
<https://pyranges.readthedocs.io/>`_, built through the Sphynx software.

Pyranges adopts the NumPy/SciPy-style: `https://numpydoc.readthedocs.io/en/latest/format.html
<https://numpydoc.readthedocs.io/en/latest/format.html>`_. It is important that code contributors
who edit any function also update their docstrings to reflect how it works; and that all new
functions contain an appropriate docstring. Follow the link above and inspect existing Pyranges
code to write good docstrings.



Code formatting and linting
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pyranges code follows strict guidelines about its formatting and non-redundancy. This burden is
not upon the developer: instead, this is achieved by running dedicated software that polishes,
formats, and "lints" the code before its integration in the main repository. The tool **ruff**
is used, for both code linting and formatting.

Type checking
~~~~~~~~~~~~~

Pyranges is strict about type checking to ensure code reliability and maintainability. Type
checking involves specifying and verifying the data types of variables and functions, a
practice that may be unfamiliar to some Python developers.

These annotations allow tools like **pyright**, which we use extensively, to check types.
Consequently, if `add` is called with non-integer arguments or if it returns a non-integer value,
the type checker flags an error. This preemptive error detection, happening at compile
time (before the code is run), significantly reduces runtime issues and enhances code quality.

For example, consider this basic function:

.. code:: python

    def add(a, b):
        return a + b

With type annotations, it becomes:

.. code:: python

    def add(a: int, b: int) -> int:
        return a + b

For more detailed guidance on typing in Python, see the
`official Python documentation <https://docs.python.org/3/library/typing.html>`_.

We encourage contributions to Pyranges, even if they involve partial typing. If you're new
to typing or have any questions, feel free to ask for help. We're committed to supporting
our community in enhancing Pyranges together.

.. _task_sequence:

Task sequence
~~~~~~~~~~~~~

1. Create and download your own Pyranges fork
---------------------------------------------

The easiest way to do this is through github. Login into the github website if you aren't already,
then visit the Pyranges page on github, click "Fork" on the top right. 
Fill the form and confirm. In the page of your new fork, find the
**<> Code** button, and copy the https address. On your computer, create a new folder dedicated
to the project, then clone your fork inside it:

.. code:: bash

	mkdir mypyranges
	cd mypyranges
	git clone PASTE_GITHUB_HTTPS

2. Set up your developer environment and install Pyranges
---------------------------------------------------------

We recommend creating an environment dedicated to the development of pyranges:

.. code:: bash

	conda create -n prdev python pip
	conda activate prdev


Next, let's install pyranges and its dependencies: cd into your pyranges fork, 
and install it locally with pip as shown below. By using pip
option ``-e``, your installation is in "editable" mode: any changes you make to your pyranges code
will be immediately reflected in your environment. In other words, you won't need to re-run pip
install every time you change something in the code. 

.. code:: bash

	cd pyranges
	pip install -e .

Next, let's install optional dependencies (necessary to run certain functions and thus required to 
pass tests) and all developer dependencies (necessary to run tests, lint code etc). Their list, like 
most of Pyranges configuration, is found in the pyproject.toml file. You can install all you need with:

.. code:: bash

	pip install .[all]


3. Edit the code
----------------

Now, you're ready to edit the code in the pyranges/ folder.

To run your code to see that it behaves as intended, we recommend using a separate script that
imports pyranges, making sure you're in the prdev conda environment.


4. Run tests
------------

For each of the commands below, inspect the output of pytest: warnings are acceptable, but errors must be
fixed. To run the compulsory **doctest** and **unit tests**, run:

.. code:: bash

        pytest --doctest-modules pyranges
        pytest tests/unit

If you modified core Pyranges functions, you may want to also run the non-compulsory **property-based tests**:

.. code:: bash

	pytest tests/property_based/

If any of the tests fail, you must amend them before proceeding. 



5. Format, lint, type-checking code
-----------------------------------

Next, let's format code with ruff:

.. code:: bash

        ruff format pyranges

Then, let's lint code, also with ruff:

.. code:: bash

        ruff check pyranges


If the ruff check above shows any error, you must fix them before you proceed. 
If errors are deemed 'fixable', you may simply run ``ruff check --fix pyranges``. 
If not, you must delve into the code -- note, ChatGPT/Copilot are your friends!

Lastly, let's use pyright to ensure correct type-checking:


.. code:: bash

        pyright

Again, any error in the pyright must be amended before proceeding. Note that if you edit the code, 
you may want to format and lint code again with ruff.

6. Test on all supported python and package versions
-----------------------------------------------------

Next, we use **tox** to test whether the code works across all the versions of python and main dependencies 
that we intend to support. This step internally runs steps 4 and 5 for every such version defined in 
pyproject.toml. (Advanced users may actually directly run 6 instead of 4-5). For this, run:

.. code:: bash

	tox

If any errors emerge, correct them (or ask us for help).

7. Inspect the Sphynx documentation
-----------------------------------

Your code edits may warrant edits in the Pyranges docstrings. In this case, it is compelling to
locally check that the automatically generated documentation is built appropriately. Inside the
pyranges/ folder, run these commands:

.. code:: bash

	cd docs
	make html
	cd -

If the "make" command has no major errors, it will generate the full pyranges documentation in the
form of html pages, identical to `https://pyranges.readthedocs.io/ <https://pyranges.readthedocs.io/>`_.
Open the file docs/build/html/index.html with a browser to inspect all the parts that may have
been affected by your changes, and fix any potential problems. To know more about its inner workings,
read about the Sphynx system.


8. Log your changes
----------------------

At this stage, you are ready to submit your code for integration into the
main Pyranges repository; that is to say, to open a "pull request". Before you can do that, you
have to update your remote repository, i.e. your Pyranges fork at github.

First, bump the version number in the file pyproject.toml. Then, it's essential to document your changes
in the CHANGE_LOG.txt file. This log should provide a clear and
concise summary of the modifications, additions, and fixes made in each version of your project. Include
relevant details such as feature enhancements, bug fixes, and any other notable alterations to help
maintain a transparent and informative record of your project's evolution.

9. Commit and push to your remote repository
---------------------------------------------

Run this command to list all the local files you modified:

.. code:: bash

	git status

You must tell git which of these files have to be synchronized, i.e. "git add" them. You can do this
by explicitly providing the list of files with:

.. code:: bash

	git add file1 file2 ... fileN

Alternatively to the previous command, if you want to add ALL edited files, you can use:

.. code:: bash

	git add . --dry-run

to check the list of all modified files, then this to actually add them:

.. code:: bash

	git add .

After adding files, you have to **commit** your changes locally with:

.. code:: bash

	git commit -m"Include an informative message here"

Finally, **push** to your remote repository, i.e. update your online fork at github, with:

.. code:: bash

	git push

You will be requested your github credentials. Note that your online password may not work; in this
case, google how to set up a github token that you can use.


10. Open a pull request
-----------------------

The easiest way to open a pull request is through the github website. Go to **your**
Pyranges fork on github, then find the "Contribute" button (near the **<> Code** button). Click
it, and select **Open pull request**.

In the newly opened page, carefully check that source and destination are correctly selected. The
Base repository should be pyranges/pyranges (i.e. the main pyranges repo), and the Head repository
should be your fork. If you worked on non-master git branches, select them here.

In the comments, write a summary of the introduced changes and their rationale, tagging any related
github issues (i.e. paste their http address). On the rest of the page, you are presented with a
list of the code edits. When you're ready, click "Open pull request".

Github will run a "check" workflow which basically replicates the steps above. If all checks are ok, 
Pyranges administrators will inspect the pull request, comment it if necessary, and potentially accept it.



11. Core team only: upload to PyPI
----------------------------------

Every now and then, the core development team considers that a new pyranges version should be
released. To do so:

- Update the version number in the pyproject.toml file
- Find the "Build and upload to PyPI" workflow in the left menu of the github actions at `https://github.com/pyranges/pyranges_1.x/actions/ <https://github.com/pyranges/pyranges_1.x/actions/>`_
- Click the "Run workflow" button on the right

Next, check that everything worked correctly, by confirming that a new pyranges installation via
pip selects the new version.

Finally, the pyranges conda package at Bioconda is updated automatically upon pip upload. Check
that this is updated correctly.

12. Assorted tips and recommended tools
---------------------------------------

While developing you might want to autorerun all the unittests and doctests if the contents of the
pyranges folder changes. You can do this with:

.. code:: bash

    ptw pyranges -- --doctest-modules pyranges/ tests/unit/

If you want to run tests in parallel, use the -n flag (only gives a speedup for the long-running
property-based tests):

.. code:: bash

    pytest -n 4 tests/property_based

Other useful tools:

* [rg](https://github.com/BurntSushi/ripgrep): ripgrep recursively searches directories for a regex pattern while respecting your gitignore
* [fd](https://github.com/sharkdp/fd): A simple, fast and user-friendly alternative to 'find'


.. *** docs/how_to_pages.rst ***

How-to pages
============

These pages explain pyranges functionalities grouped by topic:

.. toctree::
   :maxdepth: 3

   how_to_create
   how_to_write
   how_to_inspect
   how_to_rows
   how_to_columns
   how_to_sequences
   how_to_genomic_ops
   how_to_overlap
   how_to_map


.. *** docs/how_to_columns.rst ***

Columns operations
~~~~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2



Fetching or writing a column
----------------------------
Most column operations are analogous to pandas.
A single PyRanges column (which are pandas Series) can be extracted through the dot notation, when reading it:

  >>> import pyranges as pr
  >>> gr = pr.example_data.chipseq
  >>> gr
  index    |    Chromosome    Start      End        Name      Score    Strand
  int64    |    category      int64      int64      object    int64    category
  -------  ---  ------------  ---------  ---------  --------  -------  ----------
  0        |    chr8          28510032   28510057   U0        0        -
  1        |    chr7          107153363  107153388  U0        0        -
  2        |    chr5          135821802  135821827  U0        0        -
  3        |    chr14         19418999   19419024   U0        0        -
  ...      |    ...           ...        ...        ...       ...      ...
  16       |    chr9          120803448  120803473  U0        0        +
  17       |    chr6          89296757   89296782   U0        0        -
  18       |    chr1          194245558  194245583  U0        0        +
  19       |    chr8          57916061   57916086   U0        0        +
  PyRanges with 20 rows, 6 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

  >>> gr.Chromosome.head()
  0     chr8
  1     chr7
  2     chr5
  3    chr14
  4    chr12
  Name: Chromosome, dtype: category
  Categories (15, object): ['chr1', 'chr10', 'chr11', 'chr12', ..., 'chr6', 'chr7', 'chr8', 'chr9']


  >>> ( (gr.End + gr.Start)/2 ).head()
  0     28510044.5
  1    107153375.5
  2    135821814.5
  3     19419011.5
  4    106679773.5
  dtype: float64


The ``gr[column_name]`` syntax also extracts a column from a PyRanges object:

  >>> gr['Chromosome'].head()
  0     chr8
  1     chr7
  2     chr5
  3    chr14
  4    chr12
  Name: Chromosome, dtype: category
  Categories (15, object): ['chr1', 'chr10', 'chr11', 'chr12', ..., 'chr6', 'chr7', 'chr8', 'chr9']


The ``gr[column_name]`` syntax is the only one accepted for assignment (i.e. create or edit a column):

  >>> gr['newchr'] = gr['Chromosome'].str.replace('chr', '')
  >>> gr
  index    |    Chromosome    Start      End        Name      Score    Strand      newchr
  int64    |    category      int64      int64      object    int64    category    object
  -------  ---  ------------  ---------  ---------  --------  -------  ----------  --------
  0        |    chr8          28510032   28510057   U0        0        -           8
  1        |    chr7          107153363  107153388  U0        0        -           7
  2        |    chr5          135821802  135821827  U0        0        -           5
  3        |    chr14         19418999   19419024   U0        0        -           14
  ...      |    ...           ...        ...        ...       ...      ...         ...
  16       |    chr9          120803448  120803473  U0        0        +           9
  17       |    chr6          89296757   89296782   U0        0        -           6
  18       |    chr1          194245558  194245583  U0        0        +           1
  19       |    chr8          57916061   57916086   U0        0        +           8
  PyRanges with 20 rows, 7 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

Extracting multiple columns
---------------------------

As in pandas, you can extract a dataframe with a subset of columns by indexing it with list of column names:

  >>> gr[ ['Chromosome', 'Start'] ].head()
    Chromosome      Start
  0       chr8   28510032
  1       chr7  107153363
  2       chr5  135821802
  3      chr14   19418999
  4      chr12  106679761

When the resulting dataframe has all required genomic location columns (Chromosome, Start, End), then
a PyRanges is returned:

  >>> gr[ ['Chromosome', 'Start', 'End', 'Name'] ].head()
    index  |    Chromosome        Start        End  Name
    int64  |    category          int64      int64  object
  -------  ---  ------------  ---------  ---------  --------
        0  |    chr8           28510032   28510057  U0
        1  |    chr7          107153363  107153388  U0
        2  |    chr5          135821802  135821827  U0
        3  |    chr14          19418999   19419024  U0
        4  |    chr12         106679761  106679786  U0
  PyRanges with 5 rows, 4 columns, and 1 index columns.
  Contains 5 chromosomes.

The method :func:`get_with_loc_columns <pyranges.PyRanges.get_with_loc_columns>` is a shortcut to extract
any column together with the genomic location columns:

  >>> gr.get_with_loc_columns('Name').head()
    index  |    Chromosome        Start        End  Strand      Name
    int64  |    category          int64      int64  category    object
  -------  ---  ------------  ---------  ---------  ----------  --------
        0  |    chr8           28510032   28510057  -           U0
        1  |    chr7          107153363  107153388  -           U0
        2  |    chr5          135821802  135821827  -           U0
        3  |    chr14          19418999   19419024  -           U0
        4  |    chr12         106679761  106679786  -           U0
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 5 chromosomes and 1 strands.

  >>> gr.get_with_loc_columns(['Name', 'Score']).head()
    index  |    Chromosome        Start        End  Strand      Name        Score
    int64  |    category          int64      int64  category    object      int64
  -------  ---  ------------  ---------  ---------  ----------  --------  -------
        0  |    chr8           28510032   28510057  -           U0              0
        1  |    chr7          107153363  107153388  -           U0              0
        2  |    chr5          135821802  135821827  -           U0              0
        3  |    chr14          19418999   19419024  -           U0              0
        4  |    chr12         106679761  106679786  -           U0              0
  PyRanges with 5 rows, 6 columns, and 1 index columns.
  Contains 5 chromosomes and 1 strands.


Dropping columns
----------------

Alternatively, you can specify which columns to remove with the pandas dataframe ``drop`` method.
Again, a PyRanges object is returned only if genomic location columns are maintained:

  >>> gr.drop('Name', axis=1)
  index    |    Chromosome    Start      End        Score    Strand      newchr
  int64    |    category      int64      int64      int64    category    object
  -------  ---  ------------  ---------  ---------  -------  ----------  --------
  0        |    chr8          28510032   28510057   0        -           8
  1        |    chr7          107153363  107153388  0        -           7
  2        |    chr5          135821802  135821827  0        -           5
  3        |    chr14         19418999   19419024   0        -           14
  ...      |    ...           ...        ...        ...      ...         ...
  16       |    chr9          120803448  120803473  0        +           9
  17       |    chr6          89296757   89296782   0        -           6
  18       |    chr1          194245558  194245583  0        +           1
  19       |    chr8          57916061   57916086   0        +           8
  PyRanges with 20 rows, 6 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

  >>> gr.drop(['Name', 'Chromosome', 'newchr'], axis=1).head()
         Start        End  Score Strand
  0   28510032   28510057      0      -
  1  107153363  107153388      0      -
  2  135821802  135821827      0      -
  3   19418999   19419024      0      -
  4  106679761  106679786      0      -

The PyRanges method :func:`remove_strand <pyranges.PyRanges.remove_strand>` is a shortcut to remove the Strand column:

  >>> gr.remove_strand().head()
    index  |    Chromosome        Start        End  Name        Score    newchr
    int64  |    category          int64      int64  object      int64    object
  -------  ---  ------------  ---------  ---------  --------  -------  --------
        0  |    chr8           28510032   28510057  U0              0         8
        1  |    chr7          107153363  107153388  U0              0         7
        2  |    chr5          135821802  135821827  U0              0         5
        3  |    chr14          19418999   19419024  U0              0        14
        4  |    chr12         106679761  106679786  U0              0        12
  PyRanges with 5 rows, 6 columns, and 1 index columns.
  Contains 5 chromosomes.

.. *** docs/how_to_genomic_ops.rst ***

Operating on coordinates
~~~~~~~~~~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2

Operating on coordinates: cheatsheet
------------------------------------

.. image:: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/examples/cheatsheet_genomic_ops.png
   :alt: PyRanges cheatsheet
   :target: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/examples/cheatsheet_genomic_ops.png



Modifying coordinates
---------------------
Interval coordinates (Start, End) can be directly modified like any Series in dataframes.
Let's get some data:

  >>> import pyranges as pr
  >>> ex = pr.example_data.ensembl_gtf
  >>> ex = ex[ex.Feature == "exon"].get_with_loc_columns('transcript_id')
  >>> ex = ex.sort_ranges(use_strand=False).reset_index(drop=True)
  >>> ex
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11868    12227  +           ENST00000456328
        1  |               1    12612    12721  +           ENST00000456328
        2  |               1    13220    14409  +           ENST00000456328
        3  |               1   110952   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        5  |               1   120873   120932  -           ENST00000610542
        6  |               1   129054   129223  -           ENST00000610542
        7  |               1   133373   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

We can modify a whole column at once:

  >>> ex['Start'] += 5
  >>> ex
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11873    12227  +           ENST00000456328
        1  |               1    12617    12721  +           ENST00000456328
        2  |               1    13225    14409  +           ENST00000456328
        3  |               1   110957   111357  -           ENST00000471248
        4  |               1   112704   112804  -           ENST00000471248
        5  |               1   120878   120932  -           ENST00000610542
        6  |               1   129059   129223  -           ENST00000610542
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Or we can modify a slice of the column:

  >>> ex.loc[2:5, 'Start'] -= 5
  >>> ex
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11873    12227  +           ENST00000456328
        1  |               1    12617    12721  +           ENST00000456328
        2  |               1    13220    14409  +           ENST00000456328
        3  |               1   110952   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        5  |               1   120873   120932  -           ENST00000610542
        6  |               1   129059   129223  -           ENST00000610542
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Or use a boolean index:

  >>> ex.loc[ex.Strand == "+", "Start"] += 5
  >>> e=ex.copy()
  >>> e
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    12227  +           ENST00000456328
        1  |               1    12622    12721  +           ENST00000456328
        2  |               1    13225    14409  +           ENST00000456328
        3  |               1   110952   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        5  |               1   120873   120932  -           ENST00000610542
        6  |               1   129059   129223  -           ENST00000610542
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


On the other hand, pyranges offer convenient and intuitive methods to modify coordinates, which deal
with the complexity of intervals and strands.
Next, we will showcase some of its functionalities, using the ``e`` object above as starting point.


Extending intervals
-------------------
The :func:`extend_ranges <pyranges.PyRanges.extend_ranges>` method allows to extend the intervals in a PyRanges object.
The ``ext`` parameter implies an extension in both directions of all intervals:

  >>> e.extend_ranges(ext=5)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11873    12232  +           ENST00000456328
        1  |               1    12617    12726  +           ENST00000456328
        2  |               1    13220    14414  +           ENST00000456328
        3  |               1   110947   111362  -           ENST00000471248
        4  |               1   112694   112809  -           ENST00000471248
        5  |               1   120868   120937  -           ENST00000610542
        6  |               1   129054   129228  -           ENST00000610542
        7  |               1   133373   133728  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

The ``ext_5`` and ``ext_3`` parameters allow to specify separately the extension in the 5' and 3' directions,
respectively. These operations are strand-aware, meaning that a 5' extension affects the Start position of intervals
on the positive strand, and the End position of intervals on the negative strand, and vice versa for 3' extensions.

Let's extend upstream by 10 bases:

  >>> e.extend_ranges(ext_5=10)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11868    12227  +           ENST00000456328
        1  |               1    12612    12721  +           ENST00000456328
        2  |               1    13215    14409  +           ENST00000456328
        3  |               1   110952   111367  -           ENST00000471248
        4  |               1   112699   112814  -           ENST00000471248
        5  |               1   120873   120942  -           ENST00000610542
        6  |               1   129059   129233  -           ENST00000610542
        7  |               1   133378   133733  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Let's extend by 12 bases on the 5' end, and 6 bases on the 3' end:

  >>> e.extend_ranges(ext_5=12, ext_3=6)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11866    12233  +           ENST00000456328
        1  |               1    12610    12727  +           ENST00000456328
        2  |               1    13213    14415  +           ENST00000456328
        3  |               1   110946   111369  -           ENST00000471248
        4  |               1   112693   112816  -           ENST00000471248
        5  |               1   120867   120944  -           ENST00000610542
        6  |               1   129053   129235  -           ENST00000610542
        7  |               1   133372   133735  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

To ignore strand (i.e. treat all intervals as if on the positive strand), use ``use_strand=False``:

  >>> e.extend_ranges(ext_5=12, ext_3=6, use_strand=False)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11866    12233  +           ENST00000456328
        1  |               1    12610    12727  +           ENST00000456328
        2  |               1    13213    14415  +           ENST00000456328
        3  |               1   110940   111363  -           ENST00000471248
        4  |               1   112687   112810  -           ENST00000471248
        5  |               1   120861   120938  -           ENST00000610542
        6  |               1   129047   129229  -           ENST00000610542
        7  |               1   133366   133729  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

In all examples above, the extension is applied independently to all intervals in the PyRanges object.
Alternatively, you can group intervals by a column, specified with the ``group_by`` argument.
When provided, extensions are relative to the transcript, not the interval. In practice, only the first and/or last
exons of each transcript may be extended:

  >>> e.extend_ranges(ext_5=10, group_by='transcript_id')
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11868    12227  +           ENST00000456328
        1  |               1    12622    12721  +           ENST00000456328
        2  |               1    13225    14409  +           ENST00000456328
        3  |               1   110952   111357  -           ENST00000471248
        4  |               1   112699   112814  -           ENST00000471248
        5  |               1   120873   120932  -           ENST00000610542
        6  |               1   129059   129223  -           ENST00000610542
        7  |               1   133378   133733  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Slicing operations
------------------

Slicing operations are operations that cut the intervals in a PyRanges object to obtain smaller intervals.
Intervals may be treated independently (default) or grouped in transcripts.

Method :func:`slice_ranges <pyranges.PyRanges.slice_ranges>` allows to
obtain slices by specifying the ``start`` and ``end`` position, in python notation.
So, to get the first 10 bases of each interval, we can do:

  >>> e.slice_ranges(start=0, end=10)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    11888  +           ENST00000456328
        1  |               1    12622    12632  +           ENST00000456328
        2  |               1    13225    13235  +           ENST00000456328
        3  |               1   111347   111357  -           ENST00000471248
        4  |               1   112794   112804  -           ENST00000471248
        5  |               1   120922   120932  -           ENST00000610542
        6  |               1   129213   129223  -           ENST00000610542
        7  |               1   133713   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Note above that positions refer to the 5' end of intervals, meaning that counting
occurs from right to left for intervals on the negative strand.
You can ignore strand using ``use_strand=False``:

  >>> e.slice_ranges(start=0, end=10, use_strand=False)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    11888  +           ENST00000456328
        1  |               1    12622    12632  +           ENST00000456328
        2  |               1    13225    13235  +           ENST00000456328
        3  |               1   110952   110962  -           ENST00000471248
        4  |               1   112699   112709  -           ENST00000471248
        5  |               1   120873   120883  -           ENST00000610542
        6  |               1   129059   129069  -           ENST00000610542
        7  |               1   133378   133388  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

``start`` and ``end`` can be provided as positional arguments. ``end`` can be omitted.
When requesting a slice that is entirely out of bounds, the corresponding rows are absent in output.
The following yields intervals from position 200 to their existing 3' end
(i.e. we remove the first 200 bases of each interval).
Note that intervals that were <200 bp have no row in output:

  >>> e.slice_ranges(200)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    12078    12227  +           ENST00000456328
        2  |               1    13425    14409  +           ENST00000456328
        3  |               1   110952   111157  -           ENST00000471248
        7  |               1   133378   133523  -           ENST00000610542
  PyRanges with 4 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Positions can be negative, in which case they are counted from the end of the interval.
To get the last 10 bases of each interval, we can do:

  >>> e.slice_ranges(-10)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    12217    12227  +           ENST00000456328
        1  |               1    12711    12721  +           ENST00000456328
        2  |               1    14399    14409  +           ENST00000456328
        3  |               1   110952   110962  -           ENST00000471248
        4  |               1   112699   112709  -           ENST00000471248
        5  |               1   120873   120883  -           ENST00000610542
        6  |               1   129059   129069  -           ENST00000610542
        7  |               1   133378   133388  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

This returns intervals without their first and last 3 bases:

  >>> e.slice_ranges(3, -3)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11881    12224  +           ENST00000456328
        1  |               1    12625    12718  +           ENST00000456328
        2  |               1    13228    14406  +           ENST00000456328
        3  |               1   110955   111354  -           ENST00000471248
        4  |               1   112702   112801  -           ENST00000471248
        5  |               1   120876   120929  -           ENST00000610542
        6  |               1   129062   129220  -           ENST00000610542
        7  |               1   133381   133720  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Above, each interval is treated independently. Alternatively, you can consider transcripts,
grouping intervals (i.e. exons) by a column, specified with the ``group_by`` argument.
When provided, :func:`slice_ranges <pyranges.PyRanges.slice_ranges>` arguments are relative to the transcript, not the
interval. Note that using ``group_by`` assumes that exons belonging to the same transcript have no overlap; on the other
hand, it does not assume presorting of intervals.

By default, coordinates are relative to **spliced** transcripts.
For example, for a transcript with two exons of 50 bp, the first position of the second exon is considered to be 50
regardless of the length of the intron in-between.

Below we request the first 1500 bases of each spliced transcript. Only
exons are counted to sum up to that length, and introns are ignored:

  >>> e.slice_ranges(0, 1500, group_by='transcript_id')
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    12227  +           ENST00000456328
        1  |               1    12622    12721  +           ENST00000456328
        2  |               1    13225    14277  +           ENST00000456328
        3  |               1   110952   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        5  |               1   120873   120932  -           ENST00000610542
        6  |               1   129059   129223  -           ENST00000610542
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

In the ``e`` object, only ENST00000456328 is larger than 1500 bases.
Compare it with the result above, noting that its third exon has been shortened:

  >>> e
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    12227  +           ENST00000456328
        1  |               1    12622    12721  +           ENST00000456328
        2  |               1    13225    14409  +           ENST00000456328
        3  |               1   110952   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        5  |               1   120873   120932  -           ENST00000610542
        6  |               1   129059   129223  -           ENST00000610542
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

So, this will get the first and last 10 bases of each spliced transcript:

  >>> first10 = e.slice_ranges(0, 10, group_by='transcript_id')
  >>> last10 = e.slice_ranges(-10, group_by='transcript_id')
  >>> pr.concat([first10, last10])
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    11888  +           ENST00000456328
        4  |               1   112794   112804  -           ENST00000471248
        7  |               1   133713   133723  -           ENST00000610542
        2  |               1    14399    14409  +           ENST00000456328
        3  |               1   110952   110962  -           ENST00000471248
        5  |               1   120873   120883  -           ENST00000610542
  PyRanges with 6 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Subsequence operations can be combined with extensions to obtain intervals adjacent to the input ones.
For example, this will obtain the 100 bases upstream of each transcript:

  >>> e.extend_ranges(ext_5=100, group_by='transcript_id').slice_ranges(0, 100, group_by='transcript_id')
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11778    11878  +           ENST00000456328
        4  |               1   112804   112904  -           ENST00000471248
        7  |               1   133723   133823  -           ENST00000610542
  PyRanges with 3 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


This will obtain the 100 bases downstream of each transcript:

  >>> e.extend_ranges(ext_3=100, group_by='transcript_id').slice_ranges(-100, group_by='transcript_id')
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        2  |               1    14409    14509  +           ENST00000456328
        3  |               1   110852   110952  -           ENST00000471248
        5  |               1   120773   120873  -           ENST00000610542
  PyRanges with 3 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

However, pyranges provides more convenients functions to this purpose: :func:`upstream <pyranges.PyRanges.upstream>`
and :func:`downstream <pyranges.PyRanges.downstream>` allow  to obtain regions upstream or
downstream of intervals. They allow to specify the length, as well as any optional gap between
the returned intervals and the input ones:

  >>> e.downstream(100, group_by='transcript_id')
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        2  |               1    14409    14509  +           ENST00000456328
        3  |               1   110852   110952  -           ENST00000471248
        5  |               1   120773   120873  -           ENST00000610542
  PyRanges with 3 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> e.downstream(100, gap=10, group_by='transcript_id')
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        2  |               1    14419    14519  +           ENST00000456328
        3  |               1   110842   110942  -           ENST00000471248
        5  |               1   120763   120863  -           ENST00000610542
  PyRanges with 3 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Sometimes, you may want to slice ranges according to non-spliced coordinates. This can be done with
:func:`slice_ranges <pyranges.PyRanges.slice_ranges>` setting the ``count_introns`` argument to ``True``.
So, the following will get the subintervals included in the first 1500 bases of each unspliced transcript:

  >>> e.slice_ranges(0, 1500, group_by='transcript_id', count_introns=True)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    12227  +           ENST00000456328
        1  |               1    12622    12721  +           ENST00000456328
        2  |               1    13225    13378  +           ENST00000456328
        3  |               1   111304   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 6 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Thus, the command above is equivalent to requesting the portions of intervals
that overlap with the first 1500 bases of the boundaries of each transcript:

  >>> b = e.outer_ranges('transcript_id')
  >>> b
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    14409  +           ENST00000456328
        1  |               1   110952   112804  -           ENST00000471248
        2  |               1   120873   133723  -           ENST00000610542
  PyRanges with 3 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> e.intersect_overlaps( b.slice_ranges(0, 1500) )
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    12227  +           ENST00000456328
        1  |               1    12622    12721  +           ENST00000456328
        2  |               1    13225    13378  +           ENST00000456328
        3  |               1   111304   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 6 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Interval complement
-------------------

Another useful operation is to obtain the complement of intervals in a PyRanges object, that is,
all the bases that are not covered by any of the intervals.
This can be done with the :func:`complement_ranges <pyranges.PyRanges.complement_ranges>` method.
Let's revise our ``e`` object:

  >>> e
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    12227  +           ENST00000456328
        1  |               1    12622    12721  +           ENST00000456328
        2  |               1    13225    14409  +           ENST00000456328
        3  |               1   110952   111357  -           ENST00000471248
        4  |               1   112699   112804  -           ENST00000471248
        5  |               1   120873   120932  -           ENST00000610542
        6  |               1   129059   129223  -           ENST00000610542
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

By default, the complement return includes only the internals that are not covered by any of the intervals, and
split by strand; it does not include the bases before the first interval or after the last one.

  >>> e.complement_ranges()
    index  |      Chromosome    Start      End  Strand
    int64  |        category    int64    int64  category
  -------  ---  ------------  -------  -------  ----------
        0  |               1    12227    12622  +
        1  |               1    12721    13225  +
        2  |               1   111357   112699  -
        3  |               1   112804   120873  -
        4  |               1   120932   129059  -
        5  |               1   129223   133378  -
  PyRanges with 6 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Argument ``use_strand`` allows to ignore strand, returning the complement of all intervals:

  >>> e.complement_ranges(use_strand=False)
    index  |      Chromosome    Start      End
    int64  |        category    int64    int64
  -------  ---  ------------  -------  -------
        0  |               1    12227    12622
        1  |               1    12721    13225
        2  |               1    14409   110952
        3  |               1   111357   112699
        4  |               1   112804   120873
        5  |               1   120932   129059
        6  |               1   129223   133378
  PyRanges with 7 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

A possible application of the complement operation is to obtain the intergenic regions. To do that, we use the
boundaries of each transcript group, i.e. object ``b`` obtained above:

  >>> b.complement_ranges(use_strand=False)
    index  |      Chromosome    Start      End
    int64  |        category    int64    int64
  -------  ---  ------------  -------  -------
        0  |               1    14409   110952
        1  |               1   112804   120873
  PyRanges with 2 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

Note that the first and last intervals are not included in the output. To do so, we set ``include_first_interval=True``,
and provide the ``chromsize`` argument, which is a dictionary with chromosome names as keys and their sizes as values:

>>> b.complement_ranges(use_strand=False, chromsizes={'1':249250621}, include_first_interval=True)
  index  |      Chromosome    Start        End
  int64  |        category    int64      int64
-------  ---  ------------  -------  ---------
      0  |               1        0      11878
      1  |               1    14409     110952
      2  |               1   112804     120873
      3  |               1   133723  249250621
PyRanges with 4 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.


Another useful application of the complement operation is to obtain the coordinates of introns in a transcript.
To do this, the complement must be applied to each transcript independently, that is, grouped by a column.
This can be done with the ``group_by`` argument:

  >>> introns = e.complement_ranges(group_by='transcript_id')
  >>> introns
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    12227    12622  +           ENST00000456328
        1  |               1    12721    13225  +           ENST00000456328
        2  |               1   111357   112699  -           ENST00000471248
        3  |               1   120932   129059  -           ENST00000610542
        4  |               1   129223   133378  -           ENST00000610542
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.


Other slicing operations
------------------------

Many genomic analyses involve running a sliding window over the genome or subregions of it.
Method :func:`window_ranges <pyranges.PyRanges.window_ranges>` allows to obtain adjacent windows of a specified size and step that
span each interval in a PyRanges object.

  >>> g = pr.PyRanges(dict(Chromosome=1, Start=[4, 60, 100], End=[11, 66, 107],
  ...                      Strand=['+', '+', '-'], Name=['a', 'a', 'b']))
  >>> g
    index  |      Chromosome    Start      End  Strand    Name
    int64  |           int64    int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |               1        4       11  +         a
        1  |               1       60       66  +         a
        2  |               1      100      107  -         b
  PyRanges with 3 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

For example, let's get windows of size 3:

  >>> g.window_ranges(3)
    index  |      Chromosome    Start      End  Strand    Name
    int64  |           int64    int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |               1        4        7  +         a
        0  |               1        7       10  +         a
        0  |               1       10       11  +         a
        1  |               1       60       63  +         a
        1  |               1       63       66  +         a
        2  |               1      104      107  -         b
        2  |               1      101      104  -         b
        2  |               1      100      101  -         b
  PyRanges with 8 rows, 5 columns, and 1 index columns (with 5 index duplicates).
  Contains 1 chromosomes and 2 strands.

Windows are generated for each interval independently. Strand is considered: they are generated starting from the 5'
end. To ignore strand, use ``use_strand=False``:

  >>> g.window_ranges(3, use_strand=False)
    index  |      Chromosome    Start      End  Strand    Name
    int64  |           int64    int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |               1        4        7  +         a
        0  |               1        7       10  +         a
        0  |               1       10       11  +         a
        1  |               1       60       63  +         a
        1  |               1       63       66  +         a
        2  |               1      100      103  -         b
        2  |               1      103      106  -         b
        2  |               1      106      107  -         b
  PyRanges with 8 rows, 5 columns, and 1 index columns (with 5 index duplicates).
  Contains 1 chromosomes and 2 strands.

To avoid duplicated indices, run pandas dataframe method ``reset_index`` on the output:

  >>> g.window_ranges(3).reset_index(drop=True)
    index  |      Chromosome    Start      End  Strand    Name
    int64  |           int64    int64    int64  object    object
  -------  ---  ------------  -------  -------  --------  --------
        0  |               1        4        7  +         a
        1  |               1        7       10  +         a
        2  |               1       10       11  +         a
        3  |               1       60       63  +         a
        4  |               1       63       66  +         a
        5  |               1      104      107  -         b
        6  |               1      101      104  -         b
        7  |               1      100      101  -         b
  PyRanges with 8 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

To may retain the old index as column, with:

  >>> g.window_ranges(3).reset_index(names='g_index')
    index  |      g_index    Chromosome    Start      End  Strand    Name
    int64  |        int64         int64    int64    int64  object    object
  -------  ---  ---------  ------------  -------  -------  --------  --------
        0  |            0             1        4        7  +         a
        1  |            0             1        7       10  +         a
        2  |            0             1       10       11  +         a
        3  |            1             1       60       63  +         a
        4  |            1             1       63       66  +         a
        5  |            2             1      104      107  -         b
        6  |            2             1      101      104  -         b
        7  |            2             1      100      101  -         b
  PyRanges with 8 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

To 'window' a whole genome (e.g. to then quantify reads in each window), pyranges offers
:func:`pyranges.tile_genome`. Here, you must provide chromosome sizes, with various syntaxes accepted, and again a
window size. This function will return windows to cover all the chromosomes:

  >>> cs={'chr1':323, 'chr2':125} # creating a dictionary with chromosome sizes
  >>> pr.tile_genome(cs, 100)
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                0      100
        1  |    chr1              100      200
        2  |    chr1              200      300
        3  |    chr1              300      323
        4  |    chr2                0      100
        5  |    chr2              100      125
  PyRanges with 6 rows, 3 columns, and 1 index columns.
  Contains 2 chromosomes.

Note that the last window is not full, as the chromosome size is not a multiple of the window size.
To ensure tile size consistency, use the ``full_last_tile`` parameter:

  >>> pr.tile_genome(cs, 100, full_last_tile=True)
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                0      100
        1  |    chr1              100      200
        2  |    chr1              200      300
        3  |    chr1              300      400
        4  |    chr2                0      100
        5  |    chr2              100      200
  PyRanges with 6 rows, 3 columns, and 1 index columns.
  Contains 2 chromosomes.


A related operation is :func:`tile_ranges <pyranges.PyRanges.tile_ranges>`, whose rationale is to obtain only the genome tiles (of
a defined size) that overlap the intervals in a PyRanges object:


  >>> se = e.loc[[0,7],:]
  >>> se
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11878    12227  +           ENST00000456328
        7  |               1   133378   133723  -           ENST00000610542
  PyRanges with 2 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

  >>> se.tile_ranges(200)
    index  |      Chromosome    Start      End  Strand      transcript_id
    int64  |        category    int64    int64  category    object
  -------  ---  ------------  -------  -------  ----------  ---------------
        0  |               1    11800    12000  +           ENST00000456328
        0  |               1    12000    12200  +           ENST00000456328
        0  |               1    12200    12400  +           ENST00000456328
        7  |               1   133200   133400  -           ENST00000610542
        7  |               1   133400   133600  -           ENST00000610542
        7  |               1   133600   133800  -           ENST00000610542
  PyRanges with 6 rows, 5 columns, and 1 index columns (with 4 index duplicates).
  Contains 1 chromosomes and 2 strands.

Note that, in contrast with :func:`window_ranges <pyranges.PyRanges.window_ranges>`, the function
:func:`tile_ranges <pyranges.PyRanges.tile_ranges>` returns intervals anchored to genome positions: their Start will always be
a multiple of the tile size, like :func:`pyranges.tile_genome`, and regardless of the strand of the original intervals.
Argument ``overlap_column`` can be used to add a column indicating how much of the original interval
overlaps with the tile returned:

  >>> se.tile_ranges(200, overlap_column='nts')
    index  |      Chromosome    Start      End  Strand      transcript_id          nts
    int64  |        category    int64    int64  category    object             float64
  -------  ---  ------------  -------  -------  ----------  ---------------  ---------
        0  |               1    11800    12000  +           ENST00000456328      0.61
        0  |               1    12000    12200  +           ENST00000456328      1
        0  |               1    12200    12400  +           ENST00000456328      0.135
        7  |               1   133200   133400  -           ENST00000610542      0.11
        7  |               1   133400   133600  -           ENST00000610542      1
        7  |               1   133600   133800  -           ENST00000610542      0.615
  PyRanges with 6 rows, 6 columns, and 1 index columns (with 4 index duplicates).
  Contains 1 chromosomes and 2 strands.


.. *** docs/how_to_inspect.rst ***

Inspecting PyRanges
~~~~~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2

String representation
---------------------

Print a PyRanges object for an overview of its data:

  >>> import pyranges as pr
  >>> gr = pr.example_data.chipseq
  >>> print(gr)
  index    |    Chromosome    Start      End        Name      Score    Strand
  int64    |    category      int64      int64      object    int64    category
  -------  ---  ------------  ---------  ---------  --------  -------  ----------
  0        |    chr8          28510032   28510057   U0        0        -
  1        |    chr7          107153363  107153388  U0        0        -
  2        |    chr5          135821802  135821827  U0        0        -
  3        |    chr14         19418999   19419024   U0        0        -
  ...      |    ...           ...        ...        ...       ...      ...
  16       |    chr9          120803448  120803473  U0        0        +
  17       |    chr6          89296757   89296782   U0        0        -
  18       |    chr1          194245558  194245583  U0        0        +
  19       |    chr8          57916061   57916086   U0        0        +
  PyRanges with 20 rows, 6 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

To obtain this representation, you can invoke the ``str`` builtin, e.g. with ``str(gr)``.

  >>> a = str(gr)
  >>> print(a)
  index    |    Chromosome    Start      End        Name      Score    Strand
  int64    |    category      int64      int64      object    int64    category
  -------  ---  ------------  ---------  ---------  --------  -------  ----------
  0        |    chr8          28510032   28510057   U0        0        -
  1        |    chr7          107153363  107153388  U0        0        -
  2        |    chr5          135821802  135821827  U0        0        -
  3        |    chr14         19418999   19419024   U0        0        -
  ...      |    ...           ...        ...        ...       ...      ...
  16       |    chr9          120803448  120803473  U0        0        +
  17       |    chr6          89296757   89296782   U0        0        -
  18       |    chr1          194245558  194245583  U0        0        +
  19       |    chr8          57916061   57916086   U0        0        +
  PyRanges with 20 rows, 6 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

Only a limited number of rows are displayed, which are taken from the top and bottom of the table.
You can change the number of rows displayed in any PyRanges using :func:`pyranges.options.set_options` as such:

  >>> pr.options.set_option('max_rows_to_show', 20)
  >>> gr
    index  |    Chromosome        Start        End  Name        Score  Strand
    int64  |    category          int64      int64  object      int64  category
  -------  ---  ------------  ---------  ---------  --------  -------  ----------
        0  |    chr8           28510032   28510057  U0              0  -
        1  |    chr7          107153363  107153388  U0              0  -
        2  |    chr5          135821802  135821827  U0              0  -
        3  |    chr14          19418999   19419024  U0              0  -
        4  |    chr12         106679761  106679786  U0              0  -
        5  |    chr21          40099618   40099643  U0              0  +
        6  |    chr8           22714402   22714427  U0              0  -
        7  |    chr19          19571102   19571127  U0              0  +
        8  |    chr3          140986358  140986383  U0              0  -
        9  |    chr10          35419784   35419809  U0              0  -
       10  |    chr4           98488749   98488774  U0              0  +
       11  |    chr11          22225193   22225218  U0              0  +
       12  |    chr1           38457520   38457545  U0              0  +
       13  |    chr1           80668132   80668157  U0              0  -
       14  |    chr2          152562484  152562509  U0              0  -
       15  |    chr4          153155301  153155326  U0              0  +
       16  |    chr9          120803448  120803473  U0              0  +
       17  |    chr6           89296757   89296782  U0              0  -
       18  |    chr1          194245558  194245583  U0              0  +
       19  |    chr8           57916061   57916086  U0              0  +
  PyRanges with 20 rows, 6 columns, and 1 index columns.
  Contains 15 chromosomes and 2 strands.

Let's reset display options to defaults:

  >>> pr.options.reset_options()



Detecting invalid PyRanges
--------------------------

The string representation of PyRanges shows useful information to detect data anomalies.

For example, intervals may have invalid lengths. Note that message at the bottom:

  >>> pr.PyRanges(dict(Chromosome='chr1', Start=[1, 10], End=[0, 20]))
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                1        0
        1  |    chr1               10       20
  PyRanges with 2 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.
  Invalid ranges:
    * 1 intervals are empty or negative length (end <= start). See indexes: 0

Intervals may also be invalid because of NaN in their Start or End values:

  >>> pr.PyRanges(dict(Chromosome='chr1', Start=[None, 10], End=[0, 20]))
    index  |    Chromosome        Start      End
    int64  |    object          float64    int64
  -------  ---  ------------  ---------  -------
        0  |    chr1                nan        0
        1  |    chr1                 10       20
  PyRanges with 2 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.
  Invalid ranges:
    * 1 starts or ends are nan. See indexes: 0

Or because they have negative Start/End values, see below. This can be remedied with
function :func:`clip_ranges <pyranges.PyRanges.clip_ranges>`.

  >>> pr.PyRanges(dict(Chromosome='chr1', Start=[1, -10], End=[11, 20]))
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                1       11
        1  |    chr1              -10       20
  PyRanges with 2 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.
  Invalid ranges:
    * 1 starts or ends are < 0. See indexes: 1

A relatively common case is PyRanges objects that have a Strand column, but the strands are not valid genomic strands.
Note the warning in the last line of the string representation:

  >>> g = pr.PyRanges(dict(Chromosome='chr1', Start=[1, 1], End=[11, 20], Strand=['-', '#']))
  >>> g
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                1       11  -
        1  |    chr1                1       20  #
  PyRanges with 2 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands (including non-genomic strands: #).

Non-valid strands can affect the functioning of many methods that have a ``use_strand`` parameter
(e.g. :func:`slice_ranges <pyranges.PyRanges.slice_ranges>`) or
a ``strand_behavior`` parameter (e.g. :func:`overlap <pyranges.PyRanges.overlap>`), because these parameters
by default are set to ``auto``, meaning that strand is considered only if it is valid.
Indeed, see that this subregion is calculated from the left limit, even for the interval on  the '-' strand:

  >>> g.slice_ranges(0, 3)
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                1        4  -
        1  |    chr1                1        4  #
  PyRanges with 2 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands (including non-genomic strands: #).

When running the code above, you should get a warning message like this:

  .. code-block:: none

    UserWarning: slice_ranges: 'auto' use_strand treated as False due to invalid Strand values. Suppress this warning with use_strand=False
    g.slice_ranges(0, 3)

You can check whether a PyRanges object has valid Strand information with property
:func:`strand_valid <pyranges.PyRanges.strand_valid>`:

  >>> g.strand_valid
  False

To fix the invalid strands by turning them to '+',
use method :func:`make_strand_valid <pyranges.PyRanges.make_strand_valid>`:

  >>> g2 = g.make_strand_valid()
  >>> g2
    index  |    Chromosome      Start      End  Strand
    int64  |    object          int64    int64  object
  -------  ---  ------------  -------  -------  --------
        0  |    chr1                1       11  -
        1  |    chr1                1       20  +
  PyRanges with 2 rows, 4 columns, and 1 index columns.
  Contains 1 chromosomes and 2 strands.

Lastly, some operations may result in PyRanges with duplicated indices, which is shown in the
penultimate line of the string representation:

  >>> gr1= pr.PyRanges(dict(Chromosome='chr1', Start=[1], End=[100]))
  >>> gr2 = pr.PyRanges(dict(Chromosome='chr1', Start=[20, 50], End=[30, 60]))
  >>> gr3 = gr1.subtract_overlaps(gr2)
  >>> gr3
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                1       20
        0  |    chr1               30       50
        0  |    chr1               60      100
  PyRanges with 3 rows, 3 columns, and 1 index columns (with 2 index duplicates).
  Contains 1 chromosomes.

To remedy this, use pandas method ``reset_index``:

  >>> gr3 = gr3.reset_index(drop=True)
  >>> gr3
    index  |    Chromosome      Start      End
    int64  |    object          int64    int64
  -------  ---  ------------  -------  -------
        0  |    chr1                1       20
        1  |    chr1               30       50
        2  |    chr1               60      100
  PyRanges with 3 rows, 3 columns, and 1 index columns.
  Contains 1 chromosomes.

Column summary statistics
-------------------------
PyRanges columns are pandas Series, and they may be of different data types.
The types are shown in the header shown in their string representation (see above).
To see them all, use property ``dtypes`` like you do for dataframes:

  >>> gr.dtypes
  Chromosome    category
  Start            int64
  End              int64
  Name            object
  Score            int64
  Strand        category
  dtype: object

There are convenient methods inherited from pandas dataframes to inspect PyRanges objects, such as ``info``:

  >>> gr.info() # doctest: +NORMALIZE_WHITESPACE
  <class 'pyranges.core.pyranges_main.PyRanges'>
  RangeIndex: 20 entries, 0 to 19
  Data columns (total 6 columns):
   #   Column      Non-Null Count  Dtype
  ---  ------      --------------  -----
   0   Chromosome  20 non-null     category
   1   Start       20 non-null     int64
   2   End         20 non-null     int64
   3   Name        20 non-null     object
   4   Score       20 non-null     int64
   5   Strand      20 non-null     category
  dtypes: category(2), int64(3), object(1)
  memory usage: 1.6+ KB

On the other hand, ``describe`` reports aggregate metrics of numerical columns:

  >>> gr.describe()
                Start           End  Score
  count  2.000000e+01  2.000000e+01   20.0
  mean   8.320972e+07  8.320975e+07    0.0
  std    5.439939e+07  5.439939e+07    0.0
  min    1.941900e+07  1.941902e+07    0.0
  25%    3.369235e+07  3.369237e+07    0.0
  50%    8.498244e+07  8.498247e+07    0.0
  75%    1.245580e+08  1.245581e+08    0.0
  max    1.942456e+08  1.942456e+08    0.0


.. *** docs/how_to_map.rst ***

Mapping between coordinate systems
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. contents::
   :local:
   :depth: 2

Mapping coordinate systems: cheatsheet
--------------------------------------

.. image:: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/examples/cheatsheet_mapping.png
   :alt: PyRanges cheatsheet
   :target: https://raw.githubusercontent.com/pyranges/pyrangeyes/for_pyranges1_1/examples/cheatsheet_mapping.png


:func:`overlap <pyranges.PyRanges.overlap>`.

Nested coordinate systems
-------------------------

PyRanges may represent nested coordinate systems, where the intervals in one coordinate system
are relative to the intervals in another coordinate system. This is useful for representing hierarchical data.

Let's make an intuitive case. On the one hand, we have some global ranges, that is
genomic intervals wherein coordinates refer to positions along the genome:

  >>> import pyranges as pr, pandas as pd
  >>> gr = pr.example_data.ncbi_gff
  >>> gre = (gr[gr.Feature=='exon']).get_with_loc_columns('Parent')
  >>> gre
  index    |    Chromosome         Start    End      Strand      Parent
  int64    |    category           int64    int64    category    object
  -------  ---  -----------------  -------  -------  ----------  ---------------------
  3        |    CAJFCJ010000053.1  4882     5264     -           rna-DGYR_LOCUS13733
  7        |    CAJFCJ010000053.1  10474    10958    +           rna-DGYR_LOCUS13734
  8        |    CAJFCJ010000053.1  11028    11169    +           rna-DGYR_LOCUS13734
  9        |    CAJFCJ010000053.1  11227    11400    +           rna-DGYR_LOCUS13734
  ...      |    ...                ...      ...      ...         ...
  141      |    CAJFCJ010000025.1  2753     2851     -           rna-DGYR_LOCUS12552-2
  142      |    CAJFCJ010000025.1  2593     2693     -           rna-DGYR_LOCUS12552-2
  143      |    CAJFCJ010000025.1  2354     2537     -           rna-DGYR_LOCUS12552-2
  144      |    CAJFCJ010000025.1  1909     2294     -           rna-DGYR_LOCUS12552-2
  PyRanges with 57 rows, 5 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.

On the other hand, we have local data, i.e. mapped to the transcript sequences that are annotated in the global ranges.
Below, we load some example data that we obtained by running the Rfam database of RNA motifs against the
transcript sequences in the ``gre`` object, using the software Infernal:

  >>> rh = pr.example_data.rfam_hits
  >>> rh = rh[ ['target_name', 'seq_from', 'seq_to', 'strand', 'query_name', 'mdl_from', 'mdl_to'] ]
  >>> rh.head() # doctest: +NORMALIZE_WHITESPACE
               target_name  seq_from  seq_to strand query_name  mdl_from  mdl_to
  0    rna-DGYR_LOCUS12552       267     311      +       GAIT         1      71
  1  rna-DGYR_LOCUS12552-2       288     332      +       GAIT         1      71
  2    rna-DGYR_LOCUS13738      1641    1678      +    REN-SRE         1      37
  3    rna-DGYR_LOCUS14091       137      43      -  IFN_gamma         1     169
  4    rna-DGYR_LOCUS14091       547     616      +     snoZ30         1      97


Above, the ``target_name`` column contains the transcript IDs, which are
the same as the ``ID`` column in the ``gre`` object. Then we have coordinates that define the alignment between
portions of those transcripts and one of the RNA motifs (query models) in the Rfam database.

Let's convert the ``rh`` object to a PyRanges object, taking care of switching from 1-based to 0-based coordinates:

  >>> rh = rh.rename(columns={'target_name':'Chromosome', 'seq_from':'Start', 'seq_to':'End', 'strand':'Strand'})
  >>> rh = pr.PyRanges(rh)
  >>> rh['Start'] -= 1  # convert to 0-based coordinates
  >>> rh
  index    |    Chromosome             Start    End      Strand    query_name    mdl_from    mdl_to
  int64    |    object                 int64    int64    object    object        int64       int64
  -------  ---  ---------------------  -------  -------  --------  ------------  ----------  --------
  0        |    rna-DGYR_LOCUS12552    266      311      +         GAIT          1           71
  1        |    rna-DGYR_LOCUS12552-2  287      332      +         GAIT          1           71
  2        |    rna-DGYR_LOCUS13738    1640     1678     +         REN-SRE       1           37
  3        |    rna-DGYR_LOCUS14091    136      43       -         IFN_gamma     1           169
  ...      |    ...                    ...      ...      ...       ...           ...         ...
  31       |    rna-DGYR_LOCUS13737    549      600      +         mir-3047      1           61
  32       |    rna-DGYR_LOCUS13737    543      605      +         mir-3156      1           77
  33       |    rna-DGYR_LOCUS13737    529      612      +         MIR1523       1           92
  34       |    rna-DGYR_LOCUS13737    549      600      +         MIR8001       1           67
  PyRanges with 35 rows, 7 columns, and 1 index columns.
  Contains 13 chromosomes and 2 strands.
  Invalid ranges:
    * 15 intervals are empty or negative length (end <= start). See indexes: 3, 5, 6, ...

Infernal, like other programs, reports negative stranded hits with Start and End reversed. Let's fix that:

  >>> rh.loc[ rh.Strand == '-', ['Start', 'End'] ] = rh.loc[ rh.Strand == '-', ['End', 'Start'] ].values
  >>> rh # doctest: +NORMALIZE_WHITESPACE
  index    |    Chromosome             Start    End      Strand    query_name    mdl_from    mdl_to
  int64    |    object                 int64    int64    object    object        int64       int64
  -------  ---  ---------------------  -------  -------  --------  ------------  ----------  --------
  0        |    rna-DGYR_LOCUS12552    266      311      +         GAIT          1           71
  1        |    rna-DGYR_LOCUS12552-2  287      332      +         GAIT          1           71
  2        |    rna-DGYR_LOCUS13738    1640     1678     +         REN-SRE       1           37
  3        |    rna-DGYR_LOCUS14091    43       136      -         IFN_gamma     1           169
  ...      |    ...                    ...      ...      ...       ...           ...         ...
  31       |    rna-DGYR_LOCUS13737    549      600      +         mir-3047      1           61
  32       |    rna-DGYR_LOCUS13737    543      605      +         mir-3156      1           77
  33       |    rna-DGYR_LOCUS13737    529      612      +         MIR1523       1           92
  34       |    rna-DGYR_LOCUS13737    549      600      +         MIR8001       1           67
  PyRanges with 35 rows, 7 columns, and 1 index columns.
  Contains 13 chromosomes and 2 strands.

Now we have the ``gre`` and ``rh`` objects, that represent global and local coordinate systems, respectively.
Let's check that all ``Chromosome`` values in ``rh`` matches the ``ID`` column in ``gre``:

  >>> bool( rh.Chromosome.isin(gre.Parent).all() )
  True

Mapping from local to global ranges
-----------------------------------

Next, we want to take the Rfam hits in ``rh``, which are relative (local) to the transcript sequences,
and remap them to the genome (global) coordinates. To do so, we make use of the information in the ``gre`` object,
which defines the coordinates of each transcript, often split in exons, relative to the genome.

For this operation, we use the :func:`map_to_global <pyranges.PyRanges.map_to_global>` method.
Besides the two PyRanges objects, we also need to specify the columns in the global range
that contains the identifier used as the Chromosome in the local range, provided by the ``global_on`` argument.
The resulting PyRanges object, ``rhg``, contains the Rfam hits remapped to the genome coordinates:

  >>> rhg = rh.map_to_global(gre, global_on='Parent')
  >>> rhg
  index    |    Chromosome         Start    End      Strand    query_name    mdl_from    mdl_to
  int64    |    category           int64    int64    object    object        int64       int64
  -------  ---  -----------------  -------  -------  --------  ------------  ----------  --------
  0        |    CAJFCJ010000025.1  2598     2643     -         GAIT          1           71
  1        |    CAJFCJ010000025.1  2598     2643     -         GAIT          1           71
  2        |    CAJFCJ010000053.1  77544    77582    +         REN-SRE       1           37
  3        |    CAJFCJ010000097.1  2291     2384     -         IFN_gamma     1           169
  ...      |    ...                ...      ...      ...       ...           ...         ...
  31       |    CAJFCJ010000053.1  39708    39759    +         mir-3047      1           61
  32       |    CAJFCJ010000053.1  39702    39764    +         mir-3156      1           77
  33       |    CAJFCJ010000053.1  39688    39771    +         MIR1523       1           92
  34       |    CAJFCJ010000053.1  39708    39759    +         MIR8001       1           67
  PyRanges with 38 rows, 7 columns, and 1 index columns (with 3 index duplicates).
  Contains 3 chromosomes and 2 strands.

Note that the transcript identifiers are now missing. To keep them, we can use the ``keep_id`` argument.
Analogously, we can record the local coordinates by using the ``keep_loc`` argument:

  >>> rh.map_to_global(gre, global_on='Parent', keep_id=True, keep_loc=True).drop(
  ...    columns=['query_name', 'mdl_from','mdl_to']) # dropping some columns to allow display
  index    |    Chromosome         Start    End      Strand    Parent                 Start_local    End_local    ...
  int64    |    category           int64    int64    object    object                 int64          int64        ...
  -------  ---  -----------------  -------  -------  --------  ---------------------  -------------  -----------  -----
  0        |    CAJFCJ010000025.1  2598     2643     -         rna-DGYR_LOCUS12552    266            311          ...
  1        |    CAJFCJ010000025.1  2598     2643     -         rna-DGYR_LOCUS12552-2  287            332          ...
  2        |    CAJFCJ010000053.1  77544    77582    +         rna-DGYR_LOCUS13738    1640           1678         ...
  3        |    CAJFCJ010000097.1  2291     2384     -         rna-DGYR_LOCUS14091    43             136          ...
  ...      |    ...                ...      ...      ...       ...                    ...            ...          ...
  31       |    CAJFCJ010000053.1  39708    39759    +         rna-DGYR_LOCUS13737    549            600          ...
  32       |    CAJFCJ010000053.1  39702    39764    +         rna-DGYR_LOCUS13737    543            605          ...
  33       |    CAJFCJ010000053.1  39688    39771    +         rna-DGYR_LOCUS13737    529            612          ...
  34       |    CAJFCJ010000053.1  39708    39759    +         rna-DGYR_LOCUS13737    549            600          ...
  PyRanges with 38 rows, 8 columns, and 1 index columns (with 3 index duplicates). (1 columns not shown: "Strand_local").
  Contains 3 chromosomes and 2 strands.

Let's now map intervals relative to **protein sequences** to genome coordinates.
First, we obtain the coding sequences (CDS) from the original GFF file, and translate them to protein sequences (see
:doc:`Working with sequences <./how_to_sequences>` for details):

  >>> grc = (gr[gr.Feature=='CDS']).get_with_loc_columns('ID')
  >>> genome_file = pr.example_data.files['ncbi.fasta']
  >>> cds_seq = grc.get_sequence(genome_file, group_by='ID').str.upper()
  >>> pep_seq = pr.seqs.translate(cds_seq)
  >>> pep_seq.head()
  ID
  cds-CAD5125114.1    MSRQSGRSNDPRKVSGELLTLTYGALVAQLVKDSESDDEVNKQLDK...
  cds-CAD5125115.1    MGYNIGIRLIEDFLARSSIGKCKDLRETAEIISKNGFKMFLNITPI...
  cds-CAD5126491.1    MAKNPEKMSATKKLETINRCMGHTKRGLENGCYTKGLIKIRCFTAE...
  cds-CAD5126492.1    MKIFAIISIYFILSESCYFRNVEVEGDFYLATFLAFHTDEYCTGPI...
  cds-CAD5126493.1    MNFYRNFFNLIFCIKVSSFSPIQDYISCQEALTKTEQDGSYSIKPR...
  Name: Sequence, dtype: object

As an example of a positional feature mapped to protein sequences, let's find all instances of the
amino acid 'K' (lysine):

  >>> aa='K'
  >>> z = [(seq_id, i, aa)   for seq_id, seq in pep_seq.items()   for i, char in enumerate(seq)  if char == aa]
  >>> z = pd.DataFrame(z, columns=['ID', 'Start', 'AminoAcid'])
  >>> z.head()
                   ID  Start AminoAcid
  0  cds-CAD5125114.1     12         K
  1  cds-CAD5125114.1     31         K
  2  cds-CAD5125114.1     41         K
  3  cds-CAD5125114.1     45         K
  4  cds-CAD5125114.1     66         K

Let's convert to a PyRanges object:
  >>> aa_pos = pr.PyRanges(z.rename(columns={'ID':'Chromosome'}).assign(End=lambda df: df.Start + 1 ))
  >>> aa_pos
  index    |    Chromosome        Start    AminoAcid    End
  int64    |    object            int64    object       int64
  -------  ---  ----------------  -------  -----------  -------
  0        |    cds-CAD5125114.1  12       K            13
  1        |    cds-CAD5125114.1  31       K            32
  2        |    cds-CAD5125114.1  41       K            42
  3        |    cds-CAD5125114.1  45       K            46
  ...      |    ...               ...      ...          ...
  457      |    cds-CAD5126878.1  334      K            335
  458      |    cds-CAD5126878.1  341      K            342
  459      |    cds-CAD5126878.1  342      K            343
  460      |    cds-CAD5126878.1  350      K            351
  PyRanges with 461 rows, 4 columns, and 1 index columns.
  Contains 17 chromosomes.

Next, we have to convert protein-based positions to nucleotide-based positions, still relative to the CDS.
Because they're in pythonic 0-based coordinates, we just need to multiply by 3:

  >>> cds_pos = aa_pos.copy()
  >>> cds_pos['Start'] *= 3
  >>> cds_pos['End'] *= 3

Now we're ready to map these positions to the genome coordinates. Let's also fetch their underlying nucleotide sequence:

  >>> genome_pos = cds_pos.map_to_global(grc, global_on='ID', keep_id=True)
  >>> genome_pos['Sequence'] = genome_pos.get_sequence(genome_file).str.upper()
  >>> genome_pos
  index    |    Chromosome         Start    AminoAcid    End      ID                Strand      Sequence
  int64    |    category           int64    object       int64    object            category    object
  -------  ---  -----------------  -------  -----------  -------  ----------------  ----------  ----------
  0        |    CAJFCJ010000025.1  3114     K            3117     cds-CAD5125114.1  -           AAA
  1        |    CAJFCJ010000025.1  2797     K            2800     cds-CAD5125114.1  -           AAG
  2        |    CAJFCJ010000025.1  2767     K            2770     cds-CAD5125114.1  -           AAA
  3        |    CAJFCJ010000025.1  2755     K            2758     cds-CAD5125114.1  -           AAA
  ...      |    ...                ...      ...          ...      ...               ...         ...
  457      |    CAJFCJ010000097.1  53008    K            53011    cds-CAD5126878.1  +           AAG
  458      |    CAJFCJ010000097.1  53341    K            53344    cds-CAD5126878.1  +           AAA
  459      |    CAJFCJ010000097.1  53344    K            53347    cds-CAD5126878.1  +           AAA
  460      |    CAJFCJ010000097.1  53368    K            53371    cds-CAD5126878.1  +           AAA
  PyRanges with 466 rows, 7 columns, and 1 index columns (with 5 index duplicates).
  Contains 3 chromosomes and 2 strands.

Because protein mapping to genome coordinates is common, map_to_:func:`map_to_global <pyranges.PyRanges.map_to_global>`
provides a shortcut for this operation, through its ``pep_to_cds`` argument, which effectively multiplies the local
coordinates by 3 before mapping to the global coordinates. So this is equivalent to the previous operation:

  >>> aa_pos.map_to_global(grc, global_on='ID', keep_id=True, pep_to_cds=True)
  index    |    Chromosome         Start    AminoAcid    End      ID                Strand
  int64    |    category           int64    object       int64    object            category
  -------  ---  -----------------  -------  -----------  -------  ----------------  ----------
  0        |    CAJFCJ010000025.1  3114     K            3117     cds-CAD5125114.1  -
  1        |    CAJFCJ010000025.1  2797     K            2800     cds-CAD5125114.1  -
  2        |    CAJFCJ010000025.1  2767     K            2770     cds-CAD5125114.1  -
  3        |    CAJFCJ010000025.1  2755     K            2758     cds-CAD5125114.1  -
  ...      |    ...                ...      ...          ...      ...               ...
  457      |    CAJFCJ010000097.1  53008    K            53011    cds-CAD5126878.1  +
  458      |    CAJFCJ010000097.1  53341    K            53344    cds-CAD5126878.1  +
  459      |    CAJFCJ010000097.1  53344    K            53347    cds-CAD5126878.1  +
  460      |    CAJFCJ010000097.1  53368    K            53371    cds-CAD5126878.1  +
  PyRanges with 466 rows, 6 columns, and 1 index columns (with 5 index duplicates).
  Contains 3 chromosomes and 2 strands.

In the genetic code, the codons for lysine are 'AAA' or 'AAG', which fits what we see.
One last important observation: note the warning above about **index duplicates**. Let's take a look at them:

  >>> genome_pos[genome_pos.index.duplicated(keep=False)]
  index    |    Chromosome         Start    AminoAcid    End      ID                Strand      Sequence
  int64    |    category           int64    object       int64    object            category    object
  -------  ---  -----------------  -------  -----------  -------  ----------------  ----------  ----------
  234      |    CAJFCJ010000053.1  77393    K            77395    cds-CAD5126496.1  +           AA
  234      |    CAJFCJ010000053.1  77458    K            77459    cds-CAD5126496.1  +           G
  282      |    CAJFCJ010000053.1  89719    K            89721    cds-CAD5126498.1  -           AA
  282      |    CAJFCJ010000053.1  89660    K            89661    cds-CAD5126498.1  -           G
  ...      |    ...                ...      ...          ...      ...               ...         ...
  422      |    CAJFCJ010000097.1  52381    K            52382    cds-CAD5126877.1  +           A
  422      |    CAJFCJ010000097.1  52446    K            52448    cds-CAD5126877.1  +           AG
  446      |    CAJFCJ010000097.1  52381    K            52382    cds-CAD5126878.1  +           A
  446      |    CAJFCJ010000097.1  52446    K            52448    cds-CAD5126878.1  +           AG
  PyRanges with 10 rows, 7 columns, and 1 index columns (with 5 index duplicates).
  Contains 2 chromosomes and 2 strands.


This is because the codon for some amino acids are split between two exons.
In more general terms, this is an effect of mapping local features to a global coordinate system: if
entities (e.g. CDS) encompasses multiple non-contiguous intervals in the global coordinate system (e.g. exons), a
certain local feature (e.g. amino acid) may also be mapped into split intervals in global coordinates.
These are identified by the index duplicates in the PyRanges object, as above.

Mapping from global to local ranges
-----------------------------------

Another task is to map from global to local ranges, which is the opposite of the previous task.
This is useful when we put together data generated at different levels. For example, we may have
genomic features predicted using the full genome, and we want to see where they reside in transcripts.
In this example, we will map the sequence 'AATAAA', which is a polyadenylation signal motif, in genome sequences, then
map them to transcript coordinates.

  >>> pattern='AATAAA'

Let's remind ourselves of the ``gre`` object, which contains the transcript coordinates:

  >>> gre
  index    |    Chromosome         Start    End      Strand      Parent
  int64    |    category           int64    int64    category    object
  -------  ---  -----------------  -------  -------  ----------  ---------------------
  3        |    CAJFCJ010000053.1  4882     5264     -           rna-DGYR_LOCUS13733
  7        |    CAJFCJ010000053.1  10474    10958    +           rna-DGYR_LOCUS13734
  8        |    CAJFCJ010000053.1  11028    11169    +           rna-DGYR_LOCUS13734
  9        |    CAJFCJ010000053.1  11227    11400    +           rna-DGYR_LOCUS13734
  ...      |    ...                ...      ...      ...         ...
  141      |    CAJFCJ010000025.1  2753     2851     -           rna-DGYR_LOCUS12552-2
  142      |    CAJFCJ010000025.1  2593     2693     -           rna-DGYR_LOCUS12552-2
  143      |    CAJFCJ010000025.1  2354     2537     -           rna-DGYR_LOCUS12552-2
  144      |    CAJFCJ010000025.1  1909     2294     -           rna-DGYR_LOCUS12552-2
  PyRanges with 57 rows, 5 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.

Let's get the lengths of all these chromosomes from the genome:

  >>> import pyfaidx
  >>> pyf = pyfaidx.Fasta(genome_file)
  >>> chromsizes = {chrom: len(pyf[chrom]) for chrom in gre.chromosomes}
  >>> chromsizes
  {'CAJFCJ010000025.1': 3418, 'CAJFCJ010000053.1': 109277, 'CAJFCJ010000097.1': 78757}


Let's now create a PyRanges object than spans their whole sequence, with two intervals per chromosome: one for plus
strand and one for minus strand; and let's load their sequence in memory:

  >>> q = [(chrom, 0, chromsizes[chrom], '+')  for chrom in chromsizes] + [(chrom, 0, chromsizes[chrom], '-') for chrom in chromsizes]
  >>> q
  [('CAJFCJ010000025.1', 0, 3418, '+'), ('CAJFCJ010000053.1', 0, 109277, '+'), ('CAJFCJ010000097.1', 0, 78757, '+'), ('CAJFCJ010000025.1', 0, 3418, '-'), ('CAJFCJ010000053.1', 0, 109277, '-'), ('CAJFCJ010000097.1', 0, 78757, '-')]

  >>> full_seq = pr.PyRanges( pd.DataFrame(q, columns=['Chromosome', 'Start', 'End', 'Strand']))
  >>> full_seq['Sequence'] = full_seq.get_sequence(genome_file).str.upper()

  >>> matches = []
  >>> for i in full_seq.itertuples():
  ...    st=0
  ...    while (pos_match:= i.Sequence.find(pattern, st)) != -1:
  ...        pat_st, pat_end = pos_match, pos_match+len(pattern)
  ...        if i.Strand == '-':
  ...          pat_st, pat_end = i.End - (pos_match + len(pattern)), i.End - pos_match
  ...        matches.append( (i.Chromosome, pat_st, pat_end, i.Strand) )
  ...        st=pos_match+1
  >>> matches = pr.PyRanges( pd.DataFrame(matches, columns=['Chromosome', 'Start', 'End', 'Strand']))
  >>> matches['Sequence'] = matches.get_sequence(genome_file).str.upper() # fetch seq as control
  >>> matches
  index    |    Chromosome         Start    End      Strand    Sequence
  int64    |    object             int64    int64    object    object
  -------  ---  -----------------  -------  -------  --------  ----------
  0        |    CAJFCJ010000025.1  81       87       +         AATAAA
  1        |    CAJFCJ010000025.1  90       96       +         AATAAA
  2        |    CAJFCJ010000025.1  347      353      +         AATAAA
  3        |    CAJFCJ010000025.1  553      559      +         AATAAA
  ...      |    ...                ...      ...      ...       ...
  619      |    CAJFCJ010000097.1  2513     2519     -         AATAAA
  620      |    CAJFCJ010000097.1  2284     2290     -         AATAAA
  621      |    CAJFCJ010000097.1  2163     2169     -         AATAAA
  622      |    CAJFCJ010000097.1  858      864      -         AATAAA
  PyRanges with 623 rows, 5 columns, and 1 index columns.
  Contains 3 chromosomes and 2 strands.

The object ``matches`` contains the positions of the motif in the genome.
Now, we want to map these positions to the transcript coordinates. Function
:func:`map_to_local <pyranges.PyRanges.map_to_local>` does exactly this.
For each motif, we need to decide which transcript we want to use as reference
coordinate system. By default, it will use all transcripts that overlap the motif:

  >>> gre_matches = matches.map_to_local(gre, ref_on='Parent')
  >>> gre_matches
  index    |    Chromosome           Start    End      Strand    Sequence
  int64    |    object               int64    int64    object    object
  -------  ---  -------------------  -------  -------  --------  ----------
  28       |    rna-DGYR_LOCUS13734  1142     1148     +         AATAAA
  29       |    rna-DGYR_LOCUS13734  1416     1422     +         AATAAA
  30       |    rna-DGYR_LOCUS13734  2106     2112     +         AATAAA
  31       |    rna-DGYR_LOCUS13734  2232     2238     +         AATAAA
  ...      |    ...                  ...      ...      ...       ...
  617      |    rna-DGYR_LOCUS14091  980      986      -         AATAAA
  618      |    rna-DGYR_LOCUS14091  774      780      -         AATAAA
  619      |    rna-DGYR_LOCUS14091  265      271      -         AATAAA
  620      |    rna-DGYR_LOCUS14091  36       42       -         AATAAA
  PyRanges with 59 rows, 5 columns, and 1 index columns (with 2 index duplicates).
  Contains 14 chromosomes and 2 strands.

√•As before, you have options to retain metadata, in this case from the global ranges:

  >>> matches.map_to_local(gre, ref_on='Parent', keep_chrom=True, keep_loc=True).columns
  Index(['Chromosome', 'Start', 'End', 'Strand', 'Sequence', 'Chromosome_global',
         'Start_global', 'End_global', 'Strand_global'],
        dtype='object')


Let's look at another use case.
For example, we way have CDS and exon coordinates, and we want to map the CDS coordinates to the exon coordinates.
In other words, we want to know where CDS intervals reside along the full mRNA transcripts.

Let's inspect some data inside the ``gr`` object, focusing on a single identifier:

  >>> pr.options.set_option('max_rows_to_show', 20)
  >>> some_id = 'rna-DGYR_LOCUS12552-2'
  >>> gr[gr.Parent == some_id].get_with_loc_columns(['Feature', 'Parent'])
    index  |    Chromosome           Start      End  Strand      Feature     Parent
    int64  |    category             int64    int64  category    category    object
  -------  ---  -----------------  -------  -------  ----------  ----------  ---------------------
      140  |    CAJFCJ010000025.1     3111     3250  -           exon        rna-DGYR_LOCUS12552-2
      141  |    CAJFCJ010000025.1     2753     2851  -           exon        rna-DGYR_LOCUS12552-2
      142  |    CAJFCJ010000025.1     2593     2693  -           exon        rna-DGYR_LOCUS12552-2
      143  |    CAJFCJ010000025.1     2354     2537  -           exon        rna-DGYR_LOCUS12552-2
      144  |    CAJFCJ010000025.1     1909     2294  -           exon        rna-DGYR_LOCUS12552-2
      145  |    CAJFCJ010000025.1     3111     3153  -           CDS         rna-DGYR_LOCUS12552-2
      146  |    CAJFCJ010000025.1     2753     2851  -           CDS         rna-DGYR_LOCUS12552-2
      147  |    CAJFCJ010000025.1     2593     2693  -           CDS         rna-DGYR_LOCUS12552-2
      148  |    CAJFCJ010000025.1     2354     2537  -           CDS         rna-DGYR_LOCUS12552-2
      149  |    CAJFCJ010000025.1     2174     2294  -           CDS         rna-DGYR_LOCUS12552-2
  PyRanges with 10 rows, 6 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

You can see that CDS and exon belonging to the same transcript have the same ``Parent`` value.
Therefore, we can easily map the CDS coordinates to the exon coordinates of the corresponding transcript,
by pairing (overlapping) CDS and exon intervals with the same ``Parent`` value:

  >>> pr.options.reset_options()
  >>> cds = gr[gr.Feature == 'CDS'].get_with_loc_columns(['Feature', 'Parent'])
  >>> exons = gr[gr.Feature == 'exon'].get_with_loc_columns(['Feature', 'Parent'])
  >>> cds_local = cds.map_to_local(exons, ref_on='Parent', match_by='Parent')
  >>> cds_local
  index    |    Chromosome             Start    End      Strand    Feature
  int64    |    object                 int64    int64    object    category
  -------  ---  ---------------------  -------  -------  --------  ----------
  0        |    rna-DGYR_LOCUS13733    1        382      +         CDS
  1        |    rna-DGYR_LOCUS13734    258      484      +         CDS
  2        |    rna-DGYR_LOCUS13734    484      625      +         CDS
  3        |    rna-DGYR_LOCUS13734    625      798      +         CDS
  ...      |    ...                    ...      ...      ...       ...
  52       |    rna-DGYR_LOCUS12552-2  139      237      +         CDS
  53       |    rna-DGYR_LOCUS12552-2  237      337      +         CDS
  54       |    rna-DGYR_LOCUS12552-2  337      520      +         CDS
  55       |    rna-DGYR_LOCUS12552-2  520      640      +         CDS
  PyRanges with 56 rows, 5 columns, and 1 index columns.
  Contains 17 chromosomes and 1 strands.

  >>> cds_local[cds_local.Chromosome == some_id]
    index  |    Chromosome               Start      End  Strand    Feature
    int64  |    object                   int64    int64  object    category
  -------  ---  ---------------------  -------  -------  --------  ----------
       51  |    rna-DGYR_LOCUS12552-2       97      139  +         CDS
       52  |    rna-DGYR_LOCUS12552-2      139      237  +         CDS
       53  |    rna-DGYR_LOCUS12552-2      237      337  +         CDS
       54  |    rna-DGYR_LOCUS12552-2      337      520  +         CDS
       55  |    rna-DGYR_LOCUS12552-2      520      640  +         CDS
  PyRanges with 5 rows, 5 columns, and 1 index columns.
  Contains 1 chromosomes and 1 strands.

With the similar logic, we can easily map the start and stop codon positions to the exon coordinates:

  >>> cds.slice_ranges(0, 3).assign(Feature='start').map_to_local(exons, ref_on='Parent', match_by='Parent')
  index    |    Chromosome             Start    End      Strand    Feature
  int64    |    object                 int64    int64    object    object
  -------  ---  ---------------------  -------  -------  --------  ---------
  0        |    rna-DGYR_LOCUS13733    1        4        +         start
  1        |    rna-DGYR_LOCUS13734    258      261      +         start
  2        |    rna-DGYR_LOCUS13734    484      487      +         start
  3        |    rna-DGYR_LOCUS13734    625      628      +         start
  ...      |    ...                    ...      ...      ...       ...
  52       |    rna-DGYR_LOCUS12552-2  139      142      +         start
  53       |    rna-DGYR_LOCUS12552-2  237      240      +         start
  54       |    rna-DGYR_LOCUS12552-2  337      340      +         start
  55       |    rna-DGYR_LOCUS12552-2  520      523      +         start
  PyRanges with 56 rows, 5 columns, and 1 index columns.
  Contains 17 chromosomes and 1 strands.

  >>> cds.slice_ranges(-3).assign(Feature='stop').map_to_local(exons, ref_on='Parent', match_by='Parent')
  index    |    Chromosome             Start    End      Strand    Feature
  int64    |    object                 int64    int64    object    object
  -------  ---  ---------------------  -------  -------  --------  ---------
  0        |    rna-DGYR_LOCUS13733    379      382      +         stop
  1        |    rna-DGYR_LOCUS13734    481      484      +         stop
  2        |    rna-DGYR_LOCUS13734    622      625      +         stop
  3        |    rna-DGYR_LOCUS13734    795      798      +         stop
  ...      |    ...                    ...      ...      ...       ...
  52       |    rna-DGYR_LOCUS12552-2  234      237      +         stop
  53       |    rna-DGYR_LOCUS12552-2  334      337      +         stop
  54       |    rna-DGYR_LOCUS12552-2  517      520      +         stop
  55       |    rna-DGYR_LOCUS12552-2  637      640      +         stop
  PyRanges with 56 rows, 5 columns, and 1 index columns.
  Contains 17 chromosomes and 1 strands.


.. *** docs/_templates/custom_method_summary.rst ***

{{ fullname | escape | underline }}

.. currentmodule:: {{ module }}

.. automethod:: {{ objname }}



====================
Public API docstrings
====================

####################################################################################################
class pyranges.core.pyranges_main.PyRanges
##########################################
Two-dimensional representation of genomic intervals and their annotations.

A PyRanges object must have the columns Chromosome, Start and End. A Strand
column is optional and adds strand information to the intervals. Any other
columns are allowed and are considered metadata.

You can **initialize a PyRanges object like you would a pandas DataFrame**, as long as the resulting DataFrame
has the necessary columns (Chromosome, Start, End; Strand is optional).
See examples below, and https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html for more information.

Parameters
----------
data : dict, pd.DataFrame, or None, default None

index : Index or array-like

columns : Index or array-like

dtype : type, default None

copy : bool or None, default None


See Also
--------
pyranges.read_bed: read bed-file into PyRanges
pyranges.read_bam: read bam-file into PyRanges
pyranges.read_gff: read gff-file into PyRanges
pyranges.read_gtf: read gtf-file into PyRanges


Examples
--------
>>> pr.PyRanges()
index    |    Chromosome    Start      End
int64    |    float64       float64    float64
-------  ---  ------------  ---------  ---------
PyRanges with 0 rows, 3 columns, and 1 index columns.
Contains 0 chromosomes.

You can initiatize PyRanges with a DataFrame:

>>> df = pd.DataFrame({"Chromosome": ["chr1", "chr2"], "Start": [100, 200],
...                    "End": [150, 201]})
>>> df
  Chromosome  Start  End
0       chr1    100  150
1       chr2    200  201
>>> pr.PyRanges(df)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1              100      150
      1  |    chr2              200      201
PyRanges with 2 rows, 3 columns, and 1 index columns.
Contains 2 chromosomes.

Or you can use a dictionary of iterables:

>>> gr = pr.PyRanges({"Chromosome": [1, 1], "Strand": ["+", "-"], "Start": [1, 4], "End": [2, 27],
...                    "TP": [0, 1], "FP": [12, 11], "TN": [10, 9], "FN": [2, 3]})
>>> gr
  index  |      Chromosome  Strand      Start      End       TP       FP       TN       FN
  int64  |           int64  object      int64    int64    int64    int64    int64    int64
-------  ---  ------------  --------  -------  -------  -------  -------  -------  -------
      0  |               1  +               1        2        0       12       10        2
      1  |               1  -               4       27        1       11        9        3
PyRanges with 2 rows, 8 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Operations that remove a column required for a PyRanges return a DataFrame instead:

>>> gr.drop("Chromosome", axis=1)
  Strand  Start  End  TP  FP  TN  FN
0      +      1    2   0  12  10   2
1      -      4   27   1  11   9   3

>>> pr.PyRanges(dict(Chromosome=["chr1", "chr2"], Start=[1, 2], End=[2, 3]))
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                1        2
      1  |    chr2                2        3
PyRanges with 2 rows, 3 columns, and 1 index columns.
Contains 2 chromosomes.


####################################################################################################
PyRanges.clip_ranges()
######################
Clip or remove intervals outside of sequence (e.g. Chromosome) bounds.

Parameters
----------
chromsizes : dict or PyRanges or pyfaidx.Fasta or None, default None
    Dict or PyRanges describing the lengths of the sequences (the "Chromosomes" in the self object).
    pyfaidx.Fasta object is also accepted since it conveniently loads chromosome length.
    If None, clipping is only on the left, i.e. for the portions of intervals that are negative (Start < 0).

remove : bool, default False
    Drops intervals entirely if they are even partially out of bounds, instead of clipping them

only_right : bool, default False
    If True, remove or clip only intervals that are out-of-bounds on the right,
    and do not alter those out-of-bounds on the left (whose Start is < 0)


Examples
--------
>>> import pyranges as pr
>>> d = {"Chromosome": [1, 1, 3], "Start": [1, 249250600, 5], "End": [2, 249250640, 7]}
>>> gr = pr.PyRanges(d)
>>> gr
  index  |      Chromosome      Start        End
  int64  |           int64      int64      int64
-------  ---  ------------  ---------  ---------
      0  |               1          1          2
      1  |               1  249250600  249250640
      2  |               3          5          7
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 2 chromosomes.

>>> chromsizes = {1: 249250621, 3: 500}
>>> chromsizes
{1: 249250621, 3: 500}

>>> gr.clip_ranges(chromsizes)
  index  |      Chromosome      Start        End
  int64  |           int64      int64      int64
-------  ---  ------------  ---------  ---------
      0  |               1          1          2
      1  |               1  249250600  249250621
      2  |               3          5          7
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 2 chromosomes.

>>> gr.clip_ranges(chromsizes, remove=True)
  index  |      Chromosome    Start      End
  int64  |           int64    int64    int64
-------  ---  ------------  -------  -------
      0  |               1        1        2
      2  |               3        5        7
PyRanges with 2 rows, 3 columns, and 1 index columns.
Contains 2 chromosomes.

>>> del chromsizes[3]
>>> chromsizes
{1: 249250621}

>>> gr.clip_ranges(chromsizes)
Traceback (most recent call last):
...
ValueError: Not all chromosomes were in the chromsize dict.
Missing keys: {3}.

>>> w = pr.PyRanges({"Chromosome": [1, 1, 1], "Start": [-10, 249250600, 100], "End": [2, 249250640, 150]})
>>> w
  index  |      Chromosome      Start        End
  int64  |           int64      int64      int64
-------  ---  ------------  ---------  ---------
      0  |               1        -10          2
      1  |               1  249250600  249250640
      2  |               1        100        150
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.
Invalid ranges:
  * 1 starts or ends are < 0. See indexes: 0

>>> w.clip_ranges()
  index  |      Chromosome      Start        End
  int64  |           int64      int64      int64
-------  ---  ------------  ---------  ---------
      0  |               1          0          2
      1  |               1  249250600  249250640
      2  |               1        100        150
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> w.clip_ranges({1:249250620}, only_right=True)
  index  |      Chromosome      Start        End
  int64  |           int64      int64      int64
-------  ---  ------------  ---------  ---------
      0  |               1        -10          2
      1  |               1  249250600  249250620
      2  |               1        100        150
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.
Invalid ranges:
  * 1 starts or ends are < 0. See indexes: 0


####################################################################################################
PyRanges.cluster_overlaps()
###########################
Give overlapping intervals a common id.

Parameters
----------
use_strand: {"auto", True, False}, default: "auto"
    Whether to cluster only intervals on the same strand.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

slack : int, default 0
    Length by which the criteria of overlap are loosened.
    A value of 1 clusters also bookended intervals.
    Higher slack values cluster more distant intervals (with a maximum distance of slack-1 between them).

cluster_column:
    Name the cluster column added in output. Default: "Cluster"

Returns
-------
PyRanges
    PyRanges with an ID-column "Cluster" added.

See Also
--------
PyRanges.merge: combine overlapping intervals into one

Examples
--------
>>> gr = pr.PyRanges(dict(Chromosome=1, Start=[5, 6, 12, 16, 20, 22, 24], End=[9, 8, 16, 18, 23, 25, 27]))
>>> gr
  index  |      Chromosome    Start      End
  int64  |           int64    int64    int64
-------  ---  ------------  -------  -------
      0  |               1        5        9
      1  |               1        6        8
      2  |               1       12       16
      3  |               1       16       18
      4  |               1       20       23
      5  |               1       22       25
      6  |               1       24       27
PyRanges with 7 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.cluster_overlaps()
  index  |      Chromosome    Start      End    Cluster
  int64  |           int64    int64    int64     uint32
-------  ---  ------------  -------  -------  ---------
      0  |               1        5        9          0
      1  |               1        6        8          0
      2  |               1       12       16          1
      3  |               1       16       18          2
      4  |               1       20       23          3
      5  |               1       22       25          3
      6  |               1       24       27          3
PyRanges with 7 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

Slack=1 will cluster also bookended intervals:

>>> gr.cluster_overlaps(slack=1)
  index  |      Chromosome    Start      End    Cluster
  int64  |           int64    int64    int64     uint32
-------  ---  ------------  -------  -------  ---------
      0  |               1        5        9          0
      1  |               1        6        8          0
      2  |               1       12       16          1
      3  |               1       16       18          1
      4  |               1       20       23          2
      5  |               1       22       25          2
      6  |               1       24       27          2
PyRanges with 7 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

Higher values of slack will cluster more distant intervals:

>>> gr.cluster_overlaps(slack=3)
  index  |      Chromosome    Start      End    Cluster
  int64  |           int64    int64    int64     uint32
-------  ---  ------------  -------  -------  ---------
      0  |               1        5        9          0
      1  |               1        6        8          0
      2  |               1       12       16          1
      3  |               1       16       18          1
      4  |               1       20       23          1
      5  |               1       22       25          1
      6  |               1       24       27          1
PyRanges with 7 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.combine_interval_columns()
###################################
Use two pairs of columns representing intervals to create a new start and end column.

The function is designed as post-processing after join_overlaps to aggregate the coordinates of the two intervals.
By default, the new start and end columns will be the intersection of the intervals.

Parameters
----------
function : {"intersect", "union", "swap"} or Callable, default "intersect"
    How to combine the self and other intervals: "intersect", "union", or "swap"
    If a callable is passed, it should take four Series arguments: start1, end1, start2, end2;
    and return a tuple of two integers: (new_starts, new_ends).

start : str, default "Start"
    Column name for Start of first interval
end : str, default "End"
    Column name for End of first interval
start2 : str, default "Start_b"
    Column name for Start of second interval
end2 : str, default "End_b"
    Column name for End of second interval
drop_old_columns : bool, default True
    Whether to drop the above mentioned columns.

Examples
--------
>>> gr1 = pr.example_data.aorta.head(3).remove_nonloc_columns()
>>> gr1
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1             9916    10115  -
      1  |    chr1             9939    10138  +
      2  |    chr1             9951    10150  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr2 = pr.example_data.aorta2.head(3).remove_nonloc_columns()
>>> gr2
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1             9988    10187  -
      1  |    chr1            10073    10272  +
      2  |    chr1            10079    10278  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> j = gr1.join_overlaps(gr2)
>>> j
  index  |    Chromosome      Start      End  Strand        Start_b    End_b
  int64  |    category        int64    int64  category        int64    int64
-------  ---  ------------  -------  -------  ----------  ---------  -------
      0  |    chr1             9916    10115  -                9988    10187
      0  |    chr1             9916    10115  -               10079    10278
      1  |    chr1             9939    10138  +               10073    10272
      2  |    chr1             9951    10150  -                9988    10187
      2  |    chr1             9951    10150  -               10079    10278
PyRanges with 5 rows, 6 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes and 2 strands.

Combine the interval coordinates in different ways:

>>> j.combine_interval_columns()        # default: "intersect"
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1             9988    10115  -
      0  |    chr1            10079    10115  -
      1  |    chr1            10073    10138  +
      2  |    chr1             9988    10150  -
      2  |    chr1            10079    10150  -
PyRanges with 5 rows, 4 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> j.combine_interval_columns("union")
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1             9916    10187  -
      0  |    chr1             9916    10278  -
      1  |    chr1             9939    10272  +
      2  |    chr1             9951    10187  -
      2  |    chr1             9951    10278  -
PyRanges with 5 rows, 4 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> j.combine_interval_columns("swap")
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1             9988    10187  -
      0  |    chr1            10079    10278  -
      1  |    chr1            10073    10272  +
      2  |    chr1             9988    10187  -
      2  |    chr1            10079    10278  -
PyRanges with 5 rows, 4 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> def custom_combine(s1, e1, s2, e2):   # keep Start from first, End from second
...     return (s1, e2)
>>> j.combine_interval_columns(custom_combine)
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1             9916    10187  -
      0  |    chr1             9916    10278  -
      1  |    chr1             9939    10272  +
      2  |    chr1             9951    10187  -
      2  |    chr1             9951    10278  -
PyRanges with 5 rows, 4 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.complement_ranges()
############################
Return the internal complement of the intervals, i.e. its introns.

The complement of an interval is the set of intervals that are not covered by the original interval.
This function is useful for obtaining the introns of a set of exons, corresponding to the
"internal" complement, i.e. excluding the first and last portion of each chromosome not covered by intervals.

Parameters
----------
group_by : str or list, optional
    Column(s) to group intervals (e.g. exons into transcripts).
    If provided, the complement will be calculated separately for each group.
use_strand : {"auto", True, False}, default "auto"
    Whether to return complement intervals separately for those on the positive and negative strands.
    The default "auto" means that strand information is used if present and valid (see .strand_valid).
include_first_interval : bool, default False
    If True, include the external complement interval at the beginning of the chromosome (or group),
    i.e. the interval from the start of the chromosome up to the first interval.
group_sizes_col : str, default CHROM_COL
    The column name used to match keys in the ``chromsizes`` mapping. This determines the total size
    of each chromosome (or group) when calculating external complement intervals.
chromsizes : dict[str | int, int] or None, optional
    If provided, external complement intervals will also be returned, i.e. the intervals corresponding to the
    beginning of the chromosome up to the first interval and from the last interval to the end of the chromosome.
    The dictionary should map chromosome (or group) identifiers to their total sizes. A PyRanges or pyfaidx.Fasta
    object is also accepted since it conveniently loads chromosome lengths.

Notes
-----
* To ensure non-overlap among the input intervals, merge_overlaps is run before the complement is calculated.
* Bookended intervals will result in no complement intervals returned since they would be of length 0.

See Also
--------
PyRanges.subtract_overlaps : report non-overlapping subintervals
PyRanges.outer_ranges : report the boundaries of groups of intervals (e.g. transcripts/genes)


Examples
--------
>>> a = pr.PyRanges(dict(Chromosome="chr1", Start=[2, 10, 20, 40], End=[5, 18, 30, 46], ID=['a', 'a', 'b', 'b']))
>>> a
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                2        5  a
      1  |    chr1               10       18  a
      2  |    chr1               20       30  b
      3  |    chr1               40       46  b
PyRanges with 4 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> a.complement_ranges('ID', group_sizes_col="ID", chromsizes={"a": 22, "b": 100}, include_first_interval=True)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                0        2  a
      1  |    chr1                5       10  a
      2  |    chr1               18       22  a
      3  |    chr1                0       20  b
      4  |    chr1               30       40  b
      5  |    chr1               46      100  b
PyRanges with 6 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

Get complement of the whole set of intervals, without grouping:

Using complement to get introns:

>>> a.complement_ranges('ID')
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                5       10  a
      1  |    chr1               30       40  b
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> a.complement_ranges()
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                5       10
      1  |    chr1               18       20
      2  |    chr1               30       40
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

Include external intervals:

>>> a.complement_ranges(chromsizes={'chr1': 10000}, include_first_interval=True)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                0        2
      1  |    chr1                5       10
      2  |    chr1               18       20
      3  |    chr1               30       40
      4  |    chr1               46    10000
PyRanges with 5 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> a.complement_ranges('ID', chromsizes={'chr1': 10000}, include_first_interval=True)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                0        2  a
      1  |    chr1                5       10  a
      2  |    chr1               18    10000  a
      3  |    chr1                0       20  b
      4  |    chr1               30       40  b
      5  |    chr1               46    10000  b
PyRanges with 6 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

For complement of whole sets of intervals, you can explicitly use_strand or not:

>>> b = pr.PyRanges(dict(Chromosome="chr1", Start=[1, 10, 20, 40], End=[5, 18, 30, 46],
...                      Strand=['+', '+', '-', '-']))
>>> b
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        5  +
      1  |    chr1               10       18  +
      2  |    chr1               20       30  -
      3  |    chr1               40       46  -
PyRanges with 4 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> b.complement_ranges(use_strand=True)  # same as b.complement_ranges() because b.strand_valid == True
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                5       10  +
      1  |    chr1               30       40  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> b.complement_ranges(use_strand=False)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                5       10
      1  |    chr1               18       20
      2  |    chr1               30       40
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> b.complement_ranges(use_strand=False, chromsizes={'chr1': 10000}, include_first_interval=True)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                0        1
      1  |    chr1                5       10
      2  |    chr1               18       20
      3  |    chr1               30       40
      4  |    chr1               46    10000
PyRanges with 5 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

Bookended intervals (indices 0-1 below) and overlapping intervals (2-3) won't return any in-between intervals:

>>> c = pr.PyRanges(dict(Chromosome="chr1", Start=[1, 5, 8, 10], End=[5, 7, 14, 16]))
>>> c.complement_ranges()
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                7        8
PyRanges with 1 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.compute_interval_metrics()
###################################
Attach interval-relationship metrics as new columns.

Parameters
----------
metrics
    One of the following forms:
      * single string, eg "length"
      * iterable of strings, eg ["fraction", "jaccard"]
      * mapping {metric_name -> new_column_name} to rename on the fly
    Accepted metric names are listed in VALID_METRICS.
denom
    Denominator for the *fraction* metric.  Must be "first", "second" or "union".
start, end : str, default START_COL / END_COL
    Column names holding the first interval coordinates.
start2, end2 : str, default START_COL + "_b" / END_COL + "_b"
    Column names holding the second interval coordinates.
denom : {"first", "second", "union"}, default "first"
    Denominator used by the *fraction* metric.

Returns
-------
RangeFrame
    Copy of self with extra metric columns.

Metrics
-------
overlap_length
    Raw number of overlapping bases.

fraction
    Overlap divided by a denominator chosen with *denom*
    ("first", "second", or "union").

jaccard
    Overlap divided by the union length of the two intervals.

distance
    Positive gap in bases when intervals do not touch;
    0 when they overlap or abut.

overlap
    Boolean flag - True if at least one base overlaps.

signed_distance
    Same as *distance* but signed:
    negative when the second interval is upstream of the first,
    positive when downstream, 0 when touching/overlapping.

midpoint_distance
    Absolute distance between interval midpoints.

symmetric_coverage
    2 * overlap √∑ (length1 + length2).  Ranges from 0 to 1.

relative_direction
    For frames that contain "Strand" and "Strand_b":
    "same" if strands match, "opposite" if they differ,
    "unknown" if either strand is "." or missing.

Examples
--------
>>> import pyranges as pr
>>> df = pd.DataFrame(
...     {
...         "Chromosome": ["chr1"] * 5,
...         "Start":      [2, 10, 20, 40, 80],
...         "End":        [8, 12, 25, 45, 85],
...         "Strand":     ["+", "-", "+", "+", "-"],
...         "Start_b":    [5,  9, 23, 60, 70],
...         "End_b":      [7, 20, 30, 70, 75],
...         "Strand_b":   ["+", "+", "-", "-", "+"],
...     }
... )
>>> gr = pr.PyRanges(df)

# length
>>> gr.compute_interval_metrics("overlap_length")["overlap_length"].tolist()
[2, 2, 2, 0, 0]

# fraction (overlap / first interval length)
>>> gr.compute_interval_metrics("fraction")["fraction"].round(2).tolist()
[0.33, 1.0, 0.4, 0.0, 0.0]

# jaccard
>>> gr.compute_interval_metrics("jaccard")["jaccard"].round(2).tolist()
[0.33, 0.18, 0.2, 0.0, 0.0]

# distance (unsigned gap; 0 when overlapping)
>>> gr.compute_interval_metrics("distance")["distance"].tolist()
[0, 0, 0, 15, 5]

# overlap flag
>>> gr.compute_interval_metrics("overlap")["overlap"].tolist()
[True, True, True, False, False]

# signed_distance
>>> gr.compute_interval_metrics("signed_distance")["signed_distance"].tolist()
[0, 0, 0, 15, -5]

# midpoint_distance
>>> gr.compute_interval_metrics("midpoint_distance")["midpoint_distance"].tolist()
[1.0, 3.5, 4.0, 22.5, 10.0]

# symmetric_coverage
>>> gr.compute_interval_metrics("symmetric_coverage")["symmetric_coverage"].round(2).tolist()
[0.5, 0.31, 0.33, 0.0, 0.0]

# relative_direction (requires strand columns)
>>> gr.compute_interval_metrics("relative_direction")["relative_direction"].tolist()
['same', 'opposite', 'opposite', 'opposite', 'opposite']


####################################################################################################
PyRanges.copy()
###############
Return a copy of the PyRanges.


####################################################################################################
PyRanges.count_overlaps()
#########################
Count number of overlaps per interval.

For each interval in self, report how many intervals in 'other' overlap with it.

Parameters
----------
other: PyRanges
    Count overlaps with this PyRanges.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

strand_behavior : {"auto", "same", "opposite", "ignore"}, default "auto"
    Whether to consider overlaps of intervals on the same strand, the opposite or ignore strand
    information. The default, "auto", means use "same" if both PyRanges are stranded (see .strand_valid)
    otherwise ignore the strand information.

slack : int, default 0
    Temporarily lengthen intervals in self before searching for overlaps.

keep_nonoverlapping : bool, default True
    Keep intervals without overlaps.

overlap_col : str, default "Count"
    Name of column with overlap counts.

Returns
-------
PyRanges
    PyRanges with a column of overlaps added.

See Also
--------
pyranges.count_overlaps: count overlaps from multiple PyRanges

Examples
--------
>>> f1 = pr.example_data.f1.remove_nonloc_columns()
>>> f1
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1                3        6  +
      1  |    chr1                5        7  -
      2  |    chr1                8        9  +
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f2 = pr.example_data.f2.remove_nonloc_columns()
>>> f2
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1                1        2  +
      1  |    chr1                6        7  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f1.count_overlaps(f2)
  index  |    Chromosome      Start      End  Strand         Count
  int64  |    category        int64    int64  category      uint32
-------  ---  ------------  -------  -------  ----------  --------
      0  |    chr1                3        6  +                  0
      1  |    chr1                5        7  -                  1
      2  |    chr1                8        9  +                  0
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f1.count_overlaps(f2, slack=1, strand_behavior="ignore")
  index  |    Chromosome      Start      End  Strand         Count
  int64  |    category        int64    int64  category      uint32
-------  ---  ------------  -------  -------  ----------  --------
      0  |    chr1                3        6  +                  1
      1  |    chr1                5        7  -                  1
      2  |    chr1                8        9  +                  0
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> annotation = pr.example_data.ensembl_gtf.get_with_loc_columns(['transcript_id', 'Feature'])
>>> reads = pr.random(1000, chromsizes={'1':150000}, strand=False, seed=123)
>>> annotation.count_overlaps(reads, overlap_col="NumberOverlaps")
index    |    Chromosome    Start    End      Strand      transcript_id    Feature     NumberOverlaps
int64    |    category      int64    int64    category    object           category    uint32
-------  ---  ------------  -------  -------  ----------  ---------------  ----------  ----------------
0        |    1             11868    14409    +           nan              gene        17
1        |    1             11868    14409    +           ENST00000456328  transcript  17
2        |    1             11868    12227    +           ENST00000456328  exon        3
3        |    1             12612    12721    +           ENST00000456328  exon        1
...      |    ...           ...      ...      ...         ...              ...         ...
7        |    1             120724   133723   -           ENST00000610542  transcript  76
8        |    1             133373   133723   -           ENST00000610542  exon        1
9        |    1             129054   129223   -           ENST00000610542  exon        3
10       |    1             120873   120932   -           ENST00000610542  exon        1
PyRanges with 11 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.downstream()
#####################
Return regions downstream (at the 5' side) of input intervals.

Parameters
----------
length : int
    Size of the region (bp), **> 0**.
gap : int, default 0
    Distance between input intervals and region; use negative to include some overlap.
group_by : str or list of str or None
    Name(s) of column(s) to group intervals. If provided, one region per group (e.g. transcript) is returned.
use_strand: {"auto", True, False}, default: "auto"
    Whether to consider strand; if so, the downstream window of negative intervals is on their left.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

See Also
--------
PyRanges.slice_ranges : obtain subsequences of intervals, providing transcript-level coordinates
PyRanges.upstream : return regions upstream of input intervals or transcripts
PyRanges.three_end : return the 3' end of intervals or transcripts
PyRanges.extend_ranges : return intervals or transcripts extended at one or both ends

Examples
--------
>>> a = pr.PyRanges({'Chromosome':['chr1','chr1'],
...                  'Start':[100,200],'End':[120,220],
...                  'Strand':['+','-']})
>>> a
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1              100      120  +
      1  |    chr1              200      220  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Default 10-bp window butt-ended to the feature:

>>> a.downstream(10)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1              120      130  +
      1  |    chr1              190      200  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

With a 5-bp gap:

>>> a.downstream(10, gap=5)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1              125      135  +
      1  |    chr1              185      195  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

With a 5-bp overlap:

>>> a.downstream(10, gap=-5)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1              115      125  +
      1  |    chr1              195      205  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Transcript-aware (two 2-exon transcripts):

>>> ex = pr.PyRanges({'Chromosome':['chr1']*4,
...                   'Start':[0,10,30,50],'End':[5,15,40,60],
...                   'Strand':['+','+','-','-'],
...                   'Tx':['tx1','tx1','tx2','tx2']})
>>> ex
  index  |    Chromosome      Start      End  Strand    Tx
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                0        5  +         tx1
      1  |    chr1               10       15  +         tx1
      2  |    chr1               30       40  -         tx2
      3  |    chr1               50       60  -         tx2
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> ex.downstream(5, group_by='Tx')
  index  |    Chromosome      Start      End  Strand    Tx
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      1  |    chr1               15       20  +         tx1
      2  |    chr1               25       30  -         tx2
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Note that upstream regions may extend beyond the start of the chromosome, resulting in invalid ranges.
See clip_ranges() to fix this.

>>> ex.downstream(50, group_by='Tx')
  index  |    Chromosome      Start      End  Strand    Tx
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      1  |    chr1               15       65  +         tx1
      2  |    chr1              -20       30  -         tx2
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.
Invalid ranges:
  * 1 starts or ends are < 0. See indexes: 2


####################################################################################################
PyRanges.extend_ranges()
########################
Extend the intervals from the 5' and/or 3' ends.

The Strand (if valid) is considered when extending the intervals:
a 5' extension applies to the Start of a "+" strand interval and to the End of a "-" strand interval.

Parameters
----------
ext: int or None
    Extend intervals by this amount from both ends.

ext_5: int or None
    Extend intervals by this amount from the 5' end.

ext_3: int or None
    Extend intervals by this amount from the 3' end.

group_by : str or list of str, default: None
    group intervals by these column name(s) (e.g. into multi-exon transcripts), so that the
    extension is applied only to the left-most and/or right-most interval.

use_strand: {"auto", True, False}, default: "auto"
    If False, ignore strand information when extending intervals.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

See Also
--------
PyRanges.slice_ranges : obtain subsequences of intervals, providing transcript-level coordinates
PyRanges.upstream : return regions upstream of input intervals or transcripts
PyRanges.downstream : return regions downstream of input intervals or transcripts
PyRanges.five_end : return the 5' end of intervals or transcripts
PyRanges.three_end : return the 3' end of intervals or transcripts
PyRanges.extend_ranges : return intervals or transcripts extended at one or both ends

Examples
--------
>>> d = {'Chromosome': ['chr1', 'chr1', 'chr1'], 'Start': [3, 8, 5], 'End': [6, 9, 7],
...      'Strand': ['+', '+', '-']}
>>> gr = pr.PyRanges(d)
>>> gr
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                3        6  +
      1  |    chr1                8        9  +
      2  |    chr1                5        7  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.extend_ranges(3)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                0        9  +
      1  |    chr1                5       12  +
      2  |    chr1                2       10  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


>>> gr.extend_ranges(ext_3=1, ext_5=2)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        7  +
      1  |    chr1                6       10  +
      2  |    chr1                4        9  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.extend_ranges(ext_3=1, ext_5=2, use_strand=False)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        7  +
      1  |    chr1                6       10  +
      2  |    chr1                3        8  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Extending by negative values will contract the intervals. This may yield invalid intervals:

>>> gr.extend_ranges(-1)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                4        5  +
      1  |    chr1                9        8  +
      2  |    chr1                6        6  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.
Invalid ranges:
  * 2 intervals are empty or negative length (end <= start). See indexes: 1, 2

Extending beyond the boundaries of the chromosome is allowed though it yields invalid ranges (below).
See clip_ranges() to fix this.

>>> gr.extend_ranges(4)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1               -1       10  +
      1  |    chr1                4       13  +
      2  |    chr1                1       11  -
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.
Invalid ranges:
  * 1 starts or ends are < 0. See indexes: 0


>>> gr['transcript_id']=['a', 'a', 'b']
>>> gr.extend_ranges(group_by='transcript_id', ext_3=3)
  index  |    Chromosome      Start      End  Strand    transcript_id
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  ---------------
      0  |    chr1                3        6  +         a
      1  |    chr1                8       12  +         a
      2  |    chr1                2        7  -         b
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.five_end()
###################
Return the five prime end of intervals.

The five prime end is the start of a forward strand or the end of a reverse strand.
All returned intervals have length of 1.

Parameters
----------
group_by : str or list of str, default: None
    Optional column name(s). If provided, the five prime end is calculated for each
    group of intervals.

ext : int, default 0
    Lengthen the resulting intervals on both ends by this amount.

See Also
--------
PyRanges.upstream : return regions upstream of input intervals or transcripts
PyRanges.three_end : return the 3' end of intervals or transcripts
PyRanges.extend_ranges : return intervals or transcripts extended at one or both ends

Returns
-------
PyRanges

    PyRanges with the five prime ends

Note
----
Requires the PyRanges to be stranded.

See Also
--------
PyRanges.three_end : return the 3' end
PyRanges.slice_ranges : return subintervals specified in relative mRNA-based coordinates

Examples
--------
>>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1'], 'Start': [3, 10, 5], 'End': [9, 14, 7],
...                    'Strand': ["+", "+", "-"], 'Name': ['a', 'a', 'b']})
>>> gr
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                3        9  +         a
      1  |    chr1               10       14  +         a
      2  |    chr1                5        7  -         b
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.five_end()
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                3        4  +         a
      1  |    chr1               10       11  +         a
      2  |    chr1                6        7  -         b
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.five_end(group_by='Name')
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                3        4  +         a
      2  |    chr1                6        7  -         b
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.five_end(group_by='Name', ext=1)
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                2        5  +         a
      2  |    chr1                5        8  -         b
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.flip_strand()
######################
Flip the strand of every interval (+ ‚Üí - and - ‚Üí +).

All other columns remain unchanged.  If the object does not contain a
valid *Strand* column (see .strand_valid) a
`ValueError` is raised.

Returns
-------
PyRanges
    A **new** PyRanges whose *Strand* column is flipped.

Examples
--------
>>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr1'],
...                   'Start': [0, 10], 'End': [5, 15],
...                   'Strand': ['+', '-']})
>>> gr
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                0        5  +
      1  |    chr1               10       15  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.flip_strand()
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                0        5  -
      1  |    chr1               10       15  +
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Attempting to flip when strands are missing or invalid:

>>> pr.PyRanges({'Chromosome': ['chr1'], 'Start': [0], 'End': [5]}).flip_strand()
Traceback (most recent call last):
    ...
ValueError: strand column is missing or invalid


####################################################################################################
PyRanges.get_sequence()
#######################
Get the sequence of the intervals from a fasta file.

Parameters
----------
path : Path
    Path to fasta file. It will be indexed using pyfaidx if an index is not found

pyfaidx_fasta : pyfaidx.Fasta
    Alternative method to provide fasta target, as a pyfaidx.Fasta object

use_strand: {"auto", True, False}, default: "auto"
    If True, intervals on the reverse strand will be reverse complemented.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).


group_by : str or list of str, optional
    If provided, intervals grouped by this/these ID column(s) and the corresponding sequences
    are concatenated 5'->3'. This is useful for obtaining the full sequences of multi-exon transcripts.

sequence_column: str, default "Sequence"
    What the added column will be called.

Returns
-------
Series

    Sequences, one per interval, with the same index as self.
    If group_by is provided, instead returns one sequence per group, with the index being the group ID(s).

Note
----

This function requires the library pyfaidx, it can be installed with
``conda install -c bioconda pyfaidx`` or ``pip install pyfaidx``.

Sorting the PyRanges is likely to improve the speed.
Intervals on the negative strand will be reverse complemented.

Warning
-------

Note that the names in the fasta header and self.Chromosome must be the same.

See Also
--------
pyranges.seqs : submodule with sequence-related functions

Examples
--------
>>> import pyranges as pr
>>> r = pr.PyRanges({"Chromosome": ["chr1", "chr1"],
...                   "Start": [5, 0], "End": [8, 5],
...                   "Strand": ["+", "-"]})

>>> r
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                5        8  +
      1  |    chr1                0        5  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> tmp_handle = open("temp.fasta", "w+")
>>> _ = tmp_handle.write(">chr1\n")
>>> _ = tmp_handle.write("GTAATCAT\n")
>>> tmp_handle.close()

>>> seq = r.get_sequence("temp.fasta", sequence_column="Sequence")
>>> seq
0      CAT
1    ATTAC
Name: Sequence, dtype: object

>>> r["seq"] = seq
>>> r
  index  |    Chromosome      Start      End  Strand    seq
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                5        8  +         CAT
      1  |    chr1                0        5  -         ATTAC
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> r.get_sequence("temp.fasta", use_strand=False)
0      CAT
1    GTAAT
Name: Sequence, dtype: object

Fetching full sequences of transcripts:

>>> gr = pr.PyRanges({"Chromosome": ['chr1'] * 5,
...                   "Start": [0, 9, 18, 9, 18], "End": [4, 13, 21, 13, 21],
...                   "Strand":['+', '-', '-', '-', '-'],
...                   "transcript": ['t1', 't2', 't2', 't4', 't5']})

>>> tmp_handle = open("temp.fasta", "w+")
>>> _ = tmp_handle.write(">chr1\n")
>>> _ = tmp_handle.write("AAACCCTTTGGGAAACCCTTTGGG\n")
>>> tmp_handle.close()

>>> seq = gr.get_sequence(path="temp.fasta", group_by='transcript')
>>> seq  # doctest: +NORMALIZE_WHITESPACE
transcript
t1       AAAC
t2    AAATCCC
t4       TCCC
t5        AAA
Name: Sequence, dtype: object

With use_strand=False, all intervals are treated as if on the forward strand:

>>> seq2 = gr.get_sequence(path="temp.fasta", group_by='transcript', use_strand=False, sequence_column="Seq2")
>>> seq2 # doctest: +NORMALIZE_WHITESPACE
transcript
t1       AAAC
t2    GGGATTT
t4       GGGA
t5        TTT
Name: Seq2, dtype: object

To write to a file in fasta format:
>>> with open('outfile.fasta', 'w') as fw:
...     nchars=60
...     for oneid, oneseq in seq.items():
...         s = '\\n'.join([ oneseq[i:i+nchars] for i in range(0, len(oneseq), nchars)])
...         _bytes_written = fw.write(f'>{oneid}\\n{s}\\n')


####################################################################################################
PyRanges.get_with_loc_columns()
###############################
Return a PyRanges with the requested columns, as well as the genome location columns.

Parameters
----------
key : str or iterable of str
    Column(s) to return.

preserve_loc_order : bool, default False
    Whether to preserve the order of the genome location columns.
    If False, the genome location columns will be moved to the left.

Returns
-------
PyRanges

    PyRanges with the requested columns.

See Also
--------
PyRanges.remove_nonloc_columns : remove all columns that are not genome location columns.

Examples
--------
>>> gr = pr.PyRanges({"Chromosome": [1], "Start": [895], "Strand": ["+"],
...                   "Score": [1], "Score2": [2], "End": [1259]})
>>> gr
  index  |      Chromosome    Start  Strand      Score    Score2      End
  int64  |           int64    int64  object      int64     int64    int64
-------  ---  ------------  -------  --------  -------  --------  -------
      0  |               1      895  +               1         2     1259
PyRanges with 1 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.

Genomic location columns are moved to the left by default:

>>> gr.get_with_loc_columns(["Score2", "Score", "Score2"])
  index  |      Chromosome    Start      End  Strand      Score2    Score    Score2
  int64  |           int64    int64    int64  object       int64    int64     int64
-------  ---  ------------  -------  -------  --------  --------  -------  --------
      0  |               1      895     1259  +                2        1         2
PyRanges with 1 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.

>>> gr.get_with_loc_columns(["Score2", "Score"], preserve_loc_order=True)
  index  |      Chromosome    Start  Strand      Score2    Score      End
  int64  |           int64    int64  object       int64    int64    int64
-------  ---  ------------  -------  --------  --------  -------  -------
      0  |               1      895  +                2        1     1259
PyRanges with 1 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.

>>> gr.get_with_loc_columns(["Score2", "Score", "Score2"], preserve_loc_order=True)
Traceback (most recent call last):
...
ValueError: Duplicate keys not allowed when preserve_loc_order is True.


####################################################################################################
PyRanges.group_cumsum()
#######################
Strand-aware cumulative length of every interval *within each chromosome-level group*.

For every chromosome (and, if supplied, every unique combination in
*group_by*) the intervals are walked 5‚Üí3 **on their own strand**.
Two new columns are added:

* ``cumsum_start_column`` - running total **before** the interval
* ``cumsum_end_column``   - running total **after**  the interval

Parameters
----------
group_by : str or list, default *None*
    Additional column(s) that must match for two intervals to share a
    cumulative coordinate space.  When *None* all intervals on the same
    chromosome are cumulated together.
cumsum_start_column, cumsum_end_column : str | None, default None
    Names of the columns added to the returned frame. If None is given,
    Start and End is used.
use_strand: {"auto", True, False}, default: "auto"
    Whether negative strand intervals should be sliced in descending order, meaning 5' to 3'.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).
keep_order : bool, default True
    Whether to output results in the original row order.

Returns
-------
PyRanges
    Copy of *self* with the two cumulative-length columns appended.

Examples
--------
>>> gr = pr.example_data.ensembl_gtf.get_with_loc_columns(["Feature", "gene_name"])
>>> gr = gr[gr.Feature == "exon"]
>>> gr
  index  |      Chromosome    Start      End  Strand      Feature     gene_name
  int64  |        category    int64    int64  category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  -----------
      2  |               1    11868    12227  +           exon        DDX11L1
      3  |               1    12612    12721  +           exon        DDX11L1
      4  |               1    13220    14409  +           exon        DDX11L1
      5  |               1   112699   112804  -           exon        AL627309.1
      6  |               1   110952   111357  -           exon        AL627309.1
      8  |               1   133373   133723  -           exon        AL627309.1
      9  |               1   129054   129223  -           exon        AL627309.1
     10  |               1   120873   120932  -           exon        AL627309.1
PyRanges with 8 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.
>>> gr.group_cumsum(group_by="gene_name")
  index  |      Chromosome    Start      End  Strand      Feature     gene_name
  int64  |        category    int64    int64  category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  -----------
      2  |               1        0      359  +           exon        DDX11L1
      3  |               1      359      468  +           exon        DDX11L1
      4  |               1      468     1657  +           exon        DDX11L1
      5  |               1      578      683  -           exon        AL627309.1
      6  |               1      683     1088  -           exon        AL627309.1
      8  |               1        0      350  -           exon        AL627309.1
      9  |               1      350      519  -           exon        AL627309.1
     10  |               1      519      578  -           exon        AL627309.1
PyRanges with 8 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.groupby()
##################
Groupby PyRanges.


####################################################################################################
PyRanges.intersect_overlaps()
#############################
Return overlapping subintervals.

Returns the segments of the intervals in self which overlap with those in other.
When multiple intervals in 'other' overlap with the same interval in self, the result
may be complex -- read the argument 'multiple' for details.

Parameters
----------
other : PyRanges
    PyRanges to find overlaps with.

multiple : {"all", "first", "last"}, default "all"
    What intervals to report when multiple intervals in 'other' overlap with the same interval in self.
    The default "all" reports all overlapping subintervals, which will have duplicate indices.
    "first" reports only, for each interval in self, the overlapping subinterval with smallest Start in 'other'
    "last" reports only the overlapping subinterval with the biggest End in 'other'

strand_behavior : {"auto", "same", "opposite", "ignore"}, default "auto"
    Whether to consider overlaps of intervals on the same strand, the opposite or ignore strand
    information. The default, "auto", means use "same" if both PyRanges are stranded (see .strand_valid)
    otherwise ignore the strand information.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

Returns
-------
PyRanges
    A PyRanges with overlapping intervals. Input index is preserved, but may contain duplicates.

See Also
--------
PyRanges.overlap : report overlapping (unmodified) intervals
PyRanges.subtract_overlaps : report non-overlapping subintervals
PyRanges.set_intersect_overlaps : set-intersect PyRanges

Examples
--------
>>> r1 = pr.PyRanges({"Chromosome": ["chr1"] * 3, "Start": [5, 20, 40],"End": [10, 30, 50], "ID": ["a", "b", "c"]})
>>> r1
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                5       10  a
      1  |    chr1               20       30  b
      2  |    chr1               40       50  c
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.


>>> r2 = pr.PyRanges({"Chromosome": ["chr1"] * 4, "Start": [7, 18, 25, 28], "End": [9, 22, 33, 32]})
>>> r2
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                7        9
      1  |    chr1               18       22
      2  |    chr1               25       33
      3  |    chr1               28       32
PyRanges with 4 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> r1.intersect_overlaps(r2)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                7        9  a
      1  |    chr1               20       22  b
      1  |    chr1               25       30  b
      1  |    chr1               28       30  b
PyRanges with 4 rows, 4 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes.

>>> r1.intersect_overlaps(r2, multiple="first")
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                7        9  a
      1  |    chr1               20       22  b
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> r1.intersect_overlaps(r2, multiple="last")
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                7        9  a
      1  |    chr1               28       30  b
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.join_overlaps()
########################
Join PyRanges based on genomic overlap.

Find pairs of overlapping intervals between two PyRanges (self and other) and combine their columns.
Each row in the return PyRanges contains columns of both intervals, including their coordinates.
By default, intervals without overlap are not reported.

Parameters
----------
other : PyRanges
    PyRanges to join.

strand_behavior : {"auto", "same", "opposite", "ignore"}, default "auto"
    Whether to consider overlaps of intervals on the same strand, the opposite or ignore strand
    information. The default, "auto", means use "same" if both PyRanges are stranded (see .strand_valid)
    otherwise ignore the strand information.

join_type : {"inner", "left", "right", "outer"}, default "inner"
    How to handle intervals without overlap. "inner" means only keep overlapping intervals.
    "left" keeps all intervals in self, "right" keeps all intervals in other, "outer" keeps both.
    For types other than "inner", intervals in self without overlaps will have NaN in columns from other,
    and/or vice versa.

multiple : {"all", "first", "last"}, default "all"
    What intervals to report when multiple intervals in 'other' overlap with the same interval in self.
    The default "all" reports all overlapping subintervals, which will have duplicate indices.
    "first" reports only, for each interval in self, the overlapping subinterval with smallest Start in 'other'
    "last" reports only the overlapping subinterval with the biggest End in 'other'

contained_intervals_only : bool, default False
    Whether to report only intervals that are entirely contained in an interval of 'other'.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be joined.

report_overlap_column : str or None
    Report amount of overlap in base pairs using column name

slack : int, default 0
    Before joining, temporarily extend intervals in self by this much on both ends.

suffix : str or tuple, default "_b"
    Suffix to give overlapping columns in other.

Returns
-------
PyRanges

    A PyRanges appended with columns of another.

Note
----
The indices of the two input PyRanges are not preserved in output.
The chromosome column from other will never be reported as it is always the same as in self.
Whether the strand column from other is reported depends on the strand_behavior.


See Also
--------
PyRanges.combine_interval_columns : give joined PyRanges new coordinates
PyRanges.compute_interval_metrics : compute overlap metrics in joined PyRanges

Examples
--------
>>> f1 = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1'],
...                   'Start': [3, 8, 5],
...                   'End': [6, 9, 7],
...                   'Name': ['interval1', 'interval3', 'interval2']})
>>> f1
  index  |    Chromosome      Start      End  Name
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  ---------
      0  |    chr1                3        6  interval1
      1  |    chr1                8        9  interval3
      2  |    chr1                5        7  interval2
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> f2 = pr.PyRanges({'Chromosome': ['chr1', 'chr1'],
...                   'Start': [1, 6],
...                   'End': [2, 7],
...                   'Name': ['a', 'b']})
>>> f2
  index  |    Chromosome      Start      End  Name
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        2  a
      1  |    chr1                6        7  b
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> f1.join_overlaps(f2)
  index  |    Chromosome      Start      End  Name         Start_b    End_b  Name_b
  int64  |    object          int64    int64  object         int64    int64  object
-------  ---  ------------  -------  -------  ---------  ---------  -------  --------
      2  |    chr1                5        7  interval2          6        7  b
PyRanges with 1 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes.

Note that since some start and end columns are NaN, a regular DataFrame is returned.

>>> f1.join_overlaps(f2, join_type="left")
  index  |    Chromosome      Start      End  Name         Start_b      End_b  Name_b
  int64  |    object          int64    int64  object       float64    float64  object
-------  ---  ------------  -------  -------  ---------  ---------  ---------  --------
      2  |    chr1                5        7  interval2          6          7  b
      0  |    chr1                3        6  interval1        nan        nan  nan
      1  |    chr1                8        9  interval3        nan        nan  nan
PyRanges with 3 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes.

>>> f1.join_overlaps(f2, join_type="outer")
  index  |    Chromosome        Start        End  Name         Start_b      End_b  Name_b
  int64  |    object          float64    float64  object       float64    float64  object
-------  ---  ------------  ---------  ---------  ---------  ---------  ---------  --------
      1  |    chr1                  5          7  interval2          6          7  b
      0  |    chr1                  3          6  interval1        nan        nan  nan
      1  |    chr1                  8          9  interval3        nan        nan  nan
      0  |    nan                 nan        nan  nan                1          2  a
PyRanges with 4 rows, 7 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes.
Invalid ranges:
  * 1 starts or ends are nan. See indexes: 0

>>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr2', 'chr1', 'chr3'],
...                   'Start': [1, 4, 10, 0],
...                   'End': [3, 9, 11, 1],
...                   'ID': ['a', 'b', 'c', 'd']})
>>> gr
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  a
      1  |    chr2                4        9  b
      2  |    chr1               10       11  c
      3  |    chr3                0        1  d
PyRanges with 4 rows, 4 columns, and 1 index columns.
Contains 3 chromosomes.

>>> gr2 = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1'],
...                    'Start': [2, 2, 1],
...                    'End': [3, 9, 10],
...                    'ID': ['a', 'b', 'c']})
>>> gr2
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                2        3  a
      1  |    chr1                2        9  b
      2  |    chr1                1       10  c
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.join_overlaps(gr2)
  index  |    Chromosome      Start      End  ID          Start_b    End_b  ID_b
  int64  |    object          int64    int64  object        int64    int64  object
-------  ---  ------------  -------  -------  --------  ---------  -------  --------
      0  |    chr1                1        3  a                 1       10  c
      0  |    chr1                1        3  a                 2        3  a
      0  |    chr1                1        3  a                 2        9  b
PyRanges with 3 rows, 7 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes.

>>> gr.join_overlaps(gr2, match_by="ID")
  index  |    Chromosome      Start      End  ID          Start_b    End_b
  int64  |    object          int64    int64  object        int64    int64
-------  ---  ------------  -------  -------  --------  ---------  -------
      0  |    chr1                1        3  a                 2        3
PyRanges with 1 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes.

>>> bad = f1.join_overlaps(f2, join_type="right")
>>> bad
  index  |    Chromosome        Start        End  Name         Start_b    End_b  Name_b
  int64  |    object          float64    float64  object         int64    int64  object
-------  ---  ------------  ---------  ---------  ---------  ---------  -------  --------
      1  |    chr1                  5          7  interval2          6        7  b
      0  |    nan                 nan        nan  nan                1        2  a
PyRanges with 2 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes.
Invalid ranges:
  * 1 starts or ends are nan. See indexes: 0

With slack 1, bookended features are joined (see row 1):

>>> f1.join_overlaps(f2, slack=1)
  index  |    Chromosome      Start      End  Name         Start_b    End_b  Name_b
  int64  |    object          int64    int64  object         int64    int64  object
-------  ---  ------------  -------  -------  ---------  ---------  -------  --------
      0  |    chr1                3        6  interval1          6        7  b
      2  |    chr1                5        7  interval2          6        7  b
PyRanges with 2 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes.

>>> f1.join_overlaps(f2, report_overlap_column="Overlap")
  index  |    Chromosome      Start      End  Name         Start_b    End_b  Name_b      Overlap
  int64  |    object          int64    int64  object         int64    int64  object        int64
-------  ---  ------------  -------  -------  ---------  ---------  -------  --------  ---------
      2  |    chr1                5        7  interval2          6        7  b                 1
PyRanges with 1 rows, 8 columns, and 1 index columns.
Contains 1 chromosomes.

Allowing slack in overlaps may result in 0 or negative Overlap values:

>>> f1.join_overlaps(f2, report_overlap_column="Overlap", slack=2)
  index  |    Chromosome      Start      End  Name         Start_b    End_b  Name_b      Overlap
  int64  |    object          int64    int64  object         int64    int64  object        int64
-------  ---  ------------  -------  -------  ---------  ---------  -------  --------  ---------
      0  |    chr1                3        6  interval1          1        2  a                -1
      0  |    chr1                3        6  interval1          6        7  b                 0
      1  |    chr1                8        9  interval3          6        7  b                -1
      2  |    chr1                5        7  interval2          6        7  b                 1
PyRanges with 4 rows, 8 columns, and 1 index columns (with 1 index duplicates).
Contains 1 chromosomes.


####################################################################################################
PyRanges.lengths()
##################
Return the length of each interval.

Returns
-------
pd.Series or dict of pd.Series with the lengths of each interval.

See Also
--------
PyRanges.length : return the total length of all intervals combined

Examples
--------
>>> gr = pr.example_data.f1
>>> gr
  index  |    Chromosome      Start      End  Name         Score  Strand
  int64  |    category        int64    int64  object       int64  category
-------  ---  ------------  -------  -------  ---------  -------  ----------
      0  |    chr1                3        6  interval1        0  +
      1  |    chr1                5        7  interval2        0  -
      2  |    chr1                8        9  interval3        0  +
PyRanges with 3 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.lengths()
0    3
1    2
2    1
dtype: int64

>>> gr["Length"] = gr.lengths()
>>> gr
  index  |    Chromosome      Start      End  Name         Score  Strand        Length
  int64  |    category        int64    int64  object       int64  category       int64
-------  ---  ------------  -------  -------  ---------  -------  ----------  --------
      0  |    chr1                3        6  interval1        0  +                  3
      1  |    chr1                5        7  interval2        0  -                  2
      2  |    chr1                8        9  interval3        0  +                  1
PyRanges with 3 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.make_strand_valid()
############################
Make the strand information in PyRanges valid.

Convert all invalid Strand values (those other than "+" and "-") to positive stranded values "+".
If the Strand column is not present, add it with all values set to "+".

Returns
-------
PyRanges
    PyRanges with valid strand information.

See Also
--------
PyRanges.strand_valid : whether PyRanges has valid strand info
PyRanges.remove_strand : remove the Strand column from PyRanges

Examples
--------
>>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr1'], 'Start': [1, 6],
...                   'End': [5, 8], 'Strand': ['-', '.']})
>>> gr
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        5  -
      1  |    chr1                6        8  .
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands (including non-genomic strands: .).

>>> gr.strand_valid
False

>>> gr.make_strand_valid()
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        5  -
      1  |    chr1                6        8  +
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr2 = pr.PyRanges({'Chromosome': ['chr1', 'chr1'], 'Start': [5, 22],
...                    'End': [15, 30]})
>>> gr2
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                5       15
      1  |    chr1               22       30
PyRanges with 2 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr2.make_strand_valid()
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                5       15  +
      1  |    chr1               22       30  +
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.


####################################################################################################
PyRanges.map_to_global()
########################
Map intervals from a *local* reference frame (e.g. transcript) to *global* coordinates (e.g. genomic).

The self PyRanges object is *local* in the sense that its
``Chromosome`` column stores an **identifier** (e.g. a
transcript ID), so that its interval coordinates are expressed
relative to that identifier.
The *global* object *gr* supplies the absolute genomic coordinates
of every interval group (e.g. annotation of transcripts, potentially with multiple
exons). The function returns the self intervals in the reference
system of the global object.

The strand of returned intervals is the product of the strand of
the corresponding local and global intervals (e.g. +/- => -)

Unused rows in *gr* (identifiers never referenced by ``self``) are ignored.

Parameters
----------
gr : PyRanges
    Intervals in global reference system (e.g. transcript annotation
    in genomic coordinates).
global_on : str
    Column in *gr* that holds the identifiers contained in
    ``self.Chromosome``.
local_on : str, default "Chromosome"
    Column in `self` that holds the identifier to be lifted. Change this
    if your identifiers live in a different column.
keep_id : bool, default False
    If True, keep the identifier column (Chromosome in `self`) in the output.
keep_loc : bool, default False
    If True, keep the local location columns (Start, End, Strand) in the output.
pep_to_cds : bool, default False
    If True, the function will assume that the intervals in `self` are
    peptide coordinates and those in *gr* are CDS coordinates.
    Thus, ``self`` coordinates are multiplied by 3 before mapping to global.

Returns
-------
PyRanges
    Intervals in genomic coordinates, maintaining order, index, and
    metadata columns of self.

Warning
-------
A single local interval will give rise to multiple intervals in output
if it overlaps discontinuities (i.e. introns) in global coordinates.
This will generate duplicated indices. To avoid them,
run pandas dataframe method ``reset_index`` on the output.

Examples
--------
>>> gr = pr.PyRanges(pd.DataFrame({
...     "Chromosome": ["chr1","chr1","chr1","chr1"],
...     "Start": [100, 300, 1000, 1100],
...     "End": [200, 400, 1050, 1200],
...     "Strand": ["+","+", "-", "-"],
...     "transcript_id": ["tx1","tx1","tx2","tx2"],
... }))
>>> tr = pr.PyRanges(pd.DataFrame({
...     "Chromosome": ["tx1","tx1","tx1","tx2","tx2"],
...     "Start": [0, 120, 160, 0, 100],
...     "End": [80, 140, 170, 20, 130],
...     "Strand": ["-","-", "+", "+", "+"],
...     "label": ["a","b","c","d","e"],
... }))
>>> gr
  index  |    Chromosome      Start      End  Strand    transcript_id
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  ---------------
      0  |    chr1              100      200  +         tx1
      1  |    chr1              300      400  +         tx1
      2  |    chr1             1000     1050  -         tx2
      3  |    chr1             1100     1200  -         tx2
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> tr
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    tx1                 0       80  -         a
      1  |    tx1               120      140  -         b
      2  |    tx1               160      170  +         c
      3  |    tx2                 0       20  +         d
      4  |    tx2               100      130  +         e
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 2 chromosomes and 2 strands.

>>> tr.map_to_global(gr, "transcript_id")
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1              100      180  -         a
      1  |    chr1              320      340  -         b
      2  |    chr1              360      370  +         c
      3  |    chr1             1180     1200  -         d
      4  |    chr1             1020     1050  -         e
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> tr.map_to_global(gr, "transcript_id", keep_id=True)
  index  |    Chromosome      Start      End  Strand    label     transcript_id
  int64  |    object          int64    int64  object    object    object
-------  ---  ------------  -------  -------  --------  --------  ---------------
      0  |    chr1              100      180  -         a         tx1
      1  |    chr1              320      340  -         b         tx1
      2  |    chr1              360      370  +         c         tx1
      3  |    chr1             1180     1200  -         d         tx2
      4  |    chr1             1020     1050  -         e         tx2
PyRanges with 5 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> tr.map_to_global(gr, "transcript_id", keep_loc=True)
  index  |    Chromosome      Start      End  Strand    label       Start_local    End_local  Strand_local
  int64  |    object          int64    int64  object    object            int64        int64  object
-------  ---  ------------  -------  -------  --------  --------  -------------  -----------  --------------
      0  |    chr1              100      180  -         a                     0           80  -
      1  |    chr1              320      340  -         b                   120          140  -
      2  |    chr1              360      370  +         c                   160          170  +
      3  |    chr1             1180     1200  -         d                     0           20  +
      4  |    chr1             1020     1050  -         e                   100          130  +
PyRanges with 5 rows, 8 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Metadata columns are preserved:

>>> tr.assign(tag=7).map_to_global(gr, "transcript_id").tag.unique()
array([7])

A local interval that spans an exon junction is split; its index is
duplicated in the output.

>>> tr2 = pr.PyRanges(pd.DataFrame({
...     "Chromosome":["tx1","tx2","tx2"],
...     "Start": [90, 80, 50],
...     "End": [110, 120, 120],
...     "Strand": ["+","+", "-"],
...     "label": ["q","w","e"],
... }))
>>> tr2.map_to_global(gr, "transcript_id")
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1              190      200  +         q
      0  |    chr1              300      310  +         q
      1  |    chr1             1030     1050  -         w
      1  |    chr1             1100     1120  -         w
      2  |    chr1             1030     1050  +         e
      2  |    chr1             1100     1150  +         e
PyRanges with 6 rows, 5 columns, and 1 index columns (with 3 index duplicates).
Contains 1 chromosomes and 2 strands.

A local interval longer than its transcript is truncated to the
portion that fits.

>>> tr3 = pr.PyRanges(pd.DataFrame({
...     "Chromosome":["tx1"], "Start":[20], "End":[1000], "Strand":["+"]
... }))
>>> tr3.map_to_global(gr, "transcript_id")
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1              120      200  +
      0  |    chr1              300      400  +
PyRanges with 2 rows, 4 columns, and 1 index columns (with 1 index duplicates).
Contains 1 chromosomes and 1 strands.

Mapping proteins to CDS global positions. Get some protein-based features:

>>> gr = pr.example_data.ncbi_gff
>>> grc = gr[gr.Feature == "CDS"].get_with_loc_columns('Parent')
>>> genome_file = pr.example_data.files['ncbi.fasta']
>>> cdss = grc.get_sequence(genome_file, group_by='Parent').str.upper()
>>> prots = pr.seqs.translate(cdss)
>>> z = [(seq_id, i, 'R') for seq_id, seq in prots.items() for i, char in enumerate(seq)  if char == 'R']
>>> z = pd.DataFrame(z, columns=['ID', 'Start', 'AminoAcid']).assign(End=lambda df: df.Start + 1 )
>>> arginines_pos =  pr.PyRanges(z.rename(columns={"ID": "Chromosome"}))
>>> arginines_pos
index    |    Chromosome             Start    AminoAcid    End
int64    |    object                 int64    object       int64
-------  ---  ---------------------  -------  -----------  -------
0        |    rna-DGYR_LOCUS12552    7        R            8
1        |    rna-DGYR_LOCUS12552    15       R            16
2        |    rna-DGYR_LOCUS12552    25       R            26
3        |    rna-DGYR_LOCUS12552    89       R            90
...      |    ...                    ...      ...          ...
158      |    rna-DGYR_LOCUS14095-2  271      R            272
159      |    rna-DGYR_LOCUS14095-2  309      R            310
160      |    rna-DGYR_LOCUS14095-2  320      R            321
161      |    rna-DGYR_LOCUS14095-2  327      R            328
PyRanges with 162 rows, 4 columns, and 1 index columns.
Contains 17 chromosomes.

>>> genome_arginine_pos = arginines_pos.map_to_global(grc, "Parent", pep_to_cds=True, keep_id=True)
>>> genome_arginine_pos['codon'] = genome_arginine_pos.get_sequence(genome_file).str.upper()
>>> genome_arginine_pos
index    |    Chromosome         Start    AminoAcid    End      Parent                 Strand      codon
int64    |    category           int64    object       int64    object                 category    object
-------  ---  -----------------  -------  -----------  -------  ---------------------  ----------  --------
0        |    CAJFCJ010000025.1  2671     R            2674     rna-DGYR_LOCUS12552    -           CGT
1        |    CAJFCJ010000025.1  2647     R            2650     rna-DGYR_LOCUS12552    -           AGA
2        |    CAJFCJ010000025.1  2617     R            2620     rna-DGYR_LOCUS12552    -           AGA
3        |    CAJFCJ010000025.1  2369     R            2372     rna-DGYR_LOCUS12552    -           AGA
...      |    ...                ...      ...          ...      ...                    ...         ...
159      |    CAJFCJ010000097.1  52993    R            52996    rna-DGYR_LOCUS14095-2  +           AGA
160      |    CAJFCJ010000097.1  53026    R            53027    rna-DGYR_LOCUS14095-2  +           A
160      |    CAJFCJ010000097.1  53339    R            53341    rna-DGYR_LOCUS14095-2  +           GA
161      |    CAJFCJ010000097.1  53359    R            53362    rna-DGYR_LOCUS14095-2  +           AGA
PyRanges with 164 rows, 7 columns, and 1 index columns (with 2 index duplicates).
Contains 3 chromosomes and 2 strands.


####################################################################################################
PyRanges.map_to_local()
#######################
Map *global* genomic intervals (``self``) onto a *local* frame defined by reference ranges ``ref``.

Both ``self`` and ``ref`` are given **in genomic coordinates**.
``ref`` holds the layout of every local entity (typically the exons
that compose each transcript).  Each interval in ``self`` that overlap
with ``ref`` is *re-based* so that the returned ``Start``/``End``
are measured from the 5' end of the **entire transcript** of ``ref``,
with introns removed.  For instance, if the
first exon of a ``ref`` transcript is 100 nt long, the first base
of the second exon has local coordinate 100.

Intervals in ``self`` are mapped to **every transcript they
overlap**; non-overlapping intervals are not reported.  ``ref`` must
contain a column whose name is supplied in *ref_on*. Those values
become the ``Chromosome`` column of the output.

The strand of each returned interval is the ‚Äúproduct‚Äù of the strands
of the overlapping pair (e.g. *+* x. *-* ‚Üí *-*).

Parameters
----------
ref : PyRanges
    Reference ranges in genomic coordinates that define the new
    coordinate system (e.g. multi-exon transcript annotation).
ref_on : str
    Column in ``ref`` that groups intervals into transcripts.
    Values are copied into ``Chromosome`` in the output.
match_by : str or list[str], optional
    If provided, only overlapping intervals with an equal value in
    column(s) `match_by` are reported.
keep_chrom : bool, default False
    If True, keep the global Chromosome column in the output.
keep_loc : bool, default False
    If True, keep the original global location columns (Start, End, Strand) in the output.

Returns
-------
PyRanges
    Intervals remapped to local (transcript) coordinates,
    preserving the original row order, index and metadata columns of ``self``.

Warning
-------
*A single ``self``  interval may overlap several ``ref`` exons, or different transcripts.
In that case its index repeats in the output.  Call ``reset_index()`` afterwards if you
need unique indices.

Examples
--------
>>> import pandas as pd, pyranges as pr
>>> tr = pr.PyRanges(pd.DataFrame({
...     "Chromosome":   ["chr1","chr1","chr1","chr1"],
...     "Start":        [  100,   300,   1000, 1100],
...     "End":          [  200,   400,   1050, 1200],
...     "Strand":       ["+","+", "-","-"],
...     "transcript_id":["tx1","tx1","tx2","tx2"],
... }))
>>> g1 = pr.PyRanges(pd.DataFrame({
...     "Chromosome": ["chr1","chr1","chr1","chr1","chr1","chr1","chr1"],
...     "Start":      [ 110,   220,   320,   340,   500,  1030, 1180],
...     "End":        [ 180,   240,   340,   360,   550,  1050, 1200],
...     "Strand":     ["+","+", "+",  "-","+",   "-","+"],
...     "label":      ["a","no_overlap_intronic","b","c",
...                    "no_overlap_intergenic","d","e"],
... }))

>>> tr
  index  |    Chromosome      Start      End  Strand    transcript_id
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  ---------------
      0  |    chr1              100      200  +         tx1
      1  |    chr1              300      400  +         tx1
      2  |    chr1             1000     1050  -         tx2
      3  |    chr1             1100     1200  -         tx2
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> g1
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  ---------------------
      0  |    chr1              110      180  +         a
      1  |    chr1              220      240  +         no_overlap_intronic
      2  |    chr1              320      340  +         b
      3  |    chr1              340      360  -         c
      4  |    chr1              500      550  +         no_overlap_intergenic
      5  |    chr1             1030     1050  -         d
      6  |    chr1             1180     1200  +         e
PyRanges with 7 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> g1.map_to_local(tr, "transcript_id")
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    tx1                10       80  +         a
      2  |    tx1               120      140  +         b
      3  |    tx1               140      160  -         c
      5  |    tx2               100      120  +         d
      6  |    tx2                 0       20  -         e
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 2 chromosomes and 2 strands.

A genomic interval spanning **two exons** is split:

>>> g2 = pr.PyRanges(pd.DataFrame({
...     "Chromosome":["chr1"], "Start":[180], "End":[330],
...     "Strand":["+"], "label":["q"]}))
>>> g2.map_to_local(tr, "transcript_id")
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    tx1                80      100  +         q
      0  |    tx1               100      130  +         q
PyRanges with 2 rows, 5 columns, and 1 index columns (with 1 index duplicates).
Contains 1 chromosomes and 1 strands.

Self intervals that overlaps multiple target ranges are reported as many times:

>>> tr2 = pr.PyRanges(pd.DataFrame({
...      "Chromosome":   ["chr1","chr1","chr1","chr1"],
...      "Start":        [  100,   300,   110, 300],
...      "End":          [  200,   400,   200, 380],
...      "Strand":       ["+","+","-","-"],
...      "transcript_id":["tx1.1","tx1.1","tx1.2","tx1.2"],
... }))

>>> g3 = pr.PyRanges(pd.DataFrame({
...     "Chromosome": ["chr1"], "Start": [150], "End": [180], "Strand": ["+"], "label": ["x"]}))

>>> g3.map_to_local(tr2, "transcript_id")
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    tx1.1              50       80  +         x
      0  |    tx1.2             100      130  -         x
PyRanges with 2 rows, 5 columns, and 1 index columns (with 1 index duplicates).
Contains 2 chromosomes and 2 strands.

>>> g3.map_to_local(tr2, "transcript_id", keep_chrom=True)
  index  |    Chromosome      Start      End  Strand    label     Chromosome_global
  int64  |    object          int64    int64  object    object    object
-------  ---  ------------  -------  -------  --------  --------  -------------------
      0  |    tx1.1              50       80  +         x         chr1
      0  |    tx1.2             100      130  -         x         chr1
PyRanges with 2 rows, 6 columns, and 1 index columns (with 1 index duplicates).
Contains 2 chromosomes and 2 strands.

>>> g3.map_to_local(tr2, "transcript_id", keep_loc=True)
  index  |    Chromosome      Start      End  Strand    label       Start_global    End_global  Strand_global
  int64  |    object          int64    int64  object    object             int64         int64  object
-------  ---  ------------  -------  -------  --------  --------  --------------  ------------  ---------------
      0  |    tx1.1              50       80  +         x                    100           200  +
      0  |    tx1.2             100      130  -         x                    110           200  -
PyRanges with 2 rows, 8 columns, and 1 index columns (with 1 index duplicates).
Contains 2 chromosomes and 2 strands.

Explicitly restrict what to report using match_by:

>>> g4 = g3.assign(transcript_id="tx1.1")
>>> g4.map_to_local(tr2, "transcript_id", match_by="transcript_id")
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    tx1.1              50       80  +         x
PyRanges with 1 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.

>>> tr3 = tr2.copy()
>>> tr3["label"] = ["x", "b", "c", "d"]
>>> g4.map_to_local(tr3, "transcript_id", match_by="label")
  index  |    Chromosome      Start      End  Strand    label     transcript_id
  int64  |    object          int64    int64  object    object    object
-------  ---  ------------  -------  -------  --------  --------  ---------------
      0  |    tx1.1              50       80  +         x         tx1.1
PyRanges with 1 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.


####################################################################################################
PyRanges.max_disjoint_overlaps()
################################
Find the maximal disjoint set of intervals.

Returns a subset of the rows in *self* so that no two intervals
overlap, choosing those that maximize the number of intervals in
the result.

Parameters
----------
use_strand : {"auto", True, False}, default: "auto"
    Find the max-disjoint set separately for each strand.
    The default ``"auto"`` means ``True`` if ``PyRanges`` has valid
    strands (see `.strand_valid`).

slack : int, default 0
    Length by which the criteria of overlap are loosened.
    A value of ``1`` implies that book-ended intervals are
    considered overlapping.  Higher values allow more distant
    intervals (with a maximum distance of ``slack-1`` between
    them).

match_by : str or list, default ``None``
    If provided, only intervals with an equal value in column(s)
    *match_by* may be considered as overlapping.

Returns
-------
PyRanges
    A ``PyRanges`` containing the maximal disjoint set of
    intervals.

See Also
--------
PyRanges.merge_overlaps : merge intervals into non-overlapping
    super-intervals
PyRanges.split_overlaps : split intervals into non-overlapping sub-intervals
PyRanges.cluster : annotate overlapping intervals with a common ID

Examples
--------
>>> gr = pr.example_data.f1
>>> gr
  index  |    Chromosome      Start      End  Name         Score  Strand
  int64  |    category        int64    int64  object       int64  category
-------  ---  ------------  -------  -------  ---------  -------  ----------
      0  |    chr1                3        6  interval1        0  +
      1  |    chr1                5        7  interval2        0  -
      2  |    chr1                8        9  interval3        0  +
PyRanges with 3 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.max_disjoint_overlaps(use_strand=False)
  index  |    Chromosome      Start      End  Name         Score  Strand
  int64  |    category        int64    int64  object       int64  category
-------  ---  ------------  -------  -------  ---------  -------  ----------
      0  |    chr1                3        6  interval1        0  +
      2  |    chr1                8        9  interval3        0  +
PyRanges with 2 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.

Strand-aware selection

>>> c = pr.PyRanges(dict(
...     Chromosome=["chr1"] * 8,
...     Start=[1, 4, 10, 12, 19, 20, 24, 28],
...     End=[5, 7, 14, 16, 27, 22, 25, 30],
...     Strand=["+", "+", "+", "-", "+", "+", "+", "+"]
... ))
>>> c
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        5  +
      1  |    chr1                4        7  +
      2  |    chr1               10       14  +
      3  |    chr1               12       16  -
      4  |    chr1               19       27  +
      5  |    chr1               20       22  +
      6  |    chr1               24       25  +
      7  |    chr1               28       30  +
PyRanges with 8 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> c.max_disjoint_overlaps(use_strand=True)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        5  +
      2  |    chr1               10       14  +
      3  |    chr1               12       16  -
      4  |    chr1               19       27  +
      7  |    chr1               28       30  +
PyRanges with 5 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Using *match_by* to exempt rows from mutual overlap

>>> c3 = c.copy()
>>> c3["label"] = [f"x{i}" for i in range(len(c3))]
>>> c3.max_disjoint_overlaps(match_by="label")
  index  |    Chromosome      Start      End  Strand    label
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                1        5  +         x0
      1  |    chr1                4        7  +         x1
      2  |    chr1               10       14  +         x2
      3  |    chr1               12       16  -         x3
      4  |    chr1               19       27  +         x4
      5  |    chr1               20       22  +         x5
      6  |    chr1               24       25  +         x6
      7  |    chr1               28       30  +         x7
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.merge_overlaps()
#########################
Merge overlapping intervals into one.

Returns a PyRanges with superintervals that are the union of overlapping intervals.

Parameters
----------
use_strand: {"auto", True, False}, default: "auto"
    Only merge intervals on same strand.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

count : bool, default False
    Count intervals in each superinterval.

count_col : str, default "Count"
    Name of column with counts.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

slack : int, default 0
    Allow this many nucleotides between each interval to merge.

Returns
-------
PyRanges
    PyRanges with superintervals. Metadata columns, index, and order are not preserved.

Note
----
To avoid losing metadata, use cluster instead. If you want to perform a reduction function
on the metadata, use pandas groupby.

See Also
--------
PyRanges.cluster : annotate overlapping intervals with common ID
PyRanges.max_disjoint_overlaps : find the maximal disjoint set of intervals
PyRanges.split_overlaps : split intervals into non-overlapping subintervals

Examples
--------
>>> gr = pr.example_data.ensembl_gtf.get_with_loc_columns(["Feature", "gene_name"])
>>> gr
index    |    Chromosome    Start    End      Strand      Feature     gene_name
int64    |    category      int64    int64    category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  -----------
0        |    1             11868    14409    +           gene        DDX11L1
1        |    1             11868    14409    +           transcript  DDX11L1
2        |    1             11868    12227    +           exon        DDX11L1
3        |    1             12612    12721    +           exon        DDX11L1
...      |    ...           ...      ...      ...         ...         ...
7        |    1             120724   133723   -           transcript  AL627309.1
8        |    1             133373   133723   -           exon        AL627309.1
9        |    1             129054   129223   -           exon        AL627309.1
10       |    1             120873   120932   -           exon        AL627309.1
PyRanges with 11 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.merge_overlaps(count_col="Count")
  index  |      Chromosome    Start      End  Strand         Count
  int64  |        category    int64    int64  category      uint32
-------  ---  ------------  -------  -------  ----------  --------
      0  |               1    11868    14409  +                  5
      1  |               1   110952   111357  -                  1
      2  |               1   112699   112804  -                  1
      3  |               1   120724   133723  -                  4
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.merge_overlaps(count_col="Count", match_by="gene_name")
  index  |      Chromosome    Start      End  Strand      gene_name       Count
  int64  |        category    int64    int64  category    object         uint32
-------  ---  ------------  -------  -------  ----------  -----------  --------
      0  |               1    11868    14409  +           DDX11L1             5
      1  |               1   110952   111357  -           AL627309.1          1
      2  |               1   112699   112804  -           AL627309.1          1
      3  |               1   120724   133723  -           AL627309.1          4
PyRanges with 4 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.nearest_ranges()
#########################
Find closest interval.

For each interval in self PyRanges, the columns of the nearest interval in other PyRanges are appended.

Parameters
----------
other : PyRanges
    PyRanges to find nearest interval in.

strand_behavior : {"auto", "same", "opposite", "ignore"}, default "auto"
    Whether to consider overlaps of intervals on the same strand, the opposite or ignore strand
    information. The default, "auto", means use "same" if both PyRanges are stranded (see .strand_valid)
    otherwise ignore the strand information.

exclude_overlaps : bool, default True
    Whether to not report intervals of others that overlap with self as the nearest ones.

direction : {"any", "upstream", "downstream"}, default "any", i.e. both directions
    Whether to only look for nearest in one direction.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be matched.

k : int, default 1
    Number of nearest intervals to fetch.

suffix : str, default "_b"
    Suffix to give columns with shared name in other.

dist_col : str or None
    Optional column to store the distance in.

Returns
-------
PyRanges

    A PyRanges with columns representing nearest interval horizontally appended.

See Also
--------
PyRanges.join_overlaps : Has a slack argument to find intervals within a distance.

Examples
--------
>>> f1 = pr.example_data.f1.remove_nonloc_columns()
>>> f1
  index  |    Chromosome      Start      End  Strand
  int64  |    category        int64    int64  category
-------  ---  ------------  -------  -------  ----------
      0  |    chr1                3        6  +
      1  |    chr1                5        7  -
      2  |    chr1                8        9  +
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f2 = pr.PyRanges(dict(Chromosome="chr1", Start=[1, 6, 20], End=[2, 7, 22], Strand=["+", "-", "+"]))
>>> f2
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        2  +
      1  |    chr1                6        7  -
      2  |    chr1               20       22  +
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f1.nearest_ranges(f2)
  index  |    Chromosome      Start      End  Strand      Chromosome_b      Start_b    End_b  Strand_b      Distance
  int64  |    category        int64    int64  category    object              int64    int64  object           int64
-------  ---  ------------  -------  -------  ----------  --------------  ---------  -------  ----------  ----------
      0  |    chr1                3        6  +           chr1                    1        2  +                    2
      1  |    chr1                5        7  -           chr1                    6        7  -                    0
      2  |    chr1                8        9  +           chr1                    1        2  +                    7
PyRanges with 3 rows, 9 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f1.nearest_ranges(f2, strand_behavior='ignore')
  index  |    Chromosome      Start      End  Strand      Chromosome_b      Start_b    End_b  Strand_b      Distance
  int64  |    category        int64    int64  category    object              int64    int64  object           int64
-------  ---  ------------  -------  -------  ----------  --------------  ---------  -------  ----------  ----------
      0  |    chr1                3        6  +           chr1                    6        7  -                    1
      1  |    chr1                5        7  -           chr1                    6        7  -                    0
      2  |    chr1                8        9  +           chr1                    6        7  -                    2
PyRanges with 3 rows, 9 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f1.nearest_ranges(f2, k=2, strand_behavior='ignore')
  index  |    Chromosome      Start      End  Strand      Chromosome_b      Start_b    End_b  Strand_b      Distance
  int64  |    category        int64    int64  category    object              int64    int64  object           int64
-------  ---  ------------  -------  -------  ----------  --------------  ---------  -------  ----------  ----------
      0  |    chr1                3        6  +           chr1                    6        7  -                    1
      0  |    chr1                3        6  +           chr1                    1        2  +                    2
      1  |    chr1                5        7  -           chr1                    6        7  -                    0
      1  |    chr1                5        7  -           chr1                    1        2  +                    4
      2  |    chr1                8        9  +           chr1                    6        7  -                    2
      2  |    chr1                8        9  +           chr1                    1        2  +                    7
PyRanges with 6 rows, 9 columns, and 1 index columns (with 3 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> f1.nearest_ranges(f2, strand_behavior='ignore', exclude_overlaps=True)
  index  |    Chromosome      Start      End  Strand      Chromosome_b      Start_b    End_b  Strand_b      Distance
  int64  |    category        int64    int64  category    object              int64    int64  object           int64
-------  ---  ------------  -------  -------  ----------  --------------  ---------  -------  ----------  ----------
      0  |    chr1                3        6  +           chr1                    6        7  -                    1
      1  |    chr1                5        7  -           chr1                    1        2  +                    4
      2  |    chr1                8        9  +           chr1                    6        7  -                    2
PyRanges with 3 rows, 9 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> f1.nearest_ranges(f2, direction='downstream')
  index  |    Chromosome      Start      End  Strand      Chromosome_b      Start_b    End_b  Strand_b      Distance
  int64  |    category        int64    int64  category    object              int64    int64  object           int64
-------  ---  ------------  -------  -------  ----------  --------------  ---------  -------  ----------  ----------
      0  |    chr1                3        6  +           chr1                   20       22  +                   15
      2  |    chr1                8        9  +           chr1                   20       22  +                   12
      1  |    chr1                5        7  -           chr1                    6        7  -                    0
PyRanges with 3 rows, 9 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

If an input interval has no suitable nearest interval, these rows are dropped:

>>> f1.nearest_ranges(f2, direction='upstream', exclude_overlaps=True)
  index  |    Chromosome      Start      End  Strand      Chromosome_b      Start_b    End_b  Strand_b      Distance
  int64  |    category        int64    int64  category    object              int64    int64  object           int64
-------  ---  ------------  -------  -------  ----------  --------------  ---------  -------  ----------  ----------
      0  |    chr1                3        6  +           chr1                    1        2  +                    2
      2  |    chr1                8        9  +           chr1                    1        2  +                    7
PyRanges with 2 rows, 9 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.


####################################################################################################
PyRanges.outer_ranges()
#######################
Return the boundaries (the minimum start and end) of groups of intervals (e.g. transcripts).

Parameters
----------
group_by : str or list of str or None
    Name(s) of column(s) to group intervals (e.g. into multi-exon transcripts)
    If None, intervals are grouped by chromosome, and strand if present and valid (see .strand_valid).

use_strand: {"auto", True, False}, default: "auto"
    Whether to cluster only intervals on the same strand.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

Returns
-------
PyRanges
    One interval per group, with the min(Start) and max(End) of the group

See Also
--------
PyRanges.complement_ranges : return the internal complement of intervals, i.e. its introns.

Examples
--------
>>> gr = pr.PyRanges({"Chromosome": [1, 1, 1], "Start": [1, 60, 110], "End": [40, 68, 130],
...                   "transcript_id": ["tr1", "tr1", "tr2"], "meta": ["a", "b", "c"]})
>>>
>>> gr["Length"] = gr.lengths()
>>> gr
  index  |      Chromosome    Start      End  transcript_id    meta        Length
  int64  |           int64    int64    int64  object           object       int64
-------  ---  ------------  -------  -------  ---------------  --------  --------
      0  |               1        1       40  tr1              a               39
      1  |               1       60       68  tr1              b                8
      2  |               1      110      130  tr2              c               20
PyRanges with 3 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.outer_ranges("transcript_id")
  index  |      Chromosome    Start      End  transcript_id
  int64  |           int64    int64    int64  object
-------  ---  ------------  -------  -------  ---------------
      0  |               1        1       68  tr1
      1  |               1      110      130  tr2
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.outer_ranges()
  index  |      Chromosome    Start      End
  int64  |           int64    int64    int64
-------  ---  ------------  -------  -------
      0  |               1        1      130
PyRanges with 1 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.overlap()
##################
Return overlapping intervals.

Returns the intervals in self which overlap with those in other.

Parameters
----------
other : PyRanges
    PyRanges to find overlaps with.

strand_behavior : {"auto", "same", "opposite", "ignore"}, default "auto"
    Whether to consider overlaps of intervals on the same strand, the opposite or ignore strand
    information. The default, "auto", means use "same" if both PyRanges are stranded (see .strand_valid)
    otherwise ignore the strand information.

slack : int, default 0
    Intervals in self are temporarily extended by slack on both ends before overlap is calculated, so that
    we allow non-overlapping intervals to be considered overlapping if they are within less than slack distance
    e.g. slack=1 reports bookended intervals.

multiple : bool, default False
    What intervals to report when multiple intervals in 'other' overlap with the same interval in self.
    If True, each interval is reported once for every overlap, potentially resulting in duplicate indices.

contained_intervals_only : bool, default False
    Whether to report only intervals that are entirely contained in an interval of 'other'.

match_by : str or list, default None
    If provided, only overlapping intervals with an equal value in column(s) `match_by` are reported.

invert : bool, default False
    If True, return intervals that do not overlap instead, according to all criteria specified

Returns
-------
PyRanges

    A PyRanges with overlapping intervals.

See Also
--------
PyRanges.intersect_overlaps : report overlapping subintervals
PyRanges.set_intersect_overlaps : set-intersect PyRanges (e.g. merge then intersect)

Examples
--------
>>> gr = pr.PyRanges({"Chromosome": ["chr1", "chr1", "chr2", "chr1", "chr3"], "Start": [1, 1, 4, 10, 0],
...                    "End": [3, 3, 9, 11, 1], "ID": ["A", "a", "b", "c", "d"]})
>>> gr2 = pr.PyRanges({"Chromosome": ["chr1", "chr1", "chr2"], "Start": [2, 2, 1], "End": [3, 9, 10]})
>>> gr
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  A
      1  |    chr1                1        3  a
      2  |    chr2                4        9  b
      3  |    chr1               10       11  c
      4  |    chr3                0        1  d
PyRanges with 5 rows, 4 columns, and 1 index columns.
Contains 3 chromosomes.

>>> gr2
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                2        3
      1  |    chr1                2        9
      2  |    chr2                1       10
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 2 chromosomes.

>>> gr.overlap(gr2)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  A
      1  |    chr1                1        3  a
      2  |    chr2                4        9  b
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 2 chromosomes.

>>> gr.overlap(gr2, multiple=True)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  A
      0  |    chr1                1        3  A
      1  |    chr1                1        3  a
      1  |    chr1                1        3  a
      2  |    chr2                4        9  b
PyRanges with 5 rows, 4 columns, and 1 index columns (with 2 index duplicates).
Contains 2 chromosomes.

>>> gr.overlap(gr2, invert=True)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      3  |    chr1               10       11  c
      4  |    chr3                0        1  d
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 2 chromosomes.

>>> gr.overlap(gr2, slack=2)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  A
      1  |    chr1                1        3  a
      2  |    chr2                4        9  b
      3  |    chr1               10       11  c
PyRanges with 4 rows, 4 columns, and 1 index columns.
Contains 2 chromosomes.

>>> gr.overlap(gr2, slack=2, invert=True)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      4  |    chr3                0        1  d
PyRanges with 1 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.overlap(gr2, contained_intervals_only=True)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      2  |    chr2                4        9  b
PyRanges with 1 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.overlap(gr2, contained_intervals_only=True, invert=True)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  A
      1  |    chr1                1        3  a
      3  |    chr1               10       11  c
      4  |    chr3                0        1  d
PyRanges with 4 rows, 4 columns, and 1 index columns.
Contains 2 chromosomes.

>>> gr.overlap(gr2, contained_intervals_only=True, slack=-2)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  A
      1  |    chr1                1        3  a
      2  |    chr2                4        9  b
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 2 chromosomes.

>>> gr3 = pr.PyRanges({"Chromosome": 1, "Start": [2, 4], "End": [3, 5], "Strand": ["+", "-"]})
>>> gr3
  index  |      Chromosome    Start      End  Strand
  int64  |           int64    int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |               1        2        3  +
      1  |               1        4        5  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr4 = pr.PyRanges({"Chromosome": 1, "Start": [0], "End": [10], "Strand": ["-"]})
>>> gr3.overlap(gr4, strand_behavior="opposite")
  index  |      Chromosome    Start      End  Strand
  int64  |           int64    int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |               1        2        3  +
PyRanges with 1 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.


####################################################################################################
PyRanges.remove_nonloc_columns()
################################
Remove all columns that are not genome location columns (Chromosome, Start, End, Strand).

Examples
--------
>>> gr = pr.PyRanges({"Chromosome": [1], "Start": [895], "Strand": ["+"], "Score": [1], "Score2": [2], "End": [1259]})
>>> gr
  index  |      Chromosome    Start  Strand      Score    Score2      End
  int64  |           int64    int64  object      int64     int64    int64
-------  ---  ------------  -------  --------  -------  --------  -------
      0  |               1      895  +               1         2     1259
PyRanges with 1 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.
>>> gr.remove_nonloc_columns()
  index  |      Chromosome    Start      End  Strand
  int64  |           int64    int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |               1      895     1259  +
PyRanges with 1 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.


####################################################################################################
PyRanges.remove_strand()
########################
Return a copy with the Strand column removed.

Strand is removed regardless of whether it contains valid strand info.

See Also
--------
PyRanges.strand_valid : whether PyRanges has valid strand info
PyRanges.invert_strand : invert plus <-> minus Strand in all intervals

Examples
--------
>>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr1'], 'Start': [1, 6],
...                   'End': [5, 8], 'Strand': ['+', '-']})
>>> gr
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        5  +
      1  |    chr1                6        8  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.remove_strand()
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                1        5
      1  |    chr1                6        8
PyRanges with 2 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.set_intersect_overlaps()
#################################
Return set-theoretical intersection.

Like intersect_overlaps, but both PyRanges are merged first.

Parameters
----------
other : PyRanges
    PyRanges to set-intersect.

strand_behavior : {"auto", "same", "opposite", "ignore"}, default "auto"
    Whether to consider overlaps of intervals on the same strand, the opposite or ignore strand
    information. The default, "auto", means use "same" if both PyRanges are stranded (see .strand_valid)
    otherwise ignore the strand information.

multiple : {"all", "first", "last"}, default "all"
    What to report when multiple merged intervals in 'other' overlap with the same merged interval in self.
    The default "all" reports all overlapping subintervals.
    "first" reports only, for each merged self interval, the overlapping 'other' subinterval with smallest Start
    "last" reports only the overlapping subinterval with the biggest End in 'other'

Returns
-------
PyRanges
    A PyRanges with overlapping subintervals. Input index is not preserved.
    No columns other than Chromosome, Start, End, and optionally Strand are returned.

See Also
--------
PyRanges.set_union_overlaps : set-theoretical union
PyRanges.intersect_overlaps : find overlapping subintervals
PyRanges.overlap : report overlapping intervals
PyRanges.merge_overlaps : merge overlapping intervals

Examples
--------
>>> r1 = pr.PyRanges({"Chromosome": ["chr1"] * 3, "Start": [5, 20, 40],"End": [10, 30, 50], "ID": ["a", "b", "c"]})
>>> r1
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                5       10  a
      1  |    chr1               20       30  b
      2  |    chr1               40       50  c
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.


>>> r2 = pr.PyRanges({"Chromosome": ["chr1"] * 4, "Start": [7, 18, 25, 28], "End": [9, 22, 33, 32]})
>>> r2
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                7        9
      1  |    chr1               18       22
      2  |    chr1               25       33
      3  |    chr1               28       32
PyRanges with 4 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> r1.set_intersect_overlaps(r2, multiple='first')
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                7        9
      1  |    chr1               20       22
PyRanges with 2 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> r1.set_intersect_overlaps(r2)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                7        9
      1  |    chr1               20       22
      2  |    chr1               25       30
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.set_union_overlaps()
#############################
Return set-theoretical union.

Returns the regions present in either self or other.
Both PyRanges are merged first.

Parameters
----------
other : PyRanges
    PyRanges to do union with.

strand_behavior : {"auto", "same", "opposite", "ignore"}, default "auto"
    Whether to consider overlaps of intervals on the same strand, the opposite or ignore strand
    information. The default, "auto", means use "same" if both PyRanges are stranded (see .strand_valid)
    otherwise ignore the strand information.

Returns
-------
PyRanges
    A PyRanges with the union of intervals. Input index is not preserved.
    No columns other than Chromosome, Start, End, and optionally Strand are returned.

See Also
--------
PyRanges.set_intersect_overlaps : set-theoretical intersection
PyRanges.overlap : report overlapping intervals
PyRanges.merge_overlaps : merge overlapping intervals

Examples
--------
>>> gr = pr.PyRanges({"Chromosome": ["chr1"] * 3, "Start": [1, 4, 10],
...                    "End": [3, 9, 11], "ID": ["a", "b", "c"]})
>>> gr
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  a
      1  |    chr1                4        9  b
      2  |    chr1               10       11  c
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr2 = pr.PyRanges({"Chromosome": ["chr1"] * 3, "Start": [2, 2, 9], "End": [3, 9, 10]})
>>> gr2
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                2        3
      1  |    chr1                2        9
      2  |    chr1                9       10
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.set_union_overlaps(gr2)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                1        9
      1  |    chr1                9       10
      2  |    chr1               10       11
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

Merging bookended intervals:

>>> gr.set_union_overlaps(gr2).merge_overlaps(slack=1)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                1       11
PyRanges with 1 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.slice_ranges()
#######################
Return sub-intervals of `self`, cut according to *start* and *end*.

The slice window can be a single pair (scalar `start`, `end`) that is
applied to every row, **or** one value per row supplied as a 1-D sequence
or NumPy array.  When vectors are used their length must equal the number
of rows in `self`.

A positive coordinate is counted from the 5' end (left end on plus strand,
right end on minus strand).  A negative coordinate is counted from the 3'
end (for example `-1` is the last nucleotide).  `end=None` means ‚Äúup to
the 3' end‚Äù.

Parameters
----------
start : int or 1-D array-like of int, default 0
    Inclusive start offset.
end : int or 1-D array-like of int or None, default None
    Exclusive end offset.  None means the existing 3' end.
group_by : str or list of str, optional
    Column name(s) that define groups (for example exons in one
    transcript).  If given, slicing is performed on the spliced
    transcript; introns are ignored unless *count_introns* is True.
use_strand : {"auto", True, False}, default "auto"
    If True the 5'/3' logic honours the strand column.  If False every
    interval is treated as plus strand.  "auto" selects True when the
    PyRanges has valid strand information.
count_introns : bool, default False
    If False (default) `start` and `end` refer to spliced coordinates
    (introns ignored).  If True they refer to unspliced coordinates.

Returns
-------
PyRanges
    A new PyRanges object with the requested sub-intervals.

Notes
-----
* Out-of-bounds requests are silently truncated to the existing span.
* Negative offsets are resolved after the transcript length is known,
  so they always count from the 3' end of the (spliced or unspliced)
  interval in question.

See Also
--------
PyRanges.window_ranges : divide intervals into windows

Examples
--------
>>> p  = pr.PyRanges({"Chromosome": [1, 1, 2, 2, 3],
...                   "Strand": ["+", "+", "-", "-", "+"],
...                   "Start": [1, 40, 10, 70, 140],
...                   "End": [11, 60, 25, 80, 152],
...                   "transcript_id":["t1", "t1", "t2", "t2", "t3"] })
>>> p
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               1       11  t1
      1  |               1  +              40       60  t1
      2  |               2  -              10       25  t2
      3  |               2  -              70       80  t2
      4  |               3  +             140      152  t3
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Get the first 5 nucleotides of each interval, counting from the 5' end:

>>> p.slice_ranges(0, 5)
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               1        6  t1
      1  |               1  +              40       45  t1
      2  |               2  -              20       25  t2
      3  |               2  -              75       80  t2
      4  |               3  +             140      145  t3
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Get the last 10 nucleotides of each interval. End is omitted to get the existing 3' end:

>>> p.slice_ranges(-10)
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               1       11  t1
      1  |               1  +              50       60  t1
      2  |               2  -              10       20  t2
      3  |               2  -              70       80  t2
      4  |               3  +             142      152  t3
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Get the first 15 nucleotides of *each spliced transcript*, grouping exons by transcript_id:

>>> p.slice_ranges(0, 15, group_by='transcript_id')
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               1       11  t1
      1  |               1  +              40       45  t1
      2  |               2  -              20       25  t2
      3  |               2  -              70       80  t2
      4  |               3  +             140      152  t3
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Get the last 20 nucleotides of each spliced transcript:

>>> p.slice_ranges(-20, group_by='transcript_id')
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      1  |               1  +              40       60  t1
      2  |               2  -              10       25  t2
      3  |               2  -              70       75  t2
      4  |               3  +             140      152  t3
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Use use_strand=False to treat all intervals as if they were on the + strand:

>>> p.slice_ranges(0, 15, group_by='transcript_id', use_strand=False)
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               1       11  t1
      1  |               1  +              40       45  t1
      2  |               2  -              10       25  t2
      4  |               3  +             140      152  t3
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Get region from 25 to 60 of each spliced transcript, or their existing subportion:

>>> p.slice_ranges(25, 60, group_by='transcript_id')
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      1  |               1  +              55       60  t1
PyRanges with 1 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 1 strands.

Get region of each spliced transcript which excludes their first and last 3 nucleotides:

>>> p.slice_ranges(3, -3, group_by='transcript_id')
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               4       11  t1
      1  |               1  +              40       57  t1
      2  |               2  -              13       25  t2
      3  |               2  -              70       77  t2
      4  |               3  +             143      149  t3
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Considering input start,end to refer to the unspliced transcript, i.e. counting introns.
This fetches all interval portions that overlap with the first 50nt of each transcript:

>>> p.slice_ranges(0, 50, group_by='transcript_id', count_introns=True)
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               1       11  t1
      1  |               1  +              40       51  t1
      3  |               2  -              70       80  t2
      4  |               3  +             140      152  t3
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

>>> p.slice_ranges(0, 50, group_by='transcript_id', count_introns=True, use_strand=False)
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +               1       11  t1
      1  |               1  +              40       51  t1
      2  |               2  -              10       25  t2
      4  |               3  +             140      152  t3
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

>>> p.slice_ranges(-50, -5, group_by='transcript_id', count_introns=True)
  index  |      Chromosome  Strand      Start      End  transcript_id
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |               1  +              10       11  t1
      1  |               1  +              40       55  t1
      2  |               2  -              15       25  t2
      4  |               3  +             140      147  t3
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.


####################################################################################################
PyRanges.sort_ranges()
######################
Sort PyRanges according to Chromosome, Strand (if present), Start, and End; or by the specified columns.

If PyRanges is stranded and use_strand is True, intervals on the negative strand are sorted in descending
order, and End is considered before Start. This is to have a 5' to 3' order.
For uses not covered by this function, use  DataFrame.sort_values().

Parameters
----------
by : str or list of str, default None
    If provided, sorting occurs by Chromosome, Strand (if present), *by, Start, and End.

use_strand: {"auto", True, False}, default: "auto"
    Whether negative strand intervals should be sorted in descending order, meaning 5' to 3'.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

natsort : bool, default True
    Whether to use natural sorting for Chromosome column, so that e.g. chr2 < chr11.

Returns
-------
PyRanges

    Sorted PyRanges. The index is preserved. Use .reset_index(drop=True) to reset the index.

Examples
--------
>>> p = pr.PyRanges({"Chromosome": ["chr1", "chr1", "chr1", "chr1", "chr2", "chr11", "chr11", "chr1"],
...                  "Strand": ["+", "+", "-", "-", "+", "+", "+",  "+"],
...                  "Start": [40, 1, 10, 70, 300, 140, 160, 90],
...                  "End": [60, 11, 25, 80, 400, 152, 190, 100],
...                  "transcript_id":["t3", "t3", "t2", "t2", "t4", "t5", "t5", "t1"]})
>>> p
  index  |    Chromosome    Strand      Start      End  transcript_id
  int64  |    object        object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      0  |    chr1          +              40       60  t3
      1  |    chr1          +               1       11  t3
      2  |    chr1          -              10       25  t2
      3  |    chr1          -              70       80  t2
      4  |    chr2          +             300      400  t4
      5  |    chr11         +             140      152  t5
      6  |    chr11         +             160      190  t5
      7  |    chr1          +              90      100  t1
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

>>> p.sort_ranges(natsort=False)
  index  |    Chromosome    Strand      Start      End  transcript_id
  int64  |    object        object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      1  |    chr1          +               1       11  t3
      0  |    chr1          +              40       60  t3
      7  |    chr1          +              90      100  t1
      3  |    chr1          -              70       80  t2
      2  |    chr1          -              10       25  t2
      5  |    chr11         +             140      152  t5
      6  |    chr11         +             160      190  t5
      4  |    chr2          +             300      400  t4
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Do not sort negative strand intervals in descending order:

>>> p.sort_ranges(use_strand=False, natsort=False)
  index  |    Chromosome    Strand      Start      End  transcript_id
  int64  |    object        object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      1  |    chr1          +               1       11  t3
      0  |    chr1          +              40       60  t3
      7  |    chr1          +              90      100  t1
      2  |    chr1          -              10       25  t2
      3  |    chr1          -              70       80  t2
      5  |    chr11         +             140      152  t5
      6  |    chr11         +             160      190  t5
      4  |    chr2          +             300      400  t4
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Sort chromosomes in natural order:

>>> p.sort_ranges()
  index  |    Chromosome    Strand      Start      End  transcript_id
  int64  |    object        object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      1  |    chr1          +               1       11  t3
      0  |    chr1          +              40       60  t3
      7  |    chr1          +              90      100  t1
      3  |    chr1          -              70       80  t2
      2  |    chr1          -              10       25  t2
      4  |    chr2          +             300      400  t4
      5  |    chr11         +             140      152  t5
      6  |    chr11         +             160      190  t5
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Sort by 'transcript_id' before than by columns Start and End (but after Chromosome and Strand):

>>> p.sort_ranges(by='transcript_id', natsort=False)
  index  |    Chromosome    Strand      Start      End  transcript_id
  int64  |    object        object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      7  |    chr1          +              90      100  t1
      1  |    chr1          +               1       11  t3
      0  |    chr1          +              40       60  t3
      3  |    chr1          -              70       80  t2
      2  |    chr1          -              10       25  t2
      5  |    chr11         +             140      152  t5
      6  |    chr11         +             160      190  t5
      4  |    chr2          +             300      400  t4
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Sort by 'transcript_id' before than by columns Strand, Start and End:

>>> res = p.sort_ranges(natsort=False)
>>> res.sort_values("transcript_id", kind="stable")
  index  |    Chromosome    Strand      Start      End  transcript_id
  int64  |    object        object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      7  |    chr1          +              90      100  t1
      3  |    chr1          -              70       80  t2
      2  |    chr1          -              10       25  t2
      1  |    chr1          +               1       11  t3
      0  |    chr1          +              40       60  t3
      4  |    chr2          +             300      400  t4
      5  |    chr11         +             140      152  t5
      6  |    chr11         +             160      190  t5
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.

Same as before, but 'transcript_id' is sorted in descending order:

>>> res = p.sort_ranges(natsort=False)
>>> res.sort_values("transcript_id", kind="stable", ascending=False)
  index  |    Chromosome    Strand      Start      End  transcript_id
  int64  |    object        object      int64    int64  object
-------  ---  ------------  --------  -------  -------  ---------------
      5  |    chr11         +             140      152  t5
      6  |    chr11         +             160      190  t5
      4  |    chr2          +             300      400  t4
      1  |    chr1          +               1       11  t3
      0  |    chr1          +              40       60  t3
      3  |    chr1          -              70       80  t2
      2  |    chr1          -              10       25  t2
      7  |    chr1          +              90      100  t1
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 3 chromosomes and 2 strands.


####################################################################################################
PyRanges.split_overlaps()
#########################
Split into non-overlapping intervals.

The output does not contain overlapping intervals, but intervals that are adjacent are not merged.
No columns other than Chromosome, Start, End, and Strand (if present) are output.

Parameters
----------
use_strand: {"auto", True, False}, default: "auto"
    Whether to split only intervals on the same strand.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

between : bool, default False
    Output also intervals corresponding to the gaps between the intervals in self.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be split.

Returns
-------
PyRanges

    PyRanges with intervals split at overlap points.

See Also
--------
PyRanges.merge_overlaps : merge overlapping intervals
PyRanges.max_disjoint_overlaps : find the maximal disjoint set of intervals

Examples
--------
>>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1', 'chr1'], 'Start': [3, 5, 5, 11],
...                   'End': [6, 9, 7, 12], 'Strand': ['+', '+', '-', '-']})
>>> gr
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                3        6  +
      1  |    chr1                5        9  +
      2  |    chr1                5        7  -
      3  |    chr1               11       12  -
PyRanges with 4 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.split_overlaps()
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                3        5  +
      1  |    chr1                5        6  +
      2  |    chr1                6        9  +
      3  |    chr1                5        7  -
      4  |    chr1               11       12  -
PyRanges with 5 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.split_overlaps(between=True)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                3        5  +
      1  |    chr1                5        6  +
      2  |    chr1                6        9  +
      3  |    chr1                5        7  -
      4  |    chr1                7       11  -
      5  |    chr1               11       12  -
PyRanges with 6 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.split_overlaps(use_strand=False)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                3        5
      1  |    chr1                5        6
      2  |    chr1                6        7
      3  |    chr1                7        9
      4  |    chr1               11       12
PyRanges with 5 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.split_overlaps(use_strand=False, between=True)
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                3        5
      1  |    chr1                5        6
      2  |    chr1                6        7
      3  |    chr1                7        9
      4  |    chr1                9       11
      5  |    chr1               11       12
PyRanges with 6 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr['ID'] = ['a', 'b', 'a', 'c']
>>> gr
  index  |    Chromosome      Start      End  Strand    ID
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                3        6  +         a
      1  |    chr1                5        9  +         b
      2  |    chr1                5        7  -         a
      3  |    chr1               11       12  -         c
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.split_overlaps(use_strand=False, match_by='ID')
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                3        5  a
      1  |    chr1                5        6  a
      2  |    chr1                6        7  a
      3  |    chr1                5        9  b
      4  |    chr1               11       12  c
PyRanges with 5 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.subtract_overlaps()
############################
Subtract intervals, i.e. return non-overlapping subintervals.

Identify intervals in other that overlap with intervals in self; return self with the overlapping parts removed.

Parameters
----------
other:
    PyRanges to subtract.

strand_behavior: "auto", "same", "opposite", "ignore"
    How to handle strand information. "auto" means use "same" if both PyRanges are stranded,
    otherwise ignore the strand information. "same" means only subtract intervals on the same strand.
    "opposite" means only subtract intervals on the opposite strand. "ignore" means ignore strand

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

Returns
-------
PyRanges
    PyRanges with subintervals from self that do not overlap with any interval in other.
    Columns and index are preserved.

Warning
-------
The returned Pyranges may have index duplicates. Call .reset_index(drop=True) to fix it.

See Also
--------
PyRanges.overlap : use with invert=True to return all intervals without overlap
PyRanges.complement_ranges : return the internal complement of intervals, i.e. its introns.

Examples
--------
>>> gr = pr.PyRanges({"Chromosome": ["chr1"] * 3, "Start": [1, 4, 10],
...                    "End": [3, 9, 11], "ID": ["a", "b", "c"]})
>>> gr2 = pr.PyRanges({"Chromosome": ["chr1"] * 3, "Start": [2, 2, 9], "End": [3, 9, 10]})
>>> gr
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        3  a
      1  |    chr1                4        9  b
      2  |    chr1               10       11  c
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr2
  index  |    Chromosome      Start      End
  int64  |    object          int64    int64
-------  ---  ------------  -------  -------
      0  |    chr1                2        3
      1  |    chr1                2        9
      2  |    chr1                9       10
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.subtract_overlaps(gr2)
  index  |    Chromosome      Start      End  ID
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                1        2  a
      2  |    chr1               10       11  c
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr['tag'] = ['x', 'y', 'z']
>>> gr2['tag'] = ['x', 'w', 'z']
>>> gr
  index  |    Chromosome      Start      End  ID        tag
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                1        3  a         x
      1  |    chr1                4        9  b         y
      2  |    chr1               10       11  c         z
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr2
  index  |    Chromosome      Start      End  tag
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1                2        3  x
      1  |    chr1                2        9  w
      2  |    chr1                9       10  z
PyRanges with 3 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.subtract_overlaps(gr2, match_by="tag")
  index  |    Chromosome      Start      End  ID        tag
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                1        2  a         x
      1  |    chr1                4        9  b         y
      2  |    chr1               10       11  c         z
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.summary()
##################
Return a summary of info regarding this PyRanges object.

In output, the row "count" refers to thenumber of intervals and "sum" to their total length.
The rest describe the distribution of lengths of the intervals.

The column "pyrange" describes the data as is. "coverage_forward" and "coverage_reverse"
describe the data after strand-specific merging of overlapping intervals.
"coverage_unstranded" describes the data after merging, without considering the strands.


Parameters
----------
return_df : bool, default False
    Return df with summary.

Returns
-------
    None or pd.DataFrame with summary.


Examples
--------
>>> gr = pr.example_data.ensembl_gtf.get_with_loc_columns(["Feature", "gene_id"])
>>> gr
index    |    Chromosome    Start    End      Strand      Feature     gene_id
int64    |    category      int64    int64    category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  ---------------
0        |    1             11868    14409    +           gene        ENSG00000223972
1        |    1             11868    14409    +           transcript  ENSG00000223972
2        |    1             11868    12227    +           exon        ENSG00000223972
3        |    1             12612    12721    +           exon        ENSG00000223972
...      |    ...           ...      ...      ...         ...         ...
7        |    1             120724   133723   -           transcript  ENSG00000238009
8        |    1             133373   133723   -           exon        ENSG00000238009
9        |    1             129054   129223   -           exon        ENSG00000238009
10       |    1             120873   120932   -           exon        ENSG00000238009
PyRanges with 11 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.summary()
         pyrange    coverage_forward    coverage_reverse    coverage_unstranded
-----  ---------  ------------------  ------------------  ---------------------
count      11                      1                3                      4
mean     1893.27                2541             4503                   4012.5
std      3799.24                 nan             7359.28                6088.38
min        59                   2541              105                    105
25%       139                   2541              255                    330
50%       359                   2541              405                   1473
75%      1865                   2541             6702                   5155.5
max     12999                   2541            12999                  12999
sum     20826                   2541            13509                  16050

>>> gr.summary(return_df=True)
            pyrange  coverage_forward  coverage_reverse  coverage_unstranded
count     11.000000               1.0          3.000000             4.000000
mean    1893.272727            2541.0       4503.000000          4012.500000
std     3799.238610               NaN       7359.280671          6088.379834
min       59.000000            2541.0        105.000000           105.000000
25%      139.000000            2541.0        255.000000           330.000000
50%      359.000000            2541.0        405.000000          1473.000000
75%     1865.000000            2541.0       6702.000000          5155.500000
max    12999.000000            2541.0      12999.000000         12999.000000
sum    20826.000000            2541.0      13509.000000         16050.000000


####################################################################################################
PyRanges.three_end()
####################
Return the three prime end of intervals.

The three prime end is the end of a forward strand or the start of a reverse strand.
All returned intervals have length of 1.

Parameters
----------
group_by : str or list of str, default: None
    Optional column name(s). If provided, the three prime end is calculated for each
    group of intervals (e.g. for each transcript).

ext : int, default 0
    Lengthen the resulting intervals on both ends by this amount.

Returns
-------
PyRanges
    PyRanges with the three prime ends

See Also
--------
PyRanges.upstream : return regions upstream of input intervals or transcripts
PyRanges.five_end : return the 5' end of intervals or transcripts
PyRanges.extend_ranges : return intervals or transcripts extended at one or both ends

Examples
--------
>>> gr = pr.PyRanges({'Chromosome': ['chr1', 'chr1', 'chr1'], 'Start': [3, 10, 5], 'End': [9, 14, 7],
...                    'Strand': ["+", "+", "-"], 'Name': ['a', 'a', 'b']})
>>> gr
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                3        9  +         a
      1  |    chr1               10       14  +         a
      2  |    chr1                5        7  -         b
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.three_end()
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                8        9  +         a
      1  |    chr1               13       14  +         a
      2  |    chr1                5        6  -         b
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.three_end(group_by='Name')
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      1  |    chr1               13       14  +         a
      2  |    chr1                5        6  -         b
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.three_end(group_by='Name', ext=1)
  index  |    Chromosome      Start      End  Strand    Name
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      1  |    chr1               12       15  +         a
      2  |    chr1                4        7  -         b
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.tile_ranges()
######################
Return overlapping genomic tiles.

The genome is divided into bookended tiles of length `tile_size`. One tile is returned for each
interval that overlaps with it, including any metadata from the original intervals.

Parameters
----------
tile_size : int
    Length of the tiles.

overlap_column : str, default None
    Name of column to add with the overlap between each bookended tile.

use_strand: {"auto", True, False}, default: "auto"
    Whether negative strand intervals should be windowed in reverse order.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

match_by : str | Sequence[str] | None, default None
    Column name(s) used to form groups when iterating rows. For `tile`,
    grouping does **not** change which tiles are produced or their overlap
    fractions: tiles are always taken from a fixed genomic grid with step
    `tile_size` (boundaries at multiples of `tile_size`), and each interval is
    intersected with that grid independently. Group boundaries only affect
    iteration order; there is no cross-interval ‚Äúcarry‚Äù for `tile`.

Returns
-------
PyRanges

    Tiled PyRanges.

Warning
-------
The returned Pyranges may have index duplicates. Call .reset_index(drop=True) to fix it.



See Also
--------
PyRanges.window_ranges : divide intervals into windows
pyranges.tile_genome : divide the genome into tiles


Examples
--------
>>> gr = pr.example_data.ensembl_gtf.get_with_loc_columns(["Feature", "gene_name"])
>>> gr
index    |    Chromosome    Start    End      Strand      Feature     gene_name
int64    |    category      int64    int64    category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  -----------
0        |    1             11868    14409    +           gene        DDX11L1
1        |    1             11868    14409    +           transcript  DDX11L1
2        |    1             11868    12227    +           exon        DDX11L1
3        |    1             12612    12721    +           exon        DDX11L1
...      |    ...           ...      ...      ...         ...         ...
7        |    1             120724   133723   -           transcript  AL627309.1
8        |    1             133373   133723   -           exon        AL627309.1
9        |    1             129054   129223   -           exon        AL627309.1
10       |    1             120873   120932   -           exon        AL627309.1
PyRanges with 11 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.tile_ranges(200)
index    |    Chromosome    Start    End      Strand      Feature     gene_name
int64    |    category      int64    int64    category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  -----------
0        |    1             11800    12000    +           gene        DDX11L1
0        |    1             12000    12200    +           gene        DDX11L1
0        |    1             12200    12400    +           gene        DDX11L1
0        |    1             12400    12600    +           gene        DDX11L1
...      |    ...           ...      ...      ...         ...         ...
8        |    1             133600   133800   -           exon        AL627309.1
9        |    1             129000   129200   -           exon        AL627309.1
9        |    1             129200   129400   -           exon        AL627309.1
10       |    1             120800   121000   -           exon        AL627309.1
PyRanges with 116 rows, 6 columns, and 1 index columns (with 105 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> gr.tile_ranges(100, overlap_column="TileOverlap")
index    |    Chromosome    Start    End      Strand      Feature     gene_name    TileOverlap
int64    |    category      int64    int64    category    category    object       float64
-------  ---  ------------  -------  -------  ----------  ----------  -----------  -------------
0        |    1             11800    11900    +           gene        DDX11L1      0.32
0        |    1             11900    12000    +           gene        DDX11L1      1.0
0        |    1             12000    12100    +           gene        DDX11L1      1.0
0        |    1             12100    12200    +           gene        DDX11L1      1.0
...      |    ...           ...      ...      ...         ...         ...          ...
9        |    1             129100   129200   -           exon        AL627309.1   1.0
9        |    1             129200   129300   -           exon        AL627309.1   0.23
10       |    1             120800   120900   -           exon        AL627309.1   0.27
10       |    1             120900   121000   -           exon        AL627309.1   0.32
PyRanges with 223 rows, 7 columns, and 1 index columns (with 212 index duplicates).
Contains 1 chromosomes and 2 strands.


####################################################################################################
PyRanges.to_bed()
#################
Write to bed.

Parameters
----------
path : str, default None
    Where to write. If None, returns string representation.

keep : bool, default True
    Whether to keep all columns, not just Chromosome, Start, End,
    Name, Score, Strand when writing.

compression : str, compression type to use, by default infer based on extension.
    See pandas.DataFree.to_csv for more info.

Examples
--------
>>> d =  {'Chromosome': ['chr1', 'chr1'], 'Start': [1, 6],
...       'End': [5, 8], 'Strand': ['+', '-'], "Gene": [1, 2]}
>>> gr = pr.PyRanges(d)
>>> gr
  index  |    Chromosome      Start      End  Strand       Gene
  int64  |    object          int64    int64  object      int64
-------  ---  ------------  -------  -------  --------  -------
      0  |    chr1                1        5  +               1
      1  |    chr1                6        8  -               2
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.to_bed()
'chr1\t1\t5\t.\t.\t+\t1\nchr1\t6\t8\t.\t.\t-\t2\n'

File contents::

    chr1        1       5       .       .       +       1
    chr1        6       8       .       .       -       2

Does not include noncanonical bed-column `Gene`:

>>> gr.to_bed(keep=False)
'chr1\t1\t5\t.\t.\t+\nchr1\t6\t8\t.\t.\t-\n'

File contents::

    chr1        1       5       .       .       +
    chr1        6       8       .       .       -

>>> gr.to_bed("test.bed")

>>> open("test.bed").readlines()
['chr1\t1\t5\t.\t.\t+\t1\n', 'chr1\t6\t8\t.\t.\t-\t2\n']


####################################################################################################
PyRanges.to_bigwig()
####################
Compute coverage (interval-based, or using a numerical value column) and write to bigwig.

Computes a score per position; by default, it is the number of intervals spanning that position.
If value_col is provided, the score is the sum of values of all intervals spanning that position.
The score per position is then reduced to a minimal number of ranges with constant coverage
(i.e. like a run-length encoding), and written in bigwig format to the provided path.

Note
----
To create one bigwig per strand, subset the PyRanges first into two separate objects (positive and negative strands).

Parameters
----------
path : str | None, default None
    Where to write bigwig. If None, return_data must be True.

chromosome_sizes : PyRanges or dict or None, default None
    Chromosome sizes to use. If provided, the output bigwig will span the entire chromosomes as given here.
    If dict, it must be a map of chromosome names to chromosome length.
    If a PyRanges, it must have 'Chromosome' and 'End' columns, where 'End' gives the chromosome length.
    If None, the maximum end position per chromosome in the input PyRanges is used.

value_col : str, default None
    Name of column to compute coverage of.
    If None, compute coverage (i.e. number of intervals spanning each position).

rpm : True
    Whether to normalize data by dividing by total number of intervals and multiplying by
    1e6.

divide : bool, default False
    (Only useful with value_col) Divide value coverage by regular coverage and take log2.

return_data : bool, default False
    Whether to return the data that would be written to bigwig as a PyRanges.

Note
----

Requires pybigwig and pyrle to be installed.


Examples
--------
>>> d =  {'Chromosome': ['chr1', 'chr1', 'chr1'], 'Start': [1, 4, 6],
...       'End': [7, 8, 10], 'Strand': ['+', '-', '-'],
...       'Value': [10, 20, 30]}
>>> gr = pr.PyRanges(d)
>>> gr
  index  |    Chromosome      Start      End  Strand      Value
  int64  |    object          int64    int64  object      int64
-------  ---  ------------  -------  -------  --------  -------
      0  |    chr1                1        7  +              10
      1  |    chr1                4        8  -              20
      2  |    chr1                6       10  -              30
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr.to_bigwig(return_data=True, rpm=False)
  index  |    Chromosome      Start      End      Score
  int64  |    category        int64    int64    float64
-------  ---  ------------  -------  -------  ---------
      1  |    chr1                1        4          1
      2  |    chr1                4        6          2
      3  |    chr1                6        7          3
      4  |    chr1                7        8          2
      5  |    chr1                8       10          1
PyRanges with 5 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.to_bigwig(return_data=True, rpm=False, value_col="Value")
  index  |    Chromosome      Start      End      Score
  int64  |    category        int64    int64    float64
-------  ---  ------------  -------  -------  ---------
      1  |    chr1                1        4         10
      2  |    chr1                4        6         30
      3  |    chr1                6        7         60
      4  |    chr1                7        8         50
      5  |    chr1                8       10         30
PyRanges with 5 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.to_bigwig(return_data=True, rpm=False, value_col="Value", divide=True)
  index  |    Chromosome      Start      End      Score
  int64  |    category        int64    int64    float64
-------  ---  ------------  -------  -------  ---------
      0  |    chr1                0        1  nan
      1  |    chr1                1        4    3.32193
      2  |    chr1                4        6    3.90689
      3  |    chr1                6        7    4.32193
      4  |    chr1                7        8    4.64386
      5  |    chr1                8       10    4.90689
PyRanges with 6 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes.


####################################################################################################
PyRanges.to_gff3()
##################
Write to General Feature Format 3.

The GFF format consists of a tab-separated file without header.
GFF contains a fixed amount of columns, indicated below (names before ":").
For each of these, PyRanges will use the corresponding column (names after ":").

* seqname: Chromosome
* source: Source
* feature: Feature
* start: Start
* end: End
* score: Score
* strand: Strand
* phase: Frame
* attribute: auto-filled

Columns which are not mapped to GFF columns are appended as a field
in the ``attribute`` string (i.e. the last field).

Parameters
----------
path : str, default None, i.e. return string representation.
    Where to write file.

compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default "infer"
    Which compression to use. Uses file extension to infer by default.

map_cols: dict, default None
    Override mapping between GTF and PyRanges fields for any number of columns.
    Format: ``{gtf_column : pyranges_column}``
    If a mapping is found for the "attribute"` column, it is not auto-filled


Note
----
Nonexisting columns will be added with a '.' to represent the missing values.

See Also
--------
pyranges.read_gff3 : read GFF3 files
pyranges.to_gtf : write to GTF format

Examples
--------
>>> d = {"Chromosome": [1] * 3, "Start": [1, 3, 5], "End": [4, 6, 9], "Feature": ["gene", "exon", "exon"]}
>>> gr = pr.PyRanges(d)
>>> gr.to_gff3()
'1\t.\tgene\t2\t4\t.\t.\t.\t\n1\t.\texon\t4\t6\t.\t.\t.\t\n1\t.\texon\t6\t9\t.\t.\t.\t\n'

How the file would look::

    1   .       gene    2       4       .       .       .
    1   .       exon    4       6       .       .       .
    1   .       exon    6       9       .       .       .

>>> gr["Gene"] = [1, 2, 3]
>>> gr["function"] = ["a b", "c", "def"]
>>> gr.to_gff3()
'1\t.\tgene\t2\t4\t.\t.\t.\tGene=1;function=a b\n1\t.\texon\t4\t6\t.\t.\t.\tGene=2;function=c\n1\t.\texon\t6\t9\t.\t.\t.\tGene=3;function=def\n'

How the file would look::

    1   .       gene    2       4       .       .       .       Gene=1;function=a b
    1   .       exon    4       6       .       .       .       Gene=2;function=c
    1   .       exon    6       9       .       .       .       Gene=3;function=def

>>> gr["phase"] = [0, 2, 1]
>>> gr["Feature"] = ['mRNA', 'CDS', 'CDS']
>>> gr
  index  |      Chromosome    Start      End  Feature       Gene  function      phase
  int64  |           int64    int64    int64  object       int64  object        int64
-------  ---  ------------  -------  -------  ---------  -------  ----------  -------
      0  |               1        1        4  mRNA             1  a b               0
      1  |               1        3        6  CDS              2  c                 2
      2  |               1        5        9  CDS              3  def               1
PyRanges with 3 rows, 7 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.to_gff3()
'1\t.\tmRNA\t2\t4\t.\t.\t0\tGene=1;function=a b\n1\t.\tCDS\t4\t6\t.\t.\t2\tGene=2;function=c\n1\t.\tCDS\t6\t9\t.\t.\t1\tGene=3;function=def\n'

How the file would look::

    1   .       mRNA    2       4       .       .       0       Gene=1;function=a b
    1   .       CDS     4       6       .       .       2       Gene=2;function=c
    1   .       CDS     6       9       .       .       1       Gene=3;function=def

>>> gr['custom'] = ['AA', 'BB', 'CC']
>>> gr
  index  |      Chromosome    Start      End  Feature       Gene  function      phase  custom
  int64  |           int64    int64    int64  object       int64  object        int64  object
-------  ---  ------------  -------  -------  ---------  -------  ----------  -------  --------
      0  |               1        1        4  mRNA             1  a b               0  AA
      1  |               1        3        6  CDS              2  c                 2  BB
      2  |               1        5        9  CDS              3  def               1  CC
PyRanges with 3 rows, 8 columns, and 1 index columns.
Contains 1 chromosomes.

>>> print(gr.to_gff3(map_cols={"feature": "custom"})) # doctest: +NORMALIZE_WHITESPACE
1       .       AA      2       4       .       .       0       Feature=mRNA;Gene=1;function=a b
1       .       BB      4       6       .       .       2       Feature=CDS;Gene=2;function=c
1       .       CC      6       9       .       .       1       Feature=CDS;Gene=3;function=def
<BLANKLINE>

>>> print(gr.to_gff3(map_cols={"attribute": "custom"})) # doctest: +NORMALIZE_WHITESPACE
1       .       mRNA    2       4       .       .       0       AA
1       .       CDS     4       6       .       .       2       BB
1       .       CDS     6       9       .       .       1       CC
<BLANKLINE>


####################################################################################################
PyRanges.to_gtf()
#################
Write to Gene Transfer Format.

The GTF format consists of a tab-separated file without header.
It contains a fixed amount of columns, indicated below (names before ":").
For each of these, PyRanges will use the corresponding column (names after ":").

* seqname: Chromosome
* source: Source
* feature: Feature
* start: Start
* end: End
* score: Score
* strand: Strand
* frame: Frame
* attribute: auto-filled

Columns which are not mapped to GTF columns are appended as a field
in the ``attribute`` string (i.e. the last field).

Parameters
----------
path : str, default None, i.e. return string representation.
    Where to write file.

compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default "infer"
    Which compression to use. Uses file extension to infer by default.

map_cols: dict, default None
    Override mapping between GTF and PyRanges fields for any number of columns.
    Format: ``{gtf_column : pyranges_column}``
    If a mapping is found for the "attribute"` column, it is not auto-filled

Note
----
Nonexisting columns will be added with a '.' to represent the missing values.

See Also
--------
pyranges.read_gtf : read GTF files
pyranges.to_gff3 : write to GFF3 format

Examples
--------
>>> d = {"Chromosome": [1] * 3, "Start": [1, 3, 5], "End": [4, 6, 9], "Feature": ["gene", "exon", "exon"]}
>>> gr = pr.PyRanges(d)
>>> gr.to_gtf()  # the raw string output
'1\t.\tgene\t2\t4\t.\t.\t.\t\n1\t.\texon\t4\t6\t.\t.\t.\t\n1\t.\texon\t6\t9\t.\t.\t.\t\n'

What the file contents look like::

    1   .       gene    2       4       .       .       .
    1   .       exon    4       6       .       .       .
    1   .       exon    6       9       .       .       .

>>> gr.Feature = ["GENE", "EXON", "EXON"]
>>> gr.to_gtf()  # the raw string output
'1\t.\tGENE\t2\t4\t.\t.\t.\t\n1\t.\tEXON\t4\t6\t.\t.\t.\t\n1\t.\tEXON\t6\t9\t.\t.\t.\t\n'

The file would look like::

    1   .       GENE    2       4       .       .       .
    1   .       EXON    4       6       .       .       .
    1   .       EXON    6       9       .       .       .

>>> gr["tag"] = [11, 22, 33]
>>> gr
  index  |      Chromosome    Start      End  Feature        tag
  int64  |           int64    int64    int64  object       int64
-------  ---  ------------  -------  -------  ---------  -------
      0  |               1        1        4  GENE            11
      1  |               1        3        6  EXON            22
      2  |               1        5        9  EXON            33
PyRanges with 3 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes.

>>> print(gr.to_gff3()) # doctest: +NORMALIZE_WHITESPACE
1       .       GENE    2       4       .       .       .       tag=11
1       .       EXON    4       6       .       .       .       tag=22
1       .       EXON    6       9       .       .       .       tag=33
<BLANKLINE>

>>> print(gr.to_gff3(map_cols={'seqname':'tag'})) # doctest: +NORMALIZE_WHITESPACE
11      .       GENE    2       4       .       .       .       Chromosome=1
22      .       EXON    4       6       .       .       .       Chromosome=1
33      .       EXON    6       9       .       .       .       Chromosome=1
<BLANKLINE>

>>> print(gr.to_gff3(map_cols={'attribute':'tag'})) # doctest: +NORMALIZE_WHITESPACE
1       .       GENE    2       4       .       .       .       11
1       .       EXON    4       6       .       .       .       22
1       .       EXON    6       9       .       .       .       33
<BLANKLINE>


####################################################################################################
PyRanges.to_rle()
#################
Return as Rledict.

Create collection of Rles representing the coverage or other numerical value.

Parameters
----------
value_col : str, default None
    Numerical column to create Rledict from.

strand : bool, default None, i.e. auto
    Whether to treat strands serparately.

rpm : bool, default False
    Normalize by multiplying with `1e6/(number_intervals)`.

Returns
-------
pyrle.Rledict

    Rle with coverage or other info from the PyRanges.


####################################################################################################
PyRanges.upstream()
###################
Return regions upstream (at the 5' side) of input intervals.

Parameters
----------
length : int
    Size of the region (bp), **> 0**.
gap : int, default 0
    Distance between region and input intervals; use negative to include some overlap.
group_by : str or list of str or None
    Name(s) of column(s) to group intervals. If provided, one region per group (e.g. transcript) is returned.
use_strand: {"auto", True, False}, default: "auto"
    Whether to consider strand; if so, the upstream window of negative intervals is on their right.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

See Also
--------
PyRanges.downstream : return regions downstream of input intervals or transcripts
PyRanges.five_end : return the 5' end of intervals or transcripts
PyRanges.extend_ranges : return intervals or transcripts extended at one or both ends
PyRanges.slice_ranges : obtain subsequences of intervals, providing transcript-level coordinates

Examples
--------
>>> a = pr.PyRanges({'Chromosome':['chr1','chr1'],
...                  'Start':[100,200],'End':[120,220],
...                  'Strand':['+','-']})
>>> a
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1              100      120  +
      1  |    chr1              200      220  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Default window (10 bp) right at the border:

>>> a.upstream(10)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1               90      100  +
      1  |    chr1              220      230  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

With a 5 bp gap:

>>> a.upstream(10, gap=5)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1               85       95  +
      1  |    chr1              225      235  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

With a 5 bp overlap (negative gap):

>>> a.upstream(10, gap=-5)
  index  |    Chromosome      Start      End  Strand
  int64  |    object          int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |    chr1               95      105  +
      1  |    chr1              215      225  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Transcript-aware example (two 2-exon transcripts):

>>> ex = pr.PyRanges({'Chromosome':['chr1']*4,
...                   'Start':[0,10,30,50],'End':[5,15,40,60],
...                   'Strand':['+','+','-','-'],
...                   'Tx':['tx1','tx1','tx2','tx2']})
>>> ex
  index  |    Chromosome      Start      End  Strand    Tx
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1                0        5  +         tx1
      1  |    chr1               10       15  +         tx1
      2  |    chr1               30       40  -         tx2
      3  |    chr1               50       60  -         tx2
PyRanges with 4 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

Note that upstream regions may extend beyond the start of the chromosome, resulting in invalid ranges.
See clip_ranges() to fix this.

>>> ex.upstream(5, group_by='Tx')
  index  |    Chromosome      Start      End  Strand    Tx
  int64  |    object          int64    int64  object    object
-------  ---  ------------  -------  -------  --------  --------
      0  |    chr1               -5        0  +         tx1
      3  |    chr1               60       65  -         tx2
PyRanges with 2 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.
Invalid ranges:
  * 1 starts or ends are < 0. See indexes: 0


####################################################################################################
PyRanges.window_ranges()
########################
Return intervals sliced in non-overlapping windows.

Every interval is split into windows of length `window_size` starting from its 5' end.

Parameters
----------
window_size : int
    Length of the windows.

use_strand: {"auto", True, False}, default: "auto"
    Whether negative strand intervals should be sliced in descending order, meaning 5' to 3'.
    The default "auto" means True if PyRanges has valid strands (see .strand_valid).

group_by : str | Sequence[str] | None, default None
    Column name(s) used to form groups. If provided, windowing proceeds
    *continuously within each group*: any leftover (partial) window at the end
    of one interval is continued at the start of the next interval with the
    same `group_by` value. The window ‚Äúphase‚Äù resets at group boundaries.

add_window_id : bool, default False
    Use only in combination with group_by. If True, adds a column "window_id" with an index-like identifier
    to link the windows split in non-contigous intervals, e.g. because a certain window spans an intron.
    The window_id starts at 0, and resets for each group.

Returns
-------
PyRanges

    Sliding window PyRanges.

Warning
-------
The returned Pyranges may have index duplicates. Call .reset_index(drop=True) to fix it.
Moreover, the input row order may not be preserved.

See Also
--------
PyRanges.tile_ranges : divide intervals into adjacent tiles.

Examples
--------
>>> import pyranges as pr
>>> gr = pr.PyRanges({"Chromosome": [1], "Start": [800], "End": [1012]})
>>> gr
  index  |      Chromosome    Start      End
  int64  |           int64    int64    int64
-------  ---  ------------  -------  -------
      0  |               1      800     1012
PyRanges with 1 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

>>> gr.window_ranges(100)
  index  |      Chromosome    Start      End
  int64  |           int64    int64    int64
-------  ---  ------------  -------  -------
      0  |               1      800      900
      0  |               1      900     1000
      0  |               1     1000     1012
PyRanges with 3 rows, 3 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes.

>>> gr.window_ranges(100).reset_index(drop=True)
  index  |      Chromosome    Start      End
  int64  |           int64    int64    int64
-------  ---  ------------  -------  -------
      0  |               1      800      900
      1  |               1      900     1000
      2  |               1     1000     1012
PyRanges with 3 rows, 3 columns, and 1 index columns.
Contains 1 chromosomes.

Negative strand intervals are sliced in descending order by default:

>>> gs = pr.PyRanges({"Chromosome": [1, 1], "Start": [200, 600], "End": [332, 787], "Strand":['+', '-']})
>>> gs
  index  |      Chromosome    Start      End  Strand
  int64  |           int64    int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |               1      200      332  +
      1  |               1      600      787  -
PyRanges with 2 rows, 4 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> w = gs.window_ranges(100)
>>> w['lengths'] = w.lengths() # add lengths column to see the length of the windows
>>> w
  index  |      Chromosome    Start      End  Strand      lengths
  int64  |           int64    int64    int64  object        int64
-------  ---  ------------  -------  -------  --------  ---------
      0  |               1      200      300  +               100
      0  |               1      300      332  +                32
      1  |               1      687      787  -               100
      1  |               1      600      687  -                87
PyRanges with 4 rows, 5 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> gs.window_ranges(100, use_strand=False)
  index  |      Chromosome    Start      End  Strand
  int64  |           int64    int64    int64  object
-------  ---  ------------  -------  -------  --------
      0  |               1      200      300  +
      0  |               1      300      332  +
      1  |               1      600      700  -
      1  |               1      700      787  -
PyRanges with 4 rows, 4 columns, and 1 index columns (with 2 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> gr2 = pr.example_data.ensembl_gtf.get_with_loc_columns(["Feature", "gene_name"])
>>> gr2
index    |    Chromosome    Start    End      Strand      Feature     gene_name
int64    |    category      int64    int64    category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  -----------
0        |    1             11868    14409    +           gene        DDX11L1
1        |    1             11868    14409    +           transcript  DDX11L1
2        |    1             11868    12227    +           exon        DDX11L1
3        |    1             12612    12721    +           exon        DDX11L1
...      |    ...           ...      ...      ...         ...         ...
7        |    1             120724   133723   -           transcript  AL627309.1
8        |    1             133373   133723   -           exon        AL627309.1
9        |    1             129054   129223   -           exon        AL627309.1
10       |    1             120873   120932   -           exon        AL627309.1
PyRanges with 11 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr2 = pr.example_data.ensembl_gtf.get_with_loc_columns(["Feature", "gene_name"])
>>> gr2.window_ranges(1000)
index    |    Chromosome    Start    End      Strand      Feature     gene_name
int64    |    category      int64    int64    category    category    object
-------  ---  ------------  -------  -------  ----------  ----------  -----------
0        |    1             11868    12868    +           gene        DDX11L1
0        |    1             12868    13868    +           gene        DDX11L1
0        |    1             13868    14409    +           gene        DDX11L1
1        |    1             11868    12868    +           transcript  DDX11L1
...      |    ...           ...      ...      ...         ...         ...
7        |    1             120724   121723   -           transcript  AL627309.1
8        |    1             133373   133723   -           exon        AL627309.1
9        |    1             129054   129223   -           exon        AL627309.1
10       |    1             120873   120932   -           exon        AL627309.1
PyRanges with 28 rows, 6 columns, and 1 index columns (with 17 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> gr3 = pr.PyRanges({'Chromosome':1, 'Strand':list('+++--'), 'Start':[10, 30, 50, 70, 90], 'End':[20, 40, 60, 80, 100], 'ID':list('aaabb')})
>>> gr3
  index  |      Chromosome  Strand      Start      End  ID
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  --------
      0  |               1  +              10       20  a
      1  |               1  +              30       40  a
      2  |               1  +              50       60  a
      3  |               1  -              70       80  b
      4  |               1  -              90      100  b
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr3.window_ranges(8, group_by='ID')
index    |    Chromosome    Strand    Start    End      ID
int64    |    int64         object    int64    int64    object
-------  ---  ------------  --------  -------  -------  --------
0        |    1             +         10       18       a
0        |    1             +         18       20       a
1        |    1             +         30       36       a
1        |    1             +         36       40       a
...      |    ...           ...       ...      ...      ...
3        |    1             -         74       80       b
3        |    1             -         70       74       b
4        |    1             -         92       100      b
4        |    1             -         90       92       b
PyRanges with 10 rows, 5 columns, and 1 index columns (with 5 index duplicates).
Contains 1 chromosomes and 2 strands.

>>> gr4 = pr.PyRanges({'Chromosome':2, 'Strand':list('+++--'), 'Start':[30,10,50,90,70],
...                    'End':[40,20,60,100,80], 'ID':['id1','id1','id1','id2','id2']})
>>> gr4
  index  |      Chromosome  Strand      Start      End  ID
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  --------
      0  |               2  +              30       40  id1
      1  |               2  +              10       20  id1
      2  |               2  +              50       60  id1
      3  |               2  -              90      100  id2
      4  |               2  -              70       80  id2
PyRanges with 5 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr4.window_ranges(8, group_by='ID').reset_index(drop=True).head(8)
  index  |      Chromosome  Strand      Start      End  ID
  int64  |           int64  object      int64    int64  object
-------  ---  ------------  --------  -------  -------  --------
      0  |               2  +              10       18  id1
      1  |               2  +              18       20  id1
      2  |               2  +              30       36  id1
      3  |               2  +              36       40  id1
      4  |               2  +              50       54  id1
      5  |               2  +              54       60  id1
      6  |               2  -              74       80  id2
      7  |               2  -              70       74  id2
PyRanges with 8 rows, 5 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.

>>> gr4.window_ranges(8, group_by='ID', add_window_id=True).reset_index(drop=True).head(8)
  index  |      Chromosome  Strand      Start      End  ID          window_id
  int64  |           int64  object      int64    int64  object          int64
-------  ---  ------------  --------  -------  -------  --------  -----------
      0  |               2  +              10       18  id1                 1
      1  |               2  +              18       20  id1                 2
      2  |               2  +              30       36  id1                 2
      3  |               2  +              36       40  id1                 3
      4  |               2  +              50       54  id1                 3
      5  |               2  +              54       60  id1                 4
      6  |               2  -              74       80  id2                 1
      7  |               2  -              70       74  id2                 2
PyRanges with 8 rows, 6 columns, and 1 index columns.
Contains 1 chromosomes and 2 strands.


####################################################################################################
class pyranges.range_frame.range_frame.RangeFrame
#################################################
Class for range based operations.

A table with Start and End columns. Parent class of PyRanges. Subclass of pandas DataFrame.


####################################################################################################
RangeFrame.cluster_overlaps()
#############################
Give overlapping intervals a common id.

Parameters
----------
match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

slack : int, default 0
    Length by which the criteria of overlap are loosened.
    A value of 1 clusters also bookended intervals.
    Higher slack values cluster more distant intervals (with a maximum distance of slack-1 between them).

cluster_column:
    Name the cluster column added in output. Default: "Cluster"

Returns
-------
RangeFrame
    RangeFrame with an ID-column "Cluster" added.

See Also
--------
RangeFrame.merge: combine overlapping intervals into one


####################################################################################################
RangeFrame.combine_interval_columns()
#####################################
Use two pairs of columns representing intervals to create a new start and end column.

The function is designed as post-processing after join_overlaps to aggregate the coordinates of the two intervals.
By default, the new start and end columns will be the intersection of the intervals.

Parameters
----------
function : {"intersect", "union", "swap"} or Callable, default "intersect"
    How to combine the self and other intervals: "intersect", "union", or "swap"
    If a callable is passed, it should take four Series arguments: start1, end1, start2, end2;
    and return a tuple of two integers: (new_starts, new_ends).

start : str, default "Start"
    Column name for Start of first interval
end : str, default "End"
    Column name for End of first interval
start2 : str, default "Start_b"
    Column name for Start of second interval
end2 : str, default "End_b"
    Column name for End of second interval
drop_old_columns : bool, default True
    Whether to drop the above mentioned columns.


####################################################################################################
RangeFrame.copy()
#################
Make a copy of this object's indices and data.

When ``deep=True`` (default), a new object will be created with a
copy of the calling object's data and indices. Modifications to
the data or indices of the copy will not be reflected in the
original object (see notes below).

When ``deep=False``, a new object will be created without copying
the calling object's data or index (only references to the data
and index are copied). Any changes to the data of the original
will be reflected in the shallow copy (and vice versa).

.. note::
    The ``deep=False`` behaviour as described above will change
    in pandas 3.0. `Copy-on-Write
    <https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html>`__
    will be enabled by default, which means that the "shallow" copy
    is that is returned with ``deep=False`` will still avoid making
    an eager copy, but changes to the data of the original will *no*
    longer be reflected in the shallow copy (or vice versa). Instead,
    it makes use of a lazy (deferred) copy mechanism that will copy
    the data only when any changes to the original or shallow copy is
    made.

    You can already get the future behavior and improvements through
    enabling copy on write ``pd.options.mode.copy_on_write = True``

Parameters
----------
deep : bool, default True
    Make a deep copy, including a copy of the data and the indices.
    With ``deep=False`` neither the indices nor the data are copied.

Returns
-------
Series or DataFrame
    Object type matches caller.

Notes
-----
When ``deep=True``, data is copied but actual Python objects
will not be copied recursively, only the reference to the object.
This is in contrast to `copy.deepcopy` in the Standard Library,
which recursively copies object data (see examples below).

While ``Index`` objects are copied when ``deep=True``, the underlying
numpy array is not copied for performance reasons. Since ``Index`` is
immutable, the underlying data can be safely shared and a copy
is not needed.

Since pandas is not thread safe, see the
:ref:`gotchas <gotchas.thread-safety>` when copying in a threading
environment.

When ``copy_on_write`` in pandas config is set to ``True``, the
``copy_on_write`` config takes effect even when ``deep=False``.
This means that any changes to the copied data would make a new copy
of the data upon write (and vice versa). Changes made to either the
original or copied variable would not be reflected in the counterpart.
See :ref:`Copy_on_Write <copy_on_write>` for more information.

Examples
--------
>>> s = pd.Series([1, 2], index=["a", "b"])
>>> s
a    1
b    2
dtype: int64

>>> s_copy = s.copy()
>>> s_copy
a    1
b    2
dtype: int64

**Shallow copy versus default (deep) copy:**

>>> s = pd.Series([1, 2], index=["a", "b"])
>>> deep = s.copy()
>>> shallow = s.copy(deep=False)

Shallow copy shares data and index with original.

>>> s is shallow
False
>>> s.values is shallow.values and s.index is shallow.index
True

Deep copy has own copy of data and index.

>>> s is deep
False
>>> s.values is deep.values or s.index is deep.index
False

Updates to the data shared by shallow copy and original is reflected
in both (NOTE: this will no longer be true for pandas >= 3.0);
deep copy remains unchanged.

>>> s.iloc[0] = 3
>>> shallow.iloc[1] = 4
>>> s
a    3
b    4
dtype: int64
>>> shallow
a    3
b    4
dtype: int64
>>> deep
a    1
b    2
dtype: int64

Note that when copying an object containing Python objects, a deep copy
will copy the data, but will not do so recursively. Updating a nested
data object will be reflected in the deep copy.

>>> s = pd.Series([[1, 2], [3, 4]])
>>> deep = s.copy()
>>> s[0][0] = 10
>>> s
0    [10, 2]
1     [3, 4]
dtype: object
>>> deep
0    [10, 2]
1     [3, 4]
dtype: object

**Copy-on-Write is set to true**, the shallow copy is not modified
when the original data is changed:

>>> with pd.option_context("mode.copy_on_write", True):
...     s = pd.Series([1, 2], index=["a", "b"])
...     copy = s.copy(deep=False)
...     s.iloc[0] = 100
...     s
a    100
b      2
dtype: int64
>>> copy
a    1
b    2
dtype: int64


####################################################################################################
RangeFrame.count_overlaps()
###########################
Count the number of overlaps per interval.

For each interval in self, count how many intervals in ``other`` overlap with it.
The overlap computation is based on the start and end coordinates, with an optional
``slack`` parameter to adjust the overlap threshold by temporarily extending the intervals.

Parameters
----------
other : RangeFrame
    The RangeFrame whose intervals are compared against those in self for overlap counting.
match_by : str or list, default None
    Column(s) to group intervals by when determining overlaps. Only intervals with equal values in the specified
    column(s) will be considered as overlapping.
slack : int, default 0
    Temporarily extend intervals in self by this many nucleotides before checking for overlaps,
    thereby adjusting the overlap threshold.

Returns
-------
pd.Series
    A pandas Series where each element corresponds to the number of overlapping intervals in ``other``
    for the corresponding interval in self.


####################################################################################################
RangeFrame.drop()
#################
Drop specified labels from rows or columns.

Remove rows or columns by specifying label names and corresponding
axis, or by directly specifying index or column names. When using a
multi-index, labels on different levels can be removed by specifying
the level. See the :ref:`user guide <advanced.shown_levels>`
for more information about the now unused levels.

Parameters
----------
labels : single label or list-like
    Index or column labels to drop. A tuple will be used as a single
    label and not treated as a list-like.
axis : {0 or 'index', 1 or 'columns'}, default 0
    Whether to drop labels from the index (0 or 'index') or
    columns (1 or 'columns').
index : single label or list-like
    Alternative to specifying axis (``labels, axis=0``
    is equivalent to ``index=labels``).
columns : single label or list-like
    Alternative to specifying axis (``labels, axis=1``
    is equivalent to ``columns=labels``).
level : int or level name, optional
    For MultiIndex, level from which the labels will be removed.
inplace : bool, default False
    If False, return a copy. Otherwise, do operation
    in place and return None.
errors : {'ignore', 'raise'}, default 'raise'
    If 'ignore', suppress error and only existing labels are
    dropped.

Returns
-------
DataFrame or None
    Returns DataFrame or None DataFrame with the specified
    index or column labels removed or None if inplace=True.

Raises
------
KeyError
    If any of the labels is not found in the selected axis.

See Also
--------
DataFrame.loc : Label-location based indexer for selection by label.
DataFrame.dropna : Return DataFrame with labels on given axis omitted
    where (all or any) data are missing.
DataFrame.drop_duplicates : Return DataFrame with duplicate rows
    removed, optionally only considering certain columns.
Series.drop : Return Series with specified index labels removed.

Examples
--------
>>> df = pd.DataFrame(np.arange(12).reshape(3, 4),
...                   columns=['A', 'B', 'C', 'D'])
>>> df
   A  B   C   D
0  0  1   2   3
1  4  5   6   7
2  8  9  10  11

Drop columns

>>> df.drop(['B', 'C'], axis=1)
   A   D
0  0   3
1  4   7
2  8  11

>>> df.drop(columns=['B', 'C'])
   A   D
0  0   3
1  4   7
2  8  11

Drop a row by index

>>> df.drop([0, 1])
   A  B   C   D
2  8  9  10  11

Drop columns and/or rows of MultiIndex DataFrame

>>> midx = pd.MultiIndex(levels=[['llama', 'cow', 'falcon'],
...                              ['speed', 'weight', 'length']],
...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],
...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])
>>> df = pd.DataFrame(index=midx, columns=['big', 'small'],
...                   data=[[45, 30], [200, 100], [1.5, 1], [30, 20],
...                         [250, 150], [1.5, 0.8], [320, 250],
...                         [1, 0.8], [0.3, 0.2]])
>>> df
                big     small
llama   speed   45.0    30.0
        weight  200.0   100.0
        length  1.5     1.0
cow     speed   30.0    20.0
        weight  250.0   150.0
        length  1.5     0.8
falcon  speed   320.0   250.0
        weight  1.0     0.8
        length  0.3     0.2

Drop a specific index combination from the MultiIndex
DataFrame, i.e., drop the combination ``'falcon'`` and
``'weight'``, which deletes only the corresponding row

>>> df.drop(index=('falcon', 'weight'))
                big     small
llama   speed   45.0    30.0
        weight  200.0   100.0
        length  1.5     1.0
cow     speed   30.0    20.0
        weight  250.0   150.0
        length  1.5     0.8
falcon  speed   320.0   250.0
        length  0.3     0.2

>>> df.drop(index='cow', columns='small')
                big
llama   speed   45.0
        weight  200.0
        length  1.5
falcon  speed   320.0
        weight  1.0
        length  0.3

>>> df.drop(index='length', level=1)
                big     small
llama   speed   45.0    30.0
        weight  200.0   100.0
cow     speed   30.0    20.0
        weight  250.0   150.0
falcon  speed   320.0   250.0
        weight  1.0     0.8


####################################################################################################
RangeFrame.drop_and_return()
############################



####################################################################################################
RangeFrame.join_overlaps()
##########################
Join RangeFrame objects based on overlapping intervals.

Find pairs of overlapping intervals between self and other and combine their attributes.
Each row in the output contains columns from both intervals, including their start and end positions.
By default, only overlapping intervals are included, but the join_type parameter controls how intervals
without overlaps are handled.

Parameters
----------
other : RangeFrame
    The RangeFrame to join with.
join_type : {"inner", "left", "right", "outer"}, default "inner"
    Specifies how to handle intervals that do not overlap. "inner" returns only overlapping intervals,
    "left" returns all intervals from self (with missing values for non-overlapping intervals from other),
    "right" returns all intervals from other, and "outer" returns all intervals from both.
multiple : {"all", "first", "last"}, default "all"
    Determines which overlapping interval(s) to report when multiple intervals in other overlap the same interval in self.
    "all" reports all overlaps (which may lead to duplicate rows), "first" reports only the overlapping interval with
    the smallest start in other, and "last" reports only the overlapping interval with the largest end in other.
match_by : str or list, default None
    If provided, only intervals with matching values in the specified column(s) will be joined.
slack : int, default 0
    Temporarily extend intervals in self by this many units on both ends before checking for overlaps.
suffix : str, default JOIN_SUFFIX
    Suffix to append to columns from the other RangeFrame in the output.
contained_intervals_only : bool, default False
    If True, only join intervals from self that are entirely contained within an interval from other.
report_overlap_column : str or None, default None
    If provided, add a column with this name reporting the amount of overlap between joined intervals.
    The overlap is computed as the minimum of the end positions minus the maximum of the start positions.

Returns
-------
RangeFrame
    A new RangeFrame containing the joined intervals with columns from both input RangeFrames.
    The indices of the input RangeFrames are not preserved in the output.

Notes
-----
Attributes from the other RangeFrame may have their column names modified by appending the specified suffix.


####################################################################################################
RangeFrame.max_disjoint_overlaps()
##################################
Find the maximal disjoint set of intervals.

Returns a subset of the rows in self so that no two intervals overlap, choosing those that
maximize the number of intervals in the result.

Parameters
----------
slack : int, default 0
    Length by which the criteria of overlap are loosened.
    A value of 1 implies that bookended intervals are considered overlapping.
    Higher slack values allow more distant intervals (with a maximum distance of slack-1 between them).

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

Returns
-------
RangeFrame
    RangeFrame with maximal disjoint set of intervals.

See Also
--------
RangeFrame.merge_overlaps : merge intervals into non-overlapping superintervals
RangeFrame.cluster : annotate overlapping intervals with common ID


####################################################################################################
RangeFrame.merge_overlaps()
###########################
Merge overlapping intervals into one.

Merge overlapping intervals into a single superinterval by uniting intervals that overlap,
optionally allowing a small gap (specified by ``slack``) between intervals to be merged. The resulting
RangeFrame will contain the merged intervals, and if ``count_col`` is provided, a column with the counts
of merged intervals will be included.

Parameters
----------
count_col : str or None, default None
    Name of the column to store the count of intervals merged into each superinterval.
    If None, no count column is added.
match_by : str or list, default None
    Column(s) to group intervals by before merging. Only intervals with equal values in the specified
    column(s) will be considered as overlapping.
slack : int, default 0
    Allow this many nucleotides between intervals to still consider them overlapping.

Returns
-------
RangeFrame
    A RangeFrame with merged (super) intervals. Metadata columns, index, and order are not necessarily preserved.


####################################################################################################
RangeFrame.nearest_ranges()
###########################
Find closest interval.

For each interval in self RangeFrame, the columns of the nearest interval in other RangeFrame are appended.

Parameters
----------
other : RangeFrame
    RangeFrame to find nearest interval in.

exclude_overlaps : bool, default True
    Whether to not report intervals of others that overlap with self as the nearest ones.

direction : {"any", "forward", "backward"}, default "any", i.e. both directions
    Whether to only look for nearest in one direction.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be matched.

k : int, default 1
    Number of nearest intervals to fetch.

suffix : str, default "_b"
    Suffix to give columns with shared name in other.

dist_col : str or None
    Optional column to store the distance in.

Returns
-------
RangeFrame

    A RangeFrame with columns representing nearest interval horizontally appended.

See Also
--------
RangeFrame.join_overlaps : Has a slack argument to find intervals within a distance.


####################################################################################################
RangeFrame.overlap()
####################
Return overlapping intervals.

Returns the intervals in self which overlap with those in other.

Parameters
----------
other : RangeFrame
    RangeFrame to find overlaps with.

multiple : {"all", "first", "last"}, default "all"
    What intervals to report when multiple intervals in 'other' overlap with the same interval in self.
    The default "all" reports all overlapping subintervals, which will have duplicate indices.
    "first" reports only, for each interval in self, the overlapping subinterval with smallest Start in 'other'
    "last" reports only the overlapping subinterval with the biggest End in 'other'

slack : int, default 0
    Intervals in self are temporarily extended by slack on both ends before overlap is calculated, so that
    we allow non-overlapping intervals to be considered overlapping if they are within less than slack distance
    e.g. slack=1 reports bookended intervals.

contained_intervals_only : bool, default False
    Whether to report only intervals that are entirely contained in an interval of 'other'.

match_by : str or list, default None
    If provided, only overlapping intervals with an equal value in column(s) `match_by` are reported.

Returns
-------
RangeFrame

    A RangeFrame with overlapping intervals.

See Also
--------
RangeFrame.intersect : report overlapping subintervals
RangeFrame.set_intersect : set-intersect RangeFrame (e.g. merge then intersect)


####################################################################################################
RangeFrame.reasons_why_frame_is_invalid()
#########################################



####################################################################################################
RangeFrame.reindex()
####################
Conform DataFrame to new index with optional filling logic.

Places NA/NaN in locations having no value in the previous index. A new object
is produced unless the new index is equivalent to the current one and
``copy=False``.

Parameters
----------

labels : array-like, optional
    New labels / index to conform the axis specified by 'axis' to.
index : array-like, optional
    New labels for the index. Preferably an Index object to avoid
    duplicating data.
columns : array-like, optional
    New labels for the columns. Preferably an Index object to avoid
    duplicating data.
axis : int or str, optional
    Axis to target. Can be either the axis name ('index', 'columns')
    or number (0, 1).
method : {None, 'backfill'/'bfill', 'pad'/'ffill', 'nearest'}
    Method to use for filling holes in reindexed DataFrame.
    Please note: this is only applicable to DataFrames/Series with a
    monotonically increasing/decreasing index.

    * None (default): don't fill gaps
    * pad / ffill: Propagate last valid observation forward to next
      valid.
    * backfill / bfill: Use next valid observation to fill gap.
    * nearest: Use nearest valid observations to fill gap.

copy : bool, default True
    Return a new object, even if the passed indexes are the same.

    .. note::
        The `copy` keyword will change behavior in pandas 3.0.
        `Copy-on-Write
        <https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html>`__
        will be enabled by default, which means that all methods with a
        `copy` keyword will use a lazy copy mechanism to defer the copy and
        ignore the `copy` keyword. The `copy` keyword will be removed in a
        future version of pandas.

        You can already get the future behavior and improvements through
        enabling copy on write ``pd.options.mode.copy_on_write = True``
level : int or name
    Broadcast across a level, matching Index values on the
    passed MultiIndex level.
fill_value : scalar, default np.nan
    Value to use for missing values. Defaults to NaN, but can be any
    "compatible" value.
limit : int, default None
    Maximum number of consecutive elements to forward or backward fill.
tolerance : optional
    Maximum distance between original and new labels for inexact
    matches. The values of the index at the matching locations most
    satisfy the equation ``abs(index[indexer] - target) <= tolerance``.

    Tolerance may be a scalar value, which applies the same tolerance
    to all values, or list-like, which applies variable tolerance per
    element. List-like includes list, tuple, array, Series, and must be
    the same size as the index and its dtype must exactly match the
    index's type.

Returns
-------
DataFrame with changed index.

See Also
--------
DataFrame.set_index : Set row labels.
DataFrame.reset_index : Remove row labels or move them to new columns.
DataFrame.reindex_like : Change to same indices as other DataFrame.

Examples
--------
``DataFrame.reindex`` supports two calling conventions

* ``(index=index_labels, columns=column_labels, ...)``
* ``(labels, axis={'index', 'columns'}, ...)``

We *highly* recommend using keyword arguments to clarify your
intent.

Create a dataframe with some fictional data.

>>> index = ['Firefox', 'Chrome', 'Safari', 'IE10', 'Konqueror']
>>> df = pd.DataFrame({'http_status': [200, 200, 404, 404, 301],
...                   'response_time': [0.04, 0.02, 0.07, 0.08, 1.0]},
...                   index=index)
>>> df
           http_status  response_time
Firefox            200           0.04
Chrome             200           0.02
Safari             404           0.07
IE10               404           0.08
Konqueror          301           1.00

Create a new index and reindex the dataframe. By default
values in the new index that do not have corresponding
records in the dataframe are assigned ``NaN``.

>>> new_index = ['Safari', 'Iceweasel', 'Comodo Dragon', 'IE10',
...              'Chrome']
>>> df.reindex(new_index)
               http_status  response_time
Safari               404.0           0.07
Iceweasel              NaN            NaN
Comodo Dragon          NaN            NaN
IE10                 404.0           0.08
Chrome               200.0           0.02

We can fill in the missing values by passing a value to
the keyword ``fill_value``. Because the index is not monotonically
increasing or decreasing, we cannot use arguments to the keyword
``method`` to fill the ``NaN`` values.

>>> df.reindex(new_index, fill_value=0)
               http_status  response_time
Safari                 404           0.07
Iceweasel                0           0.00
Comodo Dragon            0           0.00
IE10                   404           0.08
Chrome                 200           0.02

>>> df.reindex(new_index, fill_value='missing')
              http_status response_time
Safari                404          0.07
Iceweasel         missing       missing
Comodo Dragon     missing       missing
IE10                  404          0.08
Chrome                200          0.02

We can also reindex the columns.

>>> df.reindex(columns=['http_status', 'user_agent'])
           http_status  user_agent
Firefox            200         NaN
Chrome             200         NaN
Safari             404         NaN
IE10               404         NaN
Konqueror          301         NaN

Or we can use "axis-style" keyword arguments

>>> df.reindex(['http_status', 'user_agent'], axis="columns")
           http_status  user_agent
Firefox            200         NaN
Chrome             200         NaN
Safari             404         NaN
IE10               404         NaN
Konqueror          301         NaN

To further illustrate the filling functionality in
``reindex``, we will create a dataframe with a
monotonically increasing index (for example, a sequence
of dates).

>>> date_index = pd.date_range('1/1/2010', periods=6, freq='D')
>>> df2 = pd.DataFrame({"prices": [100, 101, np.nan, 100, 89, 88]},
...                    index=date_index)
>>> df2
            prices
2010-01-01   100.0
2010-01-02   101.0
2010-01-03     NaN
2010-01-04   100.0
2010-01-05    89.0
2010-01-06    88.0

Suppose we decide to expand the dataframe to cover a wider
date range.

>>> date_index2 = pd.date_range('12/29/2009', periods=10, freq='D')
>>> df2.reindex(date_index2)
            prices
2009-12-29     NaN
2009-12-30     NaN
2009-12-31     NaN
2010-01-01   100.0
2010-01-02   101.0
2010-01-03     NaN
2010-01-04   100.0
2010-01-05    89.0
2010-01-06    88.0
2010-01-07     NaN

The index entries that did not have a value in the original data frame
(for example, '2009-12-29') are by default filled with ``NaN``.
If desired, we can fill in the missing values using one of several
options.

For example, to back-propagate the last valid value to fill the ``NaN``
values, pass ``bfill`` as an argument to the ``method`` keyword.

>>> df2.reindex(date_index2, method='bfill')
            prices
2009-12-29   100.0
2009-12-30   100.0
2009-12-31   100.0
2010-01-01   100.0
2010-01-02   101.0
2010-01-03     NaN
2010-01-04   100.0
2010-01-05    89.0
2010-01-06    88.0
2010-01-07     NaN

Please note that the ``NaN`` value present in the original dataframe
(at index value 2010-01-03) will not be filled by any of the
value propagation schemes. This is because filling while reindexing
does not look at dataframe values, but only compares the original and
desired indexes. If you do want to fill in the ``NaN`` values present
in the original dataframe, use the ``fillna()`` method.

See the :ref:`user guide <basics.reindexing>` for more.


####################################################################################################
RangeFrame.sort_by_position()
#############################
Sort by Start and End columns.


####################################################################################################
RangeFrame.sort_ranges()
########################
Sort RangeFrame according to Start, End, and any other columns given.

For uses not covered by this function, use  DataFrame.sort_values().

Parameters
----------
by : str or list of str, default None
    in the desired order as part of the 'by' argument.

natsort : bool, default False
    Whether to use natural sorting for the columns in match_by.

sort_rows_reverse_order : sequence of bools or None
    Whether to sort these rows in the reverse order for the starts and ends.

Returns
-------
RangeFrame

    Sorted RangeFrame. The index is preserved. Use .reset_index(drop=True) to reset the index.


####################################################################################################
RangeFrame.subtract_overlaps()
##############################
Subtract intervals, i.e. return non-overlapping subintervals.

Identify intervals in other that overlap with intervals in self; return self with the overlapping parts removed.

Parameters
----------
other:
    RangeFrame to subtract.

match_by : str or list, default None
    If provided, only intervals with an equal value in column(s) `match_by` may be considered as overlapping.

Returns
-------
RangeFrame
    RangeFrame with subintervals from self that do not overlap with any interval in other.
    Columns and index are preserved.

Warning
-------
The returned Pyranges may have index duplicates. Call .reset_index(drop=True) to fix it.

See Also
--------
RangeFrame.overlap : use with invert=True to return all intervals without overlap
RangeFrame.complement_ranges : return the internal complement_ranges of intervals, i.e. its introns.
